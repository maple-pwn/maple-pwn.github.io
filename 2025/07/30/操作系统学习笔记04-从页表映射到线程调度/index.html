<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Maple"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://maple-pwn.github.io/2025/07/30/操作系统学习笔记04-从页表映射到线程调度/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="操作系统学习笔记04-从页表映射到线程调度"><meta property="og:url" content="http://maple-pwn.github.io/2025/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-%E4%BB%8E%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E5%88%B0%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/index.html"><meta property="og:site_name" content="Maple"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2025-07-30T09:02:18.000Z"><meta property="article:modified_time" content="2025-07-30T09:18:58.352Z"><meta property="article:author" content="Maple"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/1.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/1.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/1.svg"><title>操作系统学习笔记04-从页表映射到线程调度 | Maple</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"maple-pwn.github.io",root:"/",language:"zh-CN",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Maple's blog",subtitle:{text:["lucky day"],hitokoto:{enable:!1,show_author:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/maple-pwn",email:"3079403765@qq.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!0,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Github:{path:"https://github.com/maple-pwn",icon:"fa-brands fa-github"},Bookmarks:{icon:"fa-solid fa-bookmark",path:"/bookmarks/"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur",bookmark_colum:3},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Tags:{path:"/tags",icon:"fa-solid fa-tags"},Categories:{path:"/categories",icon:"fa-solid fa-list"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2025/4/5 00:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><link rel="stylesheet" href="/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Maple</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a target="_blank" rel="noopener" href="https://github.com/maple-pwn"><i class="fa-brands fa-github fa-fw"></i> GITHUB</a></li><li class="navbar-item"><a href="/bookmarks/"><i class="fa-solid fa-bookmark fa-fw"></i> BOOKMARKS</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-solid fa-box-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" target="_blank" rel="noopener" href="https://github.com/maple-pwn"><span>GITHUB </span><i class="fa-brands fa-github fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bookmarks/"><span>BOOKMARKS </span><i class="fa-solid fa-bookmark fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-solid fa-list fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">9</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">操作系统学习笔记04-从页表映射到线程调度</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/1.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Maple</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-07-30 17:02:18</span> <span class="mobile">2025-07-30 17:02:18</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-07-30 17:18:58</span> <span class="mobile">2025-07-30 17:18:58</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/OS/">OS</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/OS/">OS</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="0x0a-内存管理"><a href="#0x0a-内存管理" class="headerlink" title="0x0a 内存管理"></a>0x0a 内存管理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>断言</strong>，是一种用于调试的工具，用于在运行的时候检查某个条件是否为真</p><p>而这里实现的主要是<strong>内核级断言</strong>ASSERT，他是一种运行时自检工具，用于在开发或调试阶段强制验证内核状态是否正确，一旦失败可能引发系统崩溃(kernel panic)</p><p>实现也很简单，如下</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * debug.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL_DEBUG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_DEBUG_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic_spin</span><span class="params">(<span class="type">char</span>* filename, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* func, <span class="type">const</span> <span class="type">char</span>* condition)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PANIC(...) panic_spin(__FILE__, __LINE__, __func__, __VA_ARGS__)   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ASSERT(CONDITION) ((void)0)   </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>                                  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ASSERT(CONDITION) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span>(CONDITION)&#123;&#125;<span class="keyword">else</span>&#123;    \               </span></span><br><span class="line">  <span class="comment">/* 符号#让编译器将宏的参数转化为字符串面量 */</span> \       </span><br><span class="line">  PANIC(#CONDITION); \                 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__NDEBUG*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*__KERNEL_DEBUG_H*/</span></span></span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * debug.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;interrupt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印文件名、行号、函数名、条件并使程序悬停 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">panic_spin</span><span class="params">(<span class="type">char</span>* filename, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span>* func, <span class="type">const</span> <span class="type">char</span>* condition)</span>&#123;</span><br><span class="line">  intr_disable();                   <span class="comment">//这里先关中断，免得别的中断打扰</span></span><br><span class="line">  put_str(<span class="string">&quot;\n\n\n!!! error !!!\n&quot;</span>);</span><br><span class="line">  put_str(<span class="string">&quot;filename:&quot;</span>);</span><br><span class="line">  put_str(filename);</span><br><span class="line">  put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  put_str(<span class="string">&quot;line:0x&quot;</span>);</span><br><span class="line">  put_int(line);</span><br><span class="line">  put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  put_str(<span class="string">&quot;condition:&quot;</span>);</span><br><span class="line">  put_str(condition);</span><br><span class="line">  put_str(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>位是指bit，即字节中的位，一个字节有8位，图是指map，本质上就是映射的意思。也就是说，<strong>位图就是用字节中的1位来映射其它单位大小的资源</strong>，按位与资源之间是一对一的关系</p><p>这里实现的位图比较简单，一个bit代表一个页，若这个页被分配处去，那我们就将该bit置为1，否则为0，如下图所示</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250715144224310.png" alt="image-20250715144224310"></p><h4 id="内存管理系统"><a href="#内存管理系统" class="headerlink" title="内存管理系统"></a>内存管理系统</h4><p>在保护模式下，程序地址编程了虚拟地址，虚拟地址对应的物理地址是由分页机制做的映射。因此，在分页机制下有了虚拟、物理这两种地址，操作系统有责任把这两种地址分别管理。并通过页表将这两类地址关联。接下来讨论的就是有关这两类地址的<strong>内存池</strong>规划问题</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>内存池</p></div><div class="notel-content"><p>可以认为是一个内存仓库，我们将可用的内存地址集中放到一起，需要的时候直接从里面取出，用完再放回去。由于在分页机制下有了虚拟地址和物理地址，为了有效地管理它们，我们需要创建虚拟内存地址池和物理内存地址池</p><p><strong>物理内存池</strong></p><p>无论如何，内核和用户进程肯定都要运行在物理内存之中，那么哪些物理内存用来运行内核，哪些物理内存用来运行用户进程就成了物理内存池的关键优化问题</p><p>一种可行的方式是将物理内存划分为两部分，一部分只用来运行内核，另一部分只用来运行用户进程。两者互不打扰</p><p><strong>虚拟内存池</strong></p><p>系统运行在分页机制下，不管是内核还是用户程序都是用的虚拟地址。当它们需要申请内存的时候，内存管理系统先是从他们各自的虚拟内存池中分配出一块空闲的虚拟地址，然后再转去物理内存池找到块空闲的物理内存，然后再将这两种地址建立好映射关系</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250715155514963.png" alt="image-20250715155514963"></p></div></div><p><strong>分配页内存</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>32位虚拟地址转换过程 点击查看详细</summary><div class="content"><ol><li>高10位是页目录项pde的索引，用于在页目录表中定位pde，细节是处理获取高10位后自动将其乘以4，再加上页目录表的物理地址，这样就得到了ped索引对应的ped所在的物理地址，然后自动在该物理地址中获取保存的页表物理地址</li><li>中间10位是页表项pte的索引，用于在页表中定位pte。细节是处理器获取中间10位后自动将其乘以4，再加上第一步中得到的页表的物理地址，这样就得到了pte索引对应的pte所在的物理地址，然后自动在该物理地址中获取保存的普通物理页的物理地址</li><li>低12位是物理页内的偏移量，页大小是4KB，12位可寻址的范围正好是4KB，因此处理器便直接把低12位作为第二步中获取的物理页的偏移量，无需乘以4。用物理页的物理地址加上这低12位的和便是这32位虚拟地址最终落向的物理地址</li></ol><pre class="mermaid">flowchart TD    A[32位虚拟地址] --> B1[高10位\n(31~22)\n页目录索引 PDE]    A --> B2[中10位\n(21~12)\n页表索引 PTE]    A --> B3[低12位\n(11~0)\n页内偏移 Offset]    B1 --> C1[从 CR3 获取\n页目录物理地址]    C1 --> D1[计算：\nPDE 地址 = CR3 + 索引×4]    D1 --> E1[读取 PDE，得到\n页表基址]    B2 --> C2[计算：\nPTE 地址 = 页表基址 + 索引×4]    C2 --> D2[读取 PTE，得到\n物理页基址]    B3 --> D2    D2 --> F[最终物理地址 =\n物理页基址 + 偏移]    class A entry;    class B1,B2,B3 index;    class C1,D1,E1,C2,D2 logic;    class F result;    classDef entry fill:#fffaf0,stroke:#6a5acd,stroke-width:2px,color:#000;    classDef index fill:#f0f8ff,stroke:#1e90ff,color:#000;    classDef logic fill:#e6ffe6,stroke:#2e8b57,color:#000;    classDef result fill:#ffe4e1,stroke:#ff6347,stroke-width:2px,color:#000;    subgraph 虚拟地址分解        B1        B2        B3    end    subgraph 地址转换流程        C1        D1        E1        C2        D2    end</pre></div></details><p>分配页表中，我们需要做的事有三件：</p><ol><li>首先在虚拟内存中申请虚拟地址，然后在虚拟内存池的位图中将他们置为1</li><li>然后我们在物理内存池中申请一定量的物理页框，同样的也要在对应的物理内存池的位图中将其置为1</li><li>然后我们再访问到对应页目录项页目录表，然后修改其中的值依次来实现虚拟地址与物理地址的映射</li></ol><p>以下是映射部分的代码</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">page_table_add</span><span class="params">(<span class="type">void</span>* _vaddr, <span class="type">void</span>* _page_phyaddr)</span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> vaddr = (<span class="type">uint32_t</span>)_vaddr,page_phyaddr = (<span class="type">uint32_t</span>)_page_phyaddr;</span><br><span class="line">  <span class="type">uint32_t</span>* pde = pde_ptr(vaddr);</span><br><span class="line">  <span class="type">uint32_t</span>* pte = pte_ptr(vaddr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************** 注意 **********************************</span></span><br><span class="line"><span class="comment"> * 执行*pte会访问到空的pde，所以确保pde创建完成后才能执行*pte,</span></span><br><span class="line"><span class="comment"> * 否则会引发page_fault。因此在*pde为0的时候，*pte只能出现在下面else语句块中的*pde后面</span></span><br><span class="line"><span class="comment"> * **********************************************************************/</span></span><br><span class="line">  <span class="comment">/* 先在页目录内判断目录项的P位，若为1则表示该表已经存在 */</span></span><br><span class="line">  <span class="keyword">if</span>(*pde &amp; <span class="number">0x00000001</span>)&#123;</span><br><span class="line">    <span class="comment">//页目录项和页表项的第0位为p，这里是判断页目录项是否存在</span></span><br><span class="line">    ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));   <span class="comment">//这里若是说以前有已经装载的物理页框，则会报错</span></span><br><span class="line">    <span class="keyword">if</span>(!(*pte &amp; <span class="number">0x00000001</span>))&#123;</span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      PANIC(<span class="string">&quot;pte repeat&quot;</span>);      <span class="comment">//ASSERT的内置函数</span></span><br><span class="line">      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//页目录项不存在，所以需要先创建页目录再创建页表项</span></span><br><span class="line">    <span class="comment">/* 页表中的页框一律从内核空间分配 */</span></span><br><span class="line">    <span class="type">uint32_t</span> pde_phyaddr = (<span class="type">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line">    *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">    <span class="comment">/* 分配到的物理页地址pde_phyaddr对应的物理内存清0,</span></span><br><span class="line"><span class="comment">     * 避免里面的旧数据变成页表项，从而让页表混乱</span></span><br><span class="line"><span class="comment">     * 访问到pde对应的物理地址，用pte取高20位即可</span></span><br><span class="line"><span class="comment">     * 因为pte基于该pde对应的物理地址内再寻址，</span></span><br><span class="line"><span class="comment">     * 把低12位置0便是该pde对应的物理页的起始 */</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)((<span class="type">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line">    ASSERT(!(*pte &amp; <span class="number">0x00000001</span>));</span><br><span class="line">    *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="0x0b-内核多线程机制"><a href="#0x0b-内核多线程机制" class="headerlink" title="0x0b 内核多线程机制"></a>0x0b 内核多线程机制</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>为了充分利用计算机硬件资源，要让计算机尽可能“同时”多做一些工作。“工作”是由处理器执行某段程序代码来完成的，这段程序代码就称为<strong>进程</strong>，一个进程可以完成一项工作。</p><p>有的时候，工作往往并不简单，它由多个“子工作”组成，因此，我们需要让进程尽可能“同时”多做一些子工作，这些子工作也得由程序代码完成，完成这些子工作的程序就是<strong>线程</strong></p></blockquote><p><strong>执行流</strong></p><p>假设任务A需要一天时间，任务B需要2分钟，那么在串行的任务执行下，用户想要任务B的结果需要等上一整天，这是极其低效的。</p><p>于是在处理器数量不变的情况下，多任务操作系统出现了，它采用一种称为<strong>多道程序设计</strong>的方式，使处理器在所有任务之间来回切换，这样就给用户一种所有任务都并行运行的错觉，称之为“伪并行”。</p><p>如下图所示，处理器固定在圆心，任务就像轮盘一样，由任务调度器把任务转动到处理器的箭头处，表示CPU运行</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250715165243740.png" alt="image-20250715165243740"></p><p>一个处理器任意时刻只能执行一个任务，真正的并行是指多个处理器同时工作，一台计算机的并行能力取决于其物理处理器的数量。也就是说，目前本来只有1个处理器，但现在一定要兼顾所有任务，唯一的做法就是让每个任务都在处理器上执行一小会。</p><p>以上的任务轮转工作就是由<strong>任务调度器</strong>完成的</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>任务调度器</p></div><div class="notel-content"><p>就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。调度器在内核中维护一个任务表（也称为进程表、线程表或调度表），然后按照一定的算法，从任务表中选择一个任务，然后把该任务放到处理器上运行，当任务运行的实践片到期后，再从任务表中找另一个任务放到处理器上运行</p></div></div><p>回归主题，我们的处理器只知道加电后按照程序计数器中的地址不断地进行执行下去，在不断执行地过程中，我们把程序计数器中地下一条指令地址所组成地执行轨迹称为程序的<strong>控制执行流</strong>。换句话说，<strong>执行流</strong>就是一段逻辑上独立的指令区域，是人为给处理器安排的处理单元。</p><p>其实，软件中所作的任务切换，本质上就是改变了处理中程序计数器的指向，即改变了处理器的“执行流”</p><p>而所谓的<strong>独立的执行流</strong>，其实就是线程和进程</p><p><strong>线程到底是什么</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>做一个简单的lab 点击查看详细</summary><div class="content"><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* _arg)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> * arg = _arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; new thread tid is %u\n&quot;</span>, *arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">pthread_t</span> new_thread_id;</span><br><span class="line">    pthread_create(&amp;new_thread_id, <span class="literal">NULL</span>, thread_func, &amp;new_thread_id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread tid is %u\n&quot;</span>, pthread_self());</span><br><span class="line">    usleep(<span class="number">100</span>);	<span class="comment">//不清楚新线程是否是在主线程结束之前被调用，所以在主线程最后加一个100ms的阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>编译并运行</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250721220946574.png" alt="image-20250721220946574"></p><p>可以发现，线程其实就是运行一段函数的载体</p></div></details><p>在高级语言中，线程是运行函数的另一种方式，也就是说，构建一套线程方法。例如POSIX线程库，让函数在此线程中调用，然后处理器去执行这个函数，因此线程的实际功能就是相当于调用了这个函数，从而让函数执行。</p><p>那么它和普通的函数调用区别在哪里呢？</p><p>一般情况下，函数是在调用它的线程的上下文中执行的。操作系统不会单独为某个函数创建新的调度实体，它只是作为线程执行流程的一部分被顺序执行。即，<strong>处理器并不是单独地执行它</strong></p><p>与普通函数调用不同，线程具有独立的执行上下文（如栈空间、寄存器状态等），这使得我们可以将某段函数作为线程的执行入口，并由调度器将该线程独立调度到处理器上执行，<strong>从而实现真正的并发执行。</strong></p><p>在支持多线程的操作系统中，线程通常是CPU调度的最小单位，而进程则是资源分配的基本单位。线程共享其所属进程的大部分资源，如地址空间、堆和打开的文件等，但每个线程拥有独立的执行栈、寄存器上下文等，用以维持自己的运行状态。通过这种机制，线程实现了轻量级并发，能够在不复制整个进程资源的情况下进行独立调度和执行。</p><p>这里进程、线程、资源之间的关系可以这样表达<code>进程 = 线程 + 资源</code></p><p><strong>程序、进程、线程</strong></p><p><strong>程序</strong> 是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像</p><p><strong>进程</strong> 是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈，使用的寄存器等</p><p>对于处理器来说，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是处理器的执行单元，或者称为调度单元，它们就是 <strong>线程</strong></p><p>可以认为，线程是在进程基础之上的二次并发</p><pre class="mermaid">graph TD
    A[程序] --> B[进程]
    B --> C[线程]
    A --> D[静态文件]
    B --> E[进程资源]
    C --> F[共享内存]

    A[程序] --> G[编译文件]
    B[进程] --> H[独立地址空间]
    C[线程] --> I[共享地址空间]

    classDef process fill:#E0F7FA,stroke:#00796B,stroke-width:2px;
    classDef thread fill:#FFEBEE,stroke:#D32F2F,stroke-width:2px;
    classDef program fill:#FFF3E0,stroke:#F57C00,stroke-width:2px;
    
    class A program;
    class B process;
    class C thread;</pre><p><strong>PCB——进程的身份证</strong></p><p>PCB(Process Control Block),程序控制块。用来记录与此进程相关的信息，比如进程状态、PID、优先级等，一般结构如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250722225456781.png" alt="image-20250722225456781"></p><p>每个金册灰姑娘都有自己的PCB，所有的PCB放在一个表格中维护，就是进程表，调度器可以根据这张表选择上处理器运行的进程，如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250722225637712.png" alt="image-20250722225637712"></p><ul><li><strong>进程状态</strong>：是指运行、就绪、阻塞等，这样调度器就知道他是否可以进行调度</li></ul><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>进程的状态 点击查看详细</summary><div class="content"><ul><li><strong>运行</strong>：进程处于运行状态时，它正被CPU调度并正在执行指令</li><li><strong>就绪</strong>：进程处于就绪状态时，它已经加载到内存并准备好执行，只是等等待操作系统将CPU分配给他。</li><li><strong>阻塞</strong>：进程处于阻塞状态时，它因为等待某些事件或资源（如I&#x2F;O操作、锁、信号量等）而无法继续执行</li></ul></div></details><ul><li><p><strong>时间片</strong>：时间为0的时候说明这个进程在处理器上的时间已经到了，这时候需要调度器进行调度</p></li><li><p><strong>页表</strong>：表示进程的地址空间，这个是进程独享的</p></li><li><p><strong>寄存器映像</strong>：用来保存进程的现场，进程在处理器上运行的时候，所有寄存器的值都将并保存在这里</p></li><li><p>0级内核特权栈位于PCB中，而寄存器映像一般保存在这里</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>线程分类解释</p></div><div class="notel-content"><p>标题中提到了<strong>内核线程</strong>，那么与之对应的，有一种<strong>用户进程</strong>，下面做一下解释</p><p>先说结论：</p><ol><li><p>内核线程：调度器由操作系统实现，但是切换线程需要压栈出栈来保护现场恢复现场</p></li><li><p>用户线程：调度器由用户实现，若一个线程阻塞，整个进程跟着阻塞</p></li></ol><p>详细可见下表：</p><table><thead><tr><th>维度</th><th>内核进程</th><th>用户进程</th></tr></thead><tbody><tr><td>所在空间</td><td>内核态（内核空间）</td><td>用户态（用户空间）</td></tr><tr><td>权限</td><td>高权限，能直接操作硬件与内存</td><td>低权限，需通过系统调用访问资源</td></tr><tr><td>创建方式</td><td>系统启动时由内核创建</td><td>用户运行程序时由内核创建</td></tr><tr><td>功能</td><td>管理资源，如调度、驱动、文件系统等</td><td>执行用户任务，如浏览器、编辑器等</td></tr><tr><td>出错影响</td><td>系统级崩溃或死机</td><td>进程崩溃，不影响系统</td></tr></tbody></table></div></div><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//thread/thread.c</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_stack</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="comment">/* 线程第一次执行的时候，eip指向带调用的函数kernel_thread</span></span><br><span class="line"><span class="comment">     * 其它时候，eip指向的switch_to的返回地址*/</span></span><br><span class="line">    <span class="type">void</span> (*eip) (thread_func* func, <span class="type">void</span>* func_arg);	<span class="comment">//表示一个地址变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/******以下仅供第一次被调度上CPU使用*******/</span></span><br><span class="line">    <span class="type">void</span>(*unused_retaddr);</span><br><span class="line">    thread_func* function;	<span class="comment">//由kernel_thread所调用的函数名</span></span><br><span class="line">    <span class="type">void</span>* func_arg;			<span class="comment">//由kernel_thread所调用的函数所需要的参数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure></div><p>这里定义的struct thread_stack有两个作用：</p><ol><li>线程首次运行的时候，线程栈用于存储创建线程所需要的相关数据。和线程有关的数据应该都在该PCB中，这样便于管理线程，避免为他们再单独维护数据空间。创建线程之初，要指定在线程中运行的函数以及参数，因此将他存放在我们的内核栈当中，而其中eip便保存的就是需要执行的函数</li><li>任务切换函数 switch_to中，这是线程已经处于正常运行后，线程所体现出来的作用，由于 switch_to 函数是汇编程序，从其返回时，必然要用到ret指令，因此为了同时满足这两个作用，我们最初现在线程栈中装入合适的返回地址以及参数，使得作用2中的switch_to的ret指令也满足创建线程时的作用1</li></ol><p>同时，这里虽然说是通过ret调用kernel_thread的，但是程序自身不知道，它认为自己时正常调用call指令过来的，所以它访问参数还是会从栈顶地址 $esp+4$开始访问第一个参数，所以我们需要填充一个4字节的无意义数据，这里充当他的返回地址，但实际上并不会返回</p><blockquote><p>这里很好的解释了为什么pwn题中，我们需要填充一个无效返回地址</p></blockquote><p><strong>多线程调度</strong></p><p>在thread.h中的PCB结构中新加几个数据，更新task_struct如下：</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进程或线程的PCB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>* self_kstack;        <span class="comment">//各内核线程都用自己的内核栈</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">task_status</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">  <span class="type">uint8_t</span> priority;             <span class="comment">//线程优先级</span></span><br><span class="line">  <span class="type">uint8_t</span> ticks;                <span class="comment">//每次在处理器上执行的时间滴答数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此任务自从上cpu运行后至今占用了多少cpu滴答数，</span></span><br><span class="line"><span class="comment">   * 也就是此任务执行了多久 */</span></span><br><span class="line">  <span class="type">uint32_t</span> elapsed_ticks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* general_tag的作用是用于线程在一般的队列中的结点 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* all_list_tag的作用是用于线程队列thread_all_list中的节点 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span>* pgdir;              <span class="comment">//进程自己页表的虚拟地址</span></span><br><span class="line">  <span class="type">uint32_t</span> stack_magic;         <span class="comment">//栈的边界标记，用于检测栈的溢出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>这里我们的<code>ticks</code>元素与<code>priority</code>配合使用，优先级越高，则处理器上执行该任务的时间片就越长，每次时钟中断都会将当前任务的<code>ticks</code>减1</p><p>以及<code>pgdir</code>，这里是指向的该进程任务自己的页表（虚拟地址，需要转换为物理地址），但如果是线程的话那么这里就是NULL</p><hr><p><strong>线程调度</strong></p><p>调度原理比较简单：当我们线程的PCB中ticks降为0的时候就进行任务调度，时钟每发生一次中断，那么他就会将ticks减1,然后时钟的中断处理程序调用调度器schedule，由他来将切换下一个线程，而调度器的主要任务就是读写就绪队列（也就是上面的thread_ready_list），增删其中的节点，修改其中的状态。<em>注意这里我们采取队列的先进先出(FIFO).</em></p><p>调度器按照队列先进先出的顺序，把就绪队列中的第1个节点作为下一个要运行的新线程，将该线程的状态设置为<code>TASK_RUNNING</code>,之后通过函数<code>switch_to</code>将新线程的寄存器环境恢复，这样新线程就开始执行</p><p>完整的调度过程需要三部分的配合：</p><ol><li>时钟中断处理函数</li><li>调度器<code>schedule</code></li><li>任务切换函数<code>switch_to</code></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="🔧-0x0a-内存管理模块总结"><a href="#🔧-0x0a-内存管理模块总结" class="headerlink" title="🔧 0x0a 内存管理模块总结"></a>🔧 <strong>0x0a 内存管理模块总结</strong></h3><p><strong>✅ 内核断言机制（调试基础）</strong></p><ul><li><code>ASSERT(CONDITION)</code> 是一种<strong>运行时断言</strong>，用于调试阶段检测内核内部状态是否正确。</li><li>一旦断言失败，调用 <code>PANIC(...)</code> 打印错误信息后<strong>中断系统运行</strong>（通过死循环保持错误现场）。</li></ul><p>✅ 位图与内存池</p><ul><li><strong>位图</strong>是最小单位为 bit 的资源分配方案，通常用于标记内存页是否被占用。</li><li><strong>物理内存池</strong>用于管理实际内存资源，划分内核态和用户态两部分。</li><li><strong>虚拟内存池</strong>用于为内核或进程申请虚拟地址空间，后续再与物理地址建立映射。</li></ul><p><strong>✅ 虚拟地址转换机制（分页机制）</strong></p><blockquote><p>虚拟地址（32 位）按 10-10-12 分为页目录索引、页表索引和页内偏移。</p></blockquote><ul><li>页目录项 PDE → 页表地址</li><li>页表项 PTE → 页框物理地址</li><li>偏移量 Offset → 最终物理地址内偏移</li></ul><p><strong>✅ 页表映射实现流程</strong></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text复制编辑1. 虚拟地址申请（虚拟内存池打标记）</span><br><span class="line">2. 物理页分配（物理内存池打标记）</span><br><span class="line">3. 建立页表映射（修改 PDE / PTE）</span><br></pre></td></tr></table></figure></div><ul><li>注意：先判断 PDE 是否存在再写入 PTE，否则会触发 <code>page_fault</code></li><li>典型函数：<code>page_table_add</code></li></ul><h3 id="🧵-0x0b-内核多线程机制总结"><a href="#🧵-0x0b-内核多线程机制总结" class="headerlink" title="🧵 0x0b 内核多线程机制总结"></a>🧵 <strong>0x0b 内核多线程机制总结</strong></h3><p><strong>✅ 概念梳理：程序、进程、线程</strong></p><table><thead><tr><th>概念</th><th>定义</th><th>特点</th></tr></thead><tbody><tr><td>程序</td><td>静态代码，尚未运行</td><td>是进程的代码模板</td></tr><tr><td>进程</td><td>程序 + 资源，操作系统调度的<strong>资源单位</strong></td><td>拥有独立地址空间与资源</td></tr><tr><td>线程</td><td>CPU 调度的最小单位，进程中的执行路径</td><td>多线程共享同一地址空</td></tr></tbody></table><blockquote><p><strong>进程 &#x3D; 资源 + 线程</strong></p></blockquote><p><strong>✅ 线程的本质</strong></p><ul><li><strong>线程是一个执行流 + 栈空间 + 寄存器上下文</strong></li><li>本质上就是 CPU 执行某个函数的<strong>调度实体</strong></li><li>与函数调用区别：<ul><li>函数运行在调用者的上下文中</li><li>线程拥有自己的上下文（栈、寄存器）可并发执行</li></ul></li></ul><p><strong>✅ 线程控制块 PCB（task_struct）</strong></p><ul><li>存储线程调度所需的信息：<ul><li>状态（就绪&#x2F;阻塞&#x2F;运行）</li><li>时间片 <code>ticks</code> 与总运行时间 <code>elapsed_ticks</code></li><li>内核栈指针、页表指针 <code>pgdir</code></li><li>链表节点用于双向挂载在队列中</li></ul></li></ul><p><strong>✅ 线程的创建过程（thread_stack）</strong></p><ul><li>首次执行：<ul><li>手动将 <code>kernel_thread</code> 和其参数压入线程栈</li><li>构造出能通过 <code>ret</code> 执行 <code>kernel_thread(func, arg)</code> 的栈帧</li></ul></li><li>正常切换：<ul><li>由汇编实现的 <code>switch_to</code> 利用 <code>ret</code> 恢复 eip、esp 实现切换</li></ul></li></ul><p><strong>✅ 内核线程调度机制</strong></p><p>三个核心模块协作：</p><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>⏰ <strong>时钟中断处理器</strong></td><td>每次中断时 <code>ticks--</code>，若为 0 则调度</td></tr><tr><td>📋 <strong>调度器 schedule()</strong></td><td>从就绪队列中取出下一个任务</td></tr><tr><td>🔄 <strong>上下文切换 switch_to()</strong></td><td>保存&#x2F;恢复寄存器状态，完成线程切换</td></tr></tbody></table><ul><li>采用<strong>时间片轮转 + FIFO</strong>调度策略</li><li>使用链表（如 <code>thread_ready_list</code>）管理任务队列</li></ul></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 操作系统学习笔记04-从页表映射到线程调度</li><li><strong>作者:</strong> Maple</li><li><strong>创建于 :</strong> 2025-07-30 17:02:18</li><li><strong>更新于 :</strong> 2025-07-30 17:18:58</li><li><strong>链接:</strong> https://github.com/maple-pwn/maple-pwn.github.io/2025/07/30/操作系统学习笔记04-从页表映射到线程调度/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/OS/">#OS</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2025/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8%E5%88%B0%E4%B8%AD%E6%96%AD/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">操作系统学习笔记03-从初始内核到中断</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">操作系统学习笔记04-从页表映射到线程调度</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x0a-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">0x0a 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x0b-%E5%86%85%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">0x0b 内核多线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1"><span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%94%A7-0x0a-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93"><span class="nav-text">🔧 0x0a 内存管理模块总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%A7%B5-0x0b-%E5%86%85%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="nav-text">🧵 0x0b 内核多线程机制总结</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2025</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Maple</a><p class="post-count space-x-0.5"><span>共撰写了 9 篇文章</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/localSearch.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/libs/mermaid.min.js"></script><script src="/js/build/plugins/mermaid.js"></script><script src="/js/build/libs/anime.min.js"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/bookmarkNav.js" type="module"></script></body></html>