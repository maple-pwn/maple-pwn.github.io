<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Maple"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://maple-pwn.github.io/2025/07/14/操作系统学习笔记03-从初始内核到中断/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="操作系统学习笔记03-从初始内核到中断"><meta property="og:url" content="http://maple-pwn.github.io/2025/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8%E5%88%B0%E4%B8%AD%E6%96%AD/index.html"><meta property="og:site_name" content="Maple"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2025-07-14T08:32:12.000Z"><meta property="article:modified_time" content="2025-07-14T08:45:18.508Z"><meta property="article:author" content="Maple"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/1.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/1.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/1.svg"><title>操作系统学习笔记03-从初始内核到中断 | Maple</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"maple-pwn.github.io",root:"/",language:"zh-CN",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Maple's blog",subtitle:{text:["lucky day"],hitokoto:{enable:!1,show_author:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/maple-pwn",email:"3079403765@qq.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!0,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Github:{path:"https://github.com/maple-pwn",icon:"fa-brands fa-github"},Bookmarks:{icon:"fa-solid fa-bookmark",path:"/bookmarks/"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur",bookmark_colum:3},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Tags:{path:"/tags",icon:"fa-solid fa-tags"},Categories:{path:"/categories",icon:"fa-solid fa-list"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2025/4/5 00:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><link rel="stylesheet" href="/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Maple</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a target="_blank" rel="noopener" href="https://github.com/maple-pwn"><i class="fa-brands fa-github fa-fw"></i> GITHUB</a></li><li class="navbar-item"><a href="/bookmarks/"><i class="fa-solid fa-bookmark fa-fw"></i> BOOKMARKS</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-solid fa-box-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" target="_blank" rel="noopener" href="https://github.com/maple-pwn"><span>GITHUB </span><i class="fa-brands fa-github fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bookmarks/"><span>BOOKMARKS </span><i class="fa-solid fa-bookmark fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-solid fa-list fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">操作系统学习笔记03-从初始内核到中断</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/1.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Maple</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-07-14 16:32:12</span> <span class="mobile">2025-07-14 16:32:12</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-07-14 16:45:18</span> <span class="mobile">2025-07-14 16:45:18</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/OS/">OS</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/OS/">OS</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="0x06-载入初始内核"><a href="#0x06-载入初始内核" class="headerlink" title="0x06 载入初始内核"></a>0x06 载入初始内核</h2><h3 id="0x06-00-基础知识"><a href="#0x06-00-基础知识" class="headerlink" title="0x06 00 基础知识"></a>0x06 00 基础知识</h3><p><strong>ELF文件</strong></p><p>每个文件都存在一个文件头，这个文件头里存放着包含这个文件的各种信息。</p><p>目标文件既会参与程序连接又会参与程序执行。处于方便性和效率考虑，根据过程的不同，目标文件格式提供了有其内容的两种并行视图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/object_file_format.png" alt="object_file_format"></p><p>首先是<strong>ELF heafer</strong>部分</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT   16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   e_ident[EI_NIDENT];	</span><br><span class="line">    <span class="comment">//Magic number（前4字节）；ELF文件内容如何解码等信息</span></span><br><span class="line">    ELF32_Half      e_type;</span><br><span class="line">    <span class="comment">//描述了ELF文件的类型</span></span><br><span class="line">    ELF32_Half      e_machine;</span><br><span class="line">    <span class="comment">//描述了文件面向的架构</span></span><br><span class="line">    ELF32_Word      e_version;</span><br><span class="line">    <span class="comment">//描述了ELF文件的版本号</span></span><br><span class="line">    ELF32_Addr      e_entry;</span><br><span class="line">    <span class="comment">//执行入口点，如果文件没有入口点，这个域保持0（4字节）</span></span><br><span class="line">    ELF32_Off       e_phoff;</span><br><span class="line">    <span class="comment">//*program header table*的offset，如果没有PH,则这个值是0</span></span><br><span class="line">    ELF32_Off       e_shoff;</span><br><span class="line">    <span class="comment">//section header table的offset,如果没有SH，则这个值是0</span></span><br><span class="line">    ELF32_Word      e_flags;</span><br><span class="line">    <span class="comment">//特定于处理器的标志，Intel架构一般都是0</span></span><br><span class="line">    ELF32_Half      e_ehsize;</span><br><span class="line">    <span class="comment">//ELF header的大小，32位的ELF是52字节，64位是64字节</span></span><br><span class="line">    ELF32_Half      e_phentsize;</span><br><span class="line">    <span class="comment">//program header table中每个入口的大小</span></span><br><span class="line">    ELF32_Half      e_phnum;</span><br><span class="line">    <span class="comment">//e_phentsize*e_phnum得到整个program header table的大小</span></span><br><span class="line">    ELF32_Half      e_shentsize;</span><br><span class="line">    <span class="comment">//section header table中entry的大小，即每个section header占多少字节</span></span><br><span class="line">    ELF32_Half      e_shnum;</span><br><span class="line">    <span class="comment">//同e_phnum</span></span><br><span class="line">    ELF32_Half      e_shstrndx;</span><br><span class="line">    <span class="comment">//section header string table index. 包含了section header table中section name string table。如果没有section name string table,e_shstrndx的值是SHN_UNDEF</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></div><p>这里可以用<code>readelf -h &lt;elffile&gt;</code>来读取文件头，例如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250630163211305.png" alt="image-20250630163211305"></p><p>接下来是**程序头表（Program Header Table)**部分</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ELF32_Word  p_type;</span><br><span class="line">    <span class="comment">//表示该段的类型</span></span><br><span class="line">    ELF32_Off   p_offset;</span><br><span class="line">    <span class="comment">//表示本段在文件中的偏移地址</span></span><br><span class="line">    ELF32_Addr  p_vaddr;</span><br><span class="line">    <span class="comment">//表示本段正在虚拟内存中的起始地址</span></span><br><span class="line">    ELF32_Addr  p_paddr;</span><br><span class="line">    <span class="comment">//仅用于与物理地址相关的系统中，因为System V忽略用户程序中所有的物理地址</span></span><br><span class="line">    ELF32_Word  p_filesz;</span><br><span class="line">    <span class="comment">//表示本段在文件中的大小</span></span><br><span class="line">    ELF32_Word  p_memsz;</span><br><span class="line">    <span class="comment">//表示本段子内存中的大小</span></span><br><span class="line">    ELF32_Word  p_flags;</span><br><span class="line">    <span class="comment">//指明本段的标志类型</span></span><br><span class="line">    ELF32_Word  p_align;</span><br><span class="line">    <span class="comment">//对齐方式</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></div><p>同样的可以使用<code>readelf -l &lt;file&gt;</code>来读取程序头，如下</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250630164046587.png" alt="image-20250630164046587"></p><h3 id="0x06-01-实现初始内核"><a href="#0x06-01-实现初始内核" class="headerlink" title="0x06 01 实现初始内核"></a>0x06 01 实现初始内核</h3><p>略去了就</p><h2 id="0x07-特权级"><a href="#0x07-特权级" class="headerlink" title="0x07 特权级"></a>0x07 特权级</h2><p>计算机里的一系列指令执行等操作都可以被认为是某个访问者来访问受访者。这里房屋内者和受访者都有属于自己的<strong>特权级</strong>，而特权级较低的访问者是不允许访问特权级较高的受访者。如下图，数字越小，特权级越高</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250630165008026.png" alt="image-20250630165008026"></p><p>其中，<strong>操作系统</strong>位于最内环的0级特权，他控制硬件，掌控各种核心数据。<strong>系统程序</strong>分别位于1级特权和2级特权，运行在这两层的程序一般是虚拟机、驱动程序等系统服务。<strong>用户程序</strong>在最外层，为3级特权</p><h4 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h4><p>即Task State Segment：任务状态段，它是每个任务都有的结构。其功能是<strong>任务切换和任务管理</strong>。结构如下：</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707105817635-1751857114382-1.png" alt="image-20250707105817635"></p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TSS</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> prev_tss;   <span class="comment">// 前一个任务的 TSS 链接（用于嵌套任务）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0;       <span class="comment">// Ring 0 的堆栈指针（用户态切换到内核态时用）</span></span><br><span class="line">    <span class="type">uint32_t</span> ss0;        <span class="comment">// Ring 0 的堆栈段选择子</span></span><br><span class="line">    <span class="type">uint32_t</span> esp1, ss1;  <span class="comment">// Ring 1（不常用）</span></span><br><span class="line">    <span class="type">uint32_t</span> esp2, ss2;  <span class="comment">// Ring 2（不常用）</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;        <span class="comment">// 页目录基址（页表）</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;        <span class="comment">// 程序计数器</span></span><br><span class="line">    <span class="type">uint32_t</span> eflags;     <span class="comment">// 状态寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> eax, ecx, edx, ebx;</span><br><span class="line">    <span class="type">uint32_t</span> esp, ebp, esi, edi;  <span class="comment">// 通用寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> es, cs, ss, ds, fs, gs; <span class="comment">// 段寄存器</span></span><br><span class="line">    <span class="type">uint32_t</span> ldt;         <span class="comment">// LDT 段选择子</span></span><br><span class="line">    <span class="type">uint16_t</span> trap;</span><br><span class="line">    <span class="type">uint16_t</span> iomap_base;  <span class="comment">// IO 权限位图起始偏移</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>上面的结构图告诉我们有三个栈顶<code>esp0、esp1、esp2</code>，分别对应3个特权级，用来保存相关的内容。而3号特权级栈，也即用户栈，它的切换是通过保存上下文来进行的</p><details class="bule" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>进程&&任务：点击查看更多</summary><div class="content"><p><strong>进程</strong>是程序的一次执行实例，是操作系统进行资源分配和调度的基本单位</p><ul><li>拥有独立的地址空间</li><li>拥有自己的代码段、数据段、堆、栈</li><li>有用系统资源（文件描述符、内存、信号量等）</li><li>每个进程都有一个唯一的PID</li></ul><p><strong>任务</strong>是一个更加广义的术语，在不同上下文中含义不太一样</p><table><thead><tr><th>上下文</th><th>含义</th></tr></thead><tbody><tr><td>Linux内核</td><td>任务 ≈ 一个执行单元，可能是进程或者线程</td></tr><tr><td>x86架构</td><td>指的是一个TSS表示的活动实体</td></tr><tr><td>一般语境</td><td>抽象的工作单元，比如某个需要执行的功能</td></tr></tbody></table><p><strong>任务vs进程（Linux角度）</strong></p><table><thead><tr><th>比较项</th><th>任务（Task）</th><th>进程（Process）</th></tr></thead><tbody><tr><td>定义</td><td>内核中的调度单元，使用 <code>task_struct</code> 表示</td><td>程序的执行实例，使用 PID 区分</td></tr><tr><td>范围</td><td>包含进程和线程</td><td>严格指拥有独立资源的执行体</td></tr><tr><td>地址空间</td><td>可共享（线程）或不共享（进程）</td><td>拥有独立地址空间</td></tr><tr><td>资源管理单位</td><td>否（线程间共享资源）</td><td>是（进程独立拥有资源）</td></tr><tr><td>调度单位</td><td>是</td><td>是（本质上由 <code>task_struct</code> 支持）</td></tr></tbody></table></div></details><p>特权级在变化的时候，需要用到不同特权级下的栈，当处理器进入不同特权级时，他会自动在TSS中找同特权级的栈</p><div class="note-large red"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>举个例子（从用户态中断进入内核态）</p></div><div class="notel-content"><p>假设现在的情况是：Ring3遭遇触发中断,则变化过程如下：</p><pre class="mermaid">flowchart 
  A[CPU检测特权级变化R3->0]:::step1
  B[从当前 GDT 中 TSS 描述符找到 TSS 地址]:::step2
  C[加载 TSS 中的 ESP0 和 SS0]:::step3
  D[切换堆栈为内核栈，并在其上压入旧的用户态 SS、ESP、EFLAGS、CS、EIP]:::step4
  E[跳转到中断处理程序执行]:::step5
  F[内核结束后通过 IRET 返回用户态]:::step6

  A --> B
  B --> C
  C --> D
  D --> E
  E --> F

  classDef step1 fill:#FF6347,stroke:#D32F2F,stroke-width:2px,color:white;
  classDef step2 fill:#FFD700,stroke:#F57C00,stroke-width:2px,color:white;
  classDef step3 fill:#1E90FF,stroke:#1976D2,stroke-width:2px,color:white;
  classDef step4 fill:#8A2BE2,stroke:#6A1B9A,stroke-width:2px,color:white;
  classDef step5 fill:#FF4500,stroke:#FF8C00,stroke-width:2px,color:white;
  classDef step6 fill:#228B22,stroke:#388E3C,stroke-width:2px,color:white;</pre></div></div><p>当然了，TSS和GDT一样是个数据结构，也自然如GDT一样需要相关的找到他的数据结构，GDT有GDTR，TSS有TR寄存器</p><h4 id="CPL和DPL"><a href="#CPL和DPL" class="headerlink" title="CPL和DPL"></a>CPL和DPL</h4><p>PL（Privilege Level）也就是CPU用来记录特权级高低的标识</p><p>RPL(Requestor Privilege Level)也就是<strong>请求特权级</strong>。它表示请求该段的程序的特权级，通常由段选择符中的特权级指定的</p><p>CPL(Current Privilege Level)也就是<strong>当前特权级</strong>。CPL的值由当前执行代码段的段选择符的特权级决定，通常会影响CPU如何执行指令和响应外部事件</p><p>DPL(Descriptor Privilege Level)也就是<strong>描述符特权级</strong>。每个段都有一个描述符，这些描述符包含了访问该段时所需的特权级要求。DPL的值决定了该段能否被具有相应CPL的程序访问。</p><blockquote><p>例如：某个段的DPL值为1，那么只有CPL&lt;&#x3D;1的程序才可以访问该段</p></blockquote><p>总而言之，CPL 代表当前正在执行的代码的特权级，而 DPL 代表段的特权级。通过这两个机制，操作系统可以有效地隔离不同权限级别的代码和数据，确保系统的安全性</p><div class="note-large cyan"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>三者的访问规则&amp;&amp;例子</p></div><div class="notel-content"><ul><li><p><strong>有效访问</strong>：当程序要访问一个段时，必须满足以下两个条件：</p><ol><li><p><strong>CPL &lt;&#x3D; DPL</strong>：即程序的当前特权级（CPL）不能高于段描述符的特权级（DPL），否则会导致特权级错误。</p></li><li><p><strong>RPL &lt;&#x3D; DPL</strong>：即请求特权级（RPL）也不能高于段的描述符要求的特权级（DPL），否则也会触发错误。</p></li></ol></li><li><p><strong>限制访问</strong>：如果 <strong>CPL &gt; DPL</strong> 或 <strong>RPL &gt; DPL</strong>，则访问该段会失败，触发特权错误（如 #GP 异常）。</p></li></ul><hr><p><strong>举个例子</strong></p><p>假设有一个段描述符，其 <strong>DPL</strong> 为 0（内核模式）。有两个程序，它们的 <strong>CPL</strong> 和 <strong>RPL</strong> 如下：</p><ol><li><p>程序 A 的 <strong>CPL</strong> 为 0（内核模式），<strong>RPL</strong> 为 3（用户模式），请求访问该段。</p></li><li><p>程序 B 的 <strong>CPL</strong> 为 3（用户模式），<strong>RPL</strong> 为 2（中间权限），请求访问该段。</p><p>在这种情况下：</p><ul><li>程序 A 可以访问该段，因为 <strong>CPL (0)</strong> &lt;&#x3D; <strong>DPL (0)</strong> 且 <strong>RPL (3)</strong> &lt;&#x3D; <strong>DPL (0)</strong>。</li><li>程序 B 无法访问该段，因为 <strong>CPL (3)</strong> &gt; <strong>DPL (0)</strong>，即它的当前特权级低于该段描述符所要求的特权级。</li></ul></li></ol></div></div><p>但是这样存在一个问题：某一特权级的代码段，低它一级的没法运行，高它一级的不让运行。<strong>因此受访者为代码段的时候，一般情况下，只能平级访问</strong></p><p>但这样会导致另一个问题，我们低特权级下的指令真的想要用高特权级的指令，怎么办呢？于是给出了<strong>一致性代码</strong>这一东西</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>一致性代码</p></div><div class="notel-content"><p>一致性代码段也称为依从代码段。用来实现从低特权级的代码向高特权级的代码转移。</p><p>一致性代码段是指如果自己是转移后的目标段，自己的特权级（DLR）一定要大于等于转移前的CPL,即<strong>数值上CPL&gt;&#x3D;DPL</strong> &#x2F; <strong>一致性代码段的DPL是权限的上限</strong>，任何在此权限之下的特权级都可以转到此代码段上执行</p><p>一致性代码段的一大特点是转移后的特权级不与自己的特权级（DPL）为主，而是与转移前的低特权级一致，听从、依从转移前的低特权级。也就是说，处理器遇到目标端为一致性代码段的时候，并不会将CPL用该目标段的DPL替换</p><p>因此这一代码的转移并没有提升特权级，只是在特权级更高的地方执行指令，并未产生因特权级升高而产生潜在危险</p></div></div><p>但我们总不能一直这样运行，因为有的代码他不会标识为一致性代码，所以我们就需要其它机制来使得我们向高特权级转化</p><h4 id="门、调用门、RPL序"><a href="#门、调用门、RPL序" class="headerlink" title="门、调用门、RPL序"></a>门、调用门、RPL序</h4><p>首先了解一下<strong>门结构</strong>：它是记录一段程序起始地址的描述符，用来描述一段程序，<strong>进入这个门结构之后，处理器就可以转移到更高的特权上</strong></p><table><thead><tr><th><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707151405434.png" alt="image-20250707151405434"></th></tr></thead><tbody><tr><td>任务门描述符</td></tr><tr><td><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707151420903.png" alt="image-20250707151420903"></td></tr><tr><td>中断门描述符</td></tr><tr><td><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707151439713.png" alt="image-20250707151439713"></td></tr><tr><td>陷阱门描述符</td></tr><tr><td><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707151511334.png" alt="image-20250707151511334"></td></tr><tr><td>调用门描述符</td></tr></tbody></table><p>除任务门之外，他们与段描述符最大的不同在于：这些门都是对应到一段例程之中，即对应一段函数，而不是像段描述符一样对应的是一片内存区域。由于任何程序都属于某个内存段，所以程序确切的地址必须用“代码段选择子+段内偏移量”来描述。可见门描述符基于段描述符，所以门描述符中记录的是选择子和偏移量的原因</p><p>任务门描述符可以放在GDT、LDT和IDT（中断描述表）中，调用门可以位于GDT、LDT中，中断门和陷阱门仅位于IDT中</p><p>此外，由于任务门、调用门都直接位于描述符表中，所以这两个门都可以直接用call、jmp指令直接使用；陷阱门和中断门位于IDT中，所以这两个门只能由中断信号触发</p><p>下面分别说下每个门的适用范围：</p><ul><li><strong>调用门</strong>：call和jmp指令后接调用门选择子为参数实现系统调用，call指令使用调用门可以实现向高特权级代码转移，jmp使用调用门只能实现平级代码转移</li><li><strong>中断门</strong>：以int指令主动发中断的形式实现从低特权级到高特权级转移</li><li><strong>陷阱门</strong>：以int3指令主动发中的的形式实现低特权级向高特权级转移，这一般是编译器在调式时用</li><li><strong>任务门</strong>：任务以状态段TSS为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时，如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用call或jmp指令后接任务门的选择子或任务TSS的选择子</li></ul><table><thead><tr><th><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707153822851.png" alt="image-20250707153822851"></th></tr></thead><tbody><tr><td>为什么可以使用门的结构进入高特权级，这个图太形象了</td></tr></tbody></table><p>门的特权级是一定要低于我们访问者的特权级的，这样才能保证我们能过调用门，而受访者的特权级一定得高于访问者者，不然没有意义了</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>调用门的内部执行结构：点击查看更多</summary><div class="content"><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250707154417052.png" alt="image-20250707154417052"></p><p>从调用门选择子到或许到内核代码的地址，共经历了5个步骤。</p><p><strong>用户程序调用调用门选择子</strong></p><p>在用户程序中有一句代码<code>call 调用门选择子</code>,call指令可以使用调用门，参数就是调用门的选择子，该选择子指向GDT或LDT中的某个门描述符。</p><p><strong>处理器查找门描述符地址</strong></p><p>处理器用门描述符选择子的高13位（索引位）乘以8作为该描述符在GDT中的偏移量，再加上寄存器GDTR中的GDT基地址，最终找到了门描述符的地址，它位于GDT中从0起的第3个描述符位置。</p><p><strong>获取内核例程地址</strong></p><p>在该描述符中记录的是内核例程的地址。我们知道，在保护模式下描述某个内存地址是离不开选择子和偏移量的，所以，门描述符中记录的是内核例程所在代码段的选择子及偏移量</p><p><strong>处理器查找内核代码段描述符地址</strong></p><p>处理器用代码段选择子的高13位索引值乘以8，加上GDT基址，得到内核代码段描述符地址</p><p><strong>最终获取内核例程起始地址</strong></p><p>用已经得到的内核代码段描述符地址，我们就可以最终得到内核例程的起始地址</p></div></details><h4 id="调用门的过程保护"><a href="#调用门的过程保护" class="headerlink" title="调用门的过程保护"></a>调用门的过程保护</h4><p>调用门涉及两个特权级，先是转移前的低特权级，这是程序调用“调用门”时的CPL；再就是转移后的目标特权级，这是由门描述符中选择子对应的目标代码段的DPL决定的。</p><p>接下来，假设用户进程要调用某个调用门，该门描述符中的参数个数是2，也就是说用户进程需要为该调用门提供2个参数才行。调用前的当前特权级为3，调用后的新特权级为0，所以调用门转移前用的是3特权级栈，调用后用的是0特权级栈</p><p>现在为此特权门提供2个参数，这是在使用调用门前完成的，目前是在3特权级，所以要在特权级栈中压入参数，分别是参数1和参数2</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250708214702630.png" alt="image-20250708214702630"></p><p>接下来确定新栈，这一步中我们根据门描述符中所寻找到的选择子来确定目的代码段的DPL值，这将作为我们日后的CPL值存在，同时我们会通过TSS来确定相对应的DPL站地址，也就是栈段选择子SS和栈指针ESP，这里记作SS_NEW、ESP_NEW</p><p>如果转移后的代码段特权提升，我们就需要换到新栈，此时旧段选择子我们记为SS_OLD、ESP_OLD,由于我们这俩值需要保存到新栈中，这是为了方便日后使用retf等指令进行返回旧栈，此时我们需要将SS_OLD、ESP_OLD放到某个地方进行保存，例如其他的一些寄存器，然后当我们将SS_NEW和ESP_NEW载入到SS和ESP寄存器后，咱们再将他俩压入新栈就行了</p><p>然后再将用户栈中保存的参数压入新栈</p><p>由于调用门描述符中记录的是某个段选择子和偏移，所以此时我们的cs寄存器需要用这个选择子重新加载，所以我们需要将旧的CS和EIP保存到栈上，然后重新加载两个寄存器</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250708215241870.png" alt="image-20250708215241870"></p><p>之后就是按照CS：EIP指示来运行内核例程从而实现特权级从3到0.</p><p><strong>但是总归是要回到原本的特权级，这里就是高特权级到低特权级了——retf指令：</strong></p><ol><li>首先进行检查，检查之前栈中保存的旧CS选择子，判断其中的RPL，来决定是否需要进行权限变换</li><li>然后弹出CS_OLD和EIP_OLD,目前为止ESP就会指向最后压的那个参数</li><li>此时我们需要跳过参数，所以得到将ESP_NEW的值加上一定偏移，使得他刚好指向ESP_OLD</li><li>若第一步中确定需要进行权限变换，此时再次pop两次，这样就恢复了之前的SS和ESP了</li></ol><blockquote><p>书中作者举了一个相当生动形象的例子：</p><p>不知道大伙儿学车了没有，报考驾校也要有个年龄限制，即使考 C本B本也要分年龄的。假如某个<br>小学生A（用户进程）特别喜欢开车，他就是想考个驾照，可驾校的门卫（调用门〉一看他年龄太小都不让他进门，连填写报名登记表的机会都没有，怎么办？于是他就求他的长辈B（内核〉帮他去报名，长辈的年龄肯定够了，门卫对他放行，他来到驾校招生办公室后，对招生人员说要帮别人报名。人家招生人员对B说，好吧，帮别人代报名需要出示对方的身份证（RPL)，于是长辈B就把小学生A的身份证（现在小孩子就可以申请身份证，只是年龄越小有效期越短，因为小孩子长得快嘛）拿出来了，招生人员一看，年纪这么小啊，不到法制学车年纪呢，拒绝接收。这时候驾校招生人员的安全意识开始泛滥了，以纵容小孩子危险驾驶为名把长辈B批评了一顿（引发异常）</p></blockquote><h2 id="0x08-实现打印函数"><a href="#0x08-实现打印函数" class="headerlink" title="0x08 实现打印函数"></a>0x08 实现打印函数</h2><p>这一段更多的是实操相关，没什么值得记录的知识点</p><h2 id="0x09-实现中断机制"><a href="#0x09-实现中断机制" class="headerlink" title="0x09 实现中断机制"></a>0x09 实现中断机制</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><strong>中断</strong>是计算机系统中的一种机制，用于打断正在执行的程序流程，以便处理更紧急或更高优先级的事件。和特权模式的切换息息相关</p><p>中断按照来源一般分为两种类型：<strong>外部中断</strong>和<strong>内部中断</strong></p><h4 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a><strong>外部中断</strong></h4><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250709111137093.png" alt="image-20250709111137093"></p><p>CPU为了接受外部设备的中断信号请求，设置了两条信号线INTR、NMI。</p><p>其中INTR收到的信号都是不影响系统运行的，可以随时处理，甚至可以不处理，因为它不影响CPU的运行；而只要从NMI引脚收到的中断，那必须要处理，因为这个是<strong>灾难性错误</strong></p><p><strong>可屏蔽中断</strong></p><p>这指的是可以通过软件设置来屏蔽或允许的外部中断请求。在中断控制器中，CPU可以选择暂时忽略被这类中断，直至它准备好接受。</p><p>在x86架构中，是否响应可屏蔽中断由<strong>eflags寄存器的IF位</strong>将所有这些外部设备的中断屏蔽</p><p><strong>不可屏蔽中断</strong></p><p>他是由NMI线传递的中断信号，只要这里传递了中断，计算机就说明遭到了严重的问题，必须立刻处理。此时上述eflags寄存器的IF位对他也毫无影响</p><h4 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h4><p>内部中断又可划分为<strong>软中断</strong>和<strong>异常</strong></p><p><strong>软中断</strong></p><p>也就是软件发起的中断，它是操作系统或应用程序通过指令或者系统调用发出的中断信号，通常用于请求操作系统执行某些特权操作，如文件操作、进程调度、内存管理等。</p><p><strong>异常</strong></p><p>异常是程序运行时出现的错误，他同样不受eflags寄存器中的标志位影响（不可屏蔽）。大致分为下面3种</p><ul><li>Fault：故障，可修复，如缺页异常</li><li>Trap：陷阱，自己想陷入中断，所以中断返回后执行下一条指令</li><li>Abort：终止，无法修复，操作系统为了自保，只能把该程序从进程表移除</li></ul><h4 id="中断描述表"><a href="#中断描述表" class="headerlink" title="中断描述表"></a>中断描述表</h4><p>是操作系统用于处理和管理中断的一种数据结构，它存储了中断服务例程地址，以及中断处理的相关信息。</p><p>其中不止有中断描述符，还有任务门描述符和陷阱门描述符，且这些描述符均指向了一段程序</p><ul><li>任务门：配合TSS使用实现特权级切换，可以存放在GDT、LDT、IDT中，描述符中任务门的tyoe字段二进制为0101</li><li>中断门：包含中断处理程序所在段的段选择子以及偏移，当通过此方式进入中断之后，eflags寄存器的IF位自动置0，也就是关中断，防止中断嵌套</li><li>陷阱门：类似于中断门，区别就是IF位不会置0，只允许放在IDT中.</li><li>调用门：提供用户进程进入特权0级，其DPL为3，只能用call和jmp指令调用，可以安装在GDT和LDT中。</li></ul><p>同理于GDT，我们需要一个寄存器来存放IDT的物理地址，这个寄存器就是IDTR</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit;  <span class="comment">// IDT 的大小（16 位）</span></span><br><span class="line">    <span class="type">uint32_t</span> base;   <span class="comment">// IDT 的基址（32 位）</span></span><br><span class="line">&#125; IDTR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64 位模式下表示 IDTR 的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> limit;  <span class="comment">// IDT 的大小（16 位）</span></span><br><span class="line">    <span class="type">uint32_t</span> base_low;   <span class="comment">// 基址的低 32 位</span></span><br><span class="line">    <span class="type">uint32_t</span> base_high;  <span class="comment">// 基址的高 32 位</span></span><br><span class="line">&#125; IDTR;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h4 id="中断处理过程及保护"><a href="#中断处理过程及保护" class="headerlink" title="中断处理过程及保护"></a>中断处理过程及保护</h4><p>中断过程分为CPU外和CPU内两个部分。</p><ul><li>CPU外：外部设备的1中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU</li><li>CPU内：CPU执行该中断向量号对应的中断处理程序</li></ul><p>先讨论处理器内部的内容</p><ol><li><p>处理器根据中断向量号定位中断门描述符</p></li><li><p>处理器进行特权级检查</p><p>由于中断是通过中断向量号通知到处理器的，中断向量号只是个整数，其中并不包含RPL，所以在对由中断引起的特权级转移做特权级检查中不会涉及RPL。中断门的特权级检查同调用门类似，对于软件主动发起的软中断，当前特权级CPL必须在门描述符和目标代码段DPL之间</p><ul><li>若是由软中断int n,int3, into引发的中断，这些是由用户自主发起的，所以处理器要检查当前特权级和门描述符DPL，这是检查进门的特权下限，乳山市检查通过，也就是CPL特权级是高于门DPL的，那么将进入下一步“门框”的检查，否则处理器将会报出异常</li><li>这一步检查特权级的上限“门框”，处理器要检查当前特权级CPL和门描述符中所记录选择子对应的目标代码段DPL，若CPL特权级小于目标代码段的DPL，则检查通过哦，否则处理器引发异常</li><li>若中断是由外部设备和异常引起的，则只检查CPL和目标代码段的DPL，若CPL小于目标代码段特权，则检查通过，否则处理器引发异常</li></ul></li><li><p>执行中断处理程序</p><p>特权级检查通过后，将门描述符目标代码段选择子加载到代码段寄存器cs中，把嗯描述符中的偏移地址加载到EIP中，然后执行中断处理程序</p></li></ol><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250710145101369.png" alt="image-20250710145101369"></p><p>中断发生后，eflags中的NT位和TF位会被置零，若中断对应的是中断门，则在进入中断门后eflags的IF会自动置0以此来防止中断嵌套。</p><p>处理器提供了一个修改IF位的指令：cli和sti。其中cli指令使得IF位为0，sti指令使得IF为1。分别称之为关中断和开中断</p><p>IF位只能限制外部设备中断，而对其它影响系统正常运行的中断都无效。</p><p>TF（Trap Flag），陷阱标志位，这用在调式环境中，当TF为0表示禁止单步执行</p><p>NT(Nest Task Flag),任务嵌套位，用来标记任务嵌套调用情况。</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>任务嵌套</p></div><div class="notel-content"><p>任务嵌套调用就是指CPU挂起当前的任务转而去执行另一个任务，待到该任务执行完再回去执行之前的任务。</p><p>CPU之所以可以如此运行是因为他会执行以下操作：</p><ol><li>将旧任务的TSS段选择子写到新任务TSS中的“上一个任务TSS的指针”字段中</li><li>将新任务eflags寄存器中NT置为1，表示新任务之所以能够执行是因为有别的任务调用了他</li></ol><p>而CPU从新任务返回到旧任务是通过iret指令，他又两个功能，一个是中断返回，一个是返回旧任务，所以这里就需要用到NT位，因为执行iret的时候会去检查NT位的值，若为1则说明当前任务是嵌套执行的，若为0则说明是在中断处理环境下，于是执行正常的中断退出流程</p></div></div><h4 id="中断压栈"><a href="#中断压栈" class="headerlink" title="中断压栈"></a>中断压栈</h4><p>当中断发生时，处理器收到一个中断向量，根据改中断向量号在IDT中的偏移，然后找到对应的门然后通过其中的选择子，然后将该选择子移入CS中，再将门描述符中的偏移字段移入EIP。这时由于CS和EIP会被刷新，所以处理器会将被中断的程序的CS和EIP保存到当前中断处理程序使用的栈当中。但由于中断在任何特权级下都有可能发生，所以中断处理程序使用的栈不确定，这就导致我们除了保存CS、EIP外还需要保存EFLAGS；如果涉及到特权级变化，还要压入SS和ESP寄存器。</p><p><strong>寄存器入栈情况及其顺序</strong></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250711164312477.png" alt="image-20250711164312477"></p><ol><li><p>当处理器通过中断向量找到对应的中断描述符后，比较CPL和中断门描述符中选择子对应目标代码段的DPL对比，若发现向高特权级转移，则需要切换到高特权级的栈，这也意味着当我们执行完中断处理程序后需要恢复旧栈才行。因此处理器先临时保存旧SS和ESP值，记作SS_old和ESP_old，然后在TSS中寻找到对应目标代码段同特权级的栈加载到寄存器SS和ESP中，记作SS_new和ESP_new，再将临时保存的SS_old和ESP_old压栈备份</p></li><li><p>在新栈中压入EFLAGS寄存器</p></li><li><p>因为要切换到目标代码段，对于这种段间转移，要将CS和EIP保存到当前栈中备份，记作CS_old和EIP_old，用于在中断结束后恢复被中断的进程</p></li><li><p>某些异常会爆出错误码，这个错误是用于报告异常是在哪个段上发生的，也就是发生异常的位置，所以错误码中包含选择子等信息，他一般紧跟EIP后入栈，记为ERROR_CODE</p></li></ol><p>处理器执行完中断处理程序后需要返回到被中断进程，也就是使用iret指令进行弹栈，这里需要保证上述顺序，如果说有中断错误码且处理器并不知道，这就需要我们手动将其跳过，也就是说当我们准备用iret指令返回时，当前栈指针必须得指向栈中备份的EIP_old所在的位置</p><h4 id="可编程中断控制器8259A"><a href="#可编程中断控制器8259A" class="headerlink" title="可编程中断控制器8259A"></a>可编程中断控制器8259A</h4><p>这个控制器比较古老了，现代中断控制器基本都是APIC类了,这里简单看一下工作流程就行</p><pre class="mermaid">flowchart TD
    %% 外设部分
    subgraph 外设
        A["外设发出中断信号并发送至8259A对应IRQ接口"]
    end

    %% 8259A内部处理
    subgraph 8259A处理
        B1{"检查IMR对应位"}
        B2["若屏蔽，丢弃"]
        B3["若未屏蔽，置IRR对应bit=1，等待处理"]
        B4["优先级解析选最高IRQ，发中断信号给CPU"]
        B5["CPU响应中断（INTA），ISR置位，IRR清零"]
        B6["CPU再次请求中断向量，8259A发送给CPU"]
    end

    %% CPU处理
    subgraph CPU处理
        C1["CPU进入中断处理程序"]
        C2{"EOI通知模式"}
        C3["手动模式：CPU发送EOI，ISR清零"]
        C4["自动模式：第二次INTA自动清零ISR"]
    end

    %% 流程连接
    A --> B1
    B1 -- 屏蔽 --> B2
    B1 -- 未屏蔽 --> B3 --> B4 --> B5 --> B6 --> C1 --> C2
    C2 -- 手动 --> C3
    C2 -- 自动 --> C4

    %% 样式定义
    classDef ext fill:#fef7d7,stroke:#f5d300,stroke-width:2px,color:#5a5a00;
    classDef pic fill:#d8f0ff,stroke:#0c87c4,stroke-width:2px,color:#034a6d;
    classDef cpu fill:#fde3e1,stroke:#d94a4a,stroke-width:2px,color:#660000;
    classDef decision fill:#fff0b8,stroke:#e1a800,stroke-width:2px,color:#6b4b00,font-weight:bold;

    %% 应用样式
    class A ext;
    class B1,B2,B3,B4,B5,B6 pic;
    class C1,C3,C4 cpu;
    class C2 decision;</pre><pre class="mermaid">flowchart TB

%% 外设输入
subgraph "外设中断输入"
    IRQ0[IRQ0]
    IRQ1[IRQ1]
    IRQ2[IRQ2]
    IRQ3[IRQ3]
    IRQ4[IRQ4]
    IRQ5[IRQ5]
    IRQ6[IRQ6]
    IRQ7[IRQ7]
end

IRQ0 --> IRR
IRQ1 --> IRR
IRQ2 --> IRR
IRQ3 --> IRR
IRQ4 --> IRR
IRQ5 --> IRR
IRQ6 --> IRR
IRQ7 --> IRR

%% 主结构
subgraph "8259A 主结构"
    IRR["🟡 IRR<br>中断请求寄存器"]
    Priority["🔼 优先级解析器"]
    GateCtrl["🟩 中断门控制逻辑"]
    ISR["🔴 ISR<br>中断服务寄存器"]
    IMR["⚪ IMR<br>中断屏蔽寄存器"]

    IRR --> Priority
    Priority --> GateCtrl
    GateCtrl --> ISR
    IMR --> GateCtrl
end

ISR --> INT["➡️ 发出中断信号<br>INT 向 CPU"]

%% CPU 接口
subgraph "CPU 接口"
    INT --> CPU["🧠 CPU 接收中断"]
    CPU --> EOI[发送 EOI]
    EOI --> ISR
end

%% 控制配置
subgraph "控制与配置"
    CMD[控制命令<br>ICW/OCW]
    CMD --> IRR
    CMD --> IMR
    CMD --> ISR
end

%% 使用 class 定义样式
classDef yellow fill:#fff3b0,stroke:#c9a600,stroke-width:2px;
classDef red fill:#ffd6d6,stroke:#d22b2b,stroke-width:2px;
classDef green fill:#ccffd8,stroke:#339933,stroke-width:2px;
classDef blue fill:#d0f0ff,stroke:#107dac,stroke-width:2px;
classDef gray fill:#f0f0f0,stroke:#999,stroke-width:2px;
classDef purple fill:#f0e5ff,stroke:#9457eb,stroke-width:2px;
classDef signal fill:#fef3c7,stroke:#facc15,stroke-width:2px;
classDef control fill:#fde2ff,stroke:#d946ef,stroke-width:2px;

%% 应用样式
class IRR yellow;
class ISR red;
class GateCtrl green;
class IMR blue;
class Priority gray;
class CPU purple;
class EOI blue;
class INT signal;
class CMD control;

%% 默认线
linkStyle default stroke:#444,stroke-width:1.5px;</pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="1-ELF文件格式"><a href="#1-ELF文件格式" class="headerlink" title="1. ELF文件格式"></a><strong>1. ELF文件格式</strong></h4><p>ELF（Executable and Linkable Format）是Unix&#x2F;Linux系统的标准可执行文件格式，包含程序加载和执行所需的所有信息。</p><p><strong>ELF文件结构：</strong></p><pre class="mermaid">graph TD
    A[ELF Header] --> B[Program Header Table]
    A --> C[Sections]
    A --> D[Section Header Table]
    B --> E[Segments]
    C --> F[.text<br>代码段]
    C --> G[.data<br>数据段]
    C --> H[.rodata<br>只读数据]</pre><p><strong>关键数据结构：</strong></p><ol><li><p><strong>ELF Header（<code>Elf32_Ehdr</code>）</strong>：</p><ul><li>魔数（<code>e_ident</code>）</li><li>入口地址（<code>e_entry</code>）</li><li>程序头表偏移（<code>e_phoff</code>）</li><li>节头表偏移（<code>e_shoff</code>）</li><li>使用命令：<code>readelf -h &lt;file&gt;</code></li></ul></li><li><p><strong>Program Header（<code>Elf32_Phdr</code>）</strong>：</p><ul><li>段类型（<code>p_type</code>）</li><li>文件偏移（<code>p_offset</code>）</li><li>虚拟地址（<code>p_vaddr</code>）</li><li>文件大小（<code>p_filesz</code>）</li><li>内存大小（<code>p_memsz</code>）</li><li>使用命令：<code>readelf -l &lt;file&gt;</code></li></ul></li></ol><hr><h4 id="2-特权级机制"><a href="#2-特权级机制" class="headerlink" title="2. 特权级机制"></a><strong>2. 特权级机制</strong></h4><p>x86架构通过特权级（0-3级）实现硬件级安全隔离：</p><pre class="mermaid">graph LR
    A[Ring 0] -->|OS内核| B[最高权限]
    C[Ring 1-2] -->|驱动/虚拟机| D[系统服务]
    E[Ring 3] -->|应用程序| F[最低权限]</pre><p><strong>关键机制：</strong></p><ol><li><p><strong>TSS（任务状态段）</strong>：</p><ul><li>存储任务上下文（寄存器&#x2F;栈指针）</li><li>特权级切换时自动更新<code>esp0/ss0</code></li></ul><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TSS</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> esp0;   <span class="comment">// Ring 0栈指针</span></span><br><span class="line">    <span class="type">uint32_t</span> ss0;    <span class="comment">// Ring 0栈段</span></span><br><span class="line">    <span class="type">uint32_t</span> cr3;    <span class="comment">// 页目录基址</span></span><br><span class="line">    <span class="comment">//... 其他寄存器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li><li><p><strong>特权级检查规则</strong>：</p><ul><li><strong>数据访问</strong>：CPL ≤ DPL 且 RPL ≤ DPL</li><li><strong>代码跳转</strong>：<ul><li>非一致代码：CPL &#x3D;&#x3D; DPL</li><li>一致代码：CPL ≥ DPL（特权级不变）</li></ul></li></ul></li><li><p><strong>门描述符</strong>：</p><table><thead><tr><th>类型</th><th>安装位置</th><th>触发方式</th></tr></thead><tbody><tr><td>调用门</td><td>GDT&#x2F;LDT</td><td>CALL&#x2F;JMP</td></tr><tr><td>中断门</td><td>IDT</td><td>INT指令&#x2F;硬件中断</td></tr><tr><td>陷阱门</td><td>IDT</td><td>INT3调试</td></tr><tr><td>任务门</td><td>GDT&#x2F;LDT&#x2F;IDT</td><td>CALL&#x2F;JMP&#x2F;中断</td></tr></tbody></table></li></ol><hr><h4 id="3-中断机制"><a href="#3-中断机制" class="headerlink" title="3. 中断机制"></a><strong>3. 中断机制</strong></h4><p>中断是CPU响应外部事件的核心机制，分为：</p><ul><li><strong>外部中断</strong>：INTR（可屏蔽）、NMI（不可屏蔽）</li><li><strong>内部中断</strong>：异常（Fault&#x2F;Trap&#x2F;Abort）、软中断（INT n）</li></ul><p><strong>中断处理流程：</strong></p><pre class="mermaid">sequenceDiagram
    participant CPU
    participant IDT
    participant Stack
    participant Handler
    
    Note over CPU: 中断发生
    CPU->>IDT: 根据向量号查找门描述符
    CPU->>Stack: 压入EFLAGS/CS/EIP/错误码
    alt 特权级变化
        CPU->>TSS: 加载新SS/ESP
        CPU->>Stack: 压入旧SS/ESP
    end
    CPU->>Handler: 跳转执行中断程序
    Handler-->>CPU: IRET返回</pre><p><strong>关键组件：</strong></p><ol><li><p><strong>IDT（中断描述表）</strong>：</p><ul><li>通过<code>LIDT</code>指令加载</li><li>包含256个门描述符</li></ul></li><li><p><strong>8259A中断控制器</strong>：</p><pre class="mermaid">   flowchart LR
    IRQ[IRQ0-7] --> IRR[中断请求寄存器]
    IRR -->|优先级| PR[优先级解析器]
    PR -->|INT| CPU
    CPU -->|INTA| ISR[中断服务寄存器]
    CPU -->|EOI| ISR</pre></li><li><p><strong>中断上下文保存</strong>：</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">High Address</span><br><span class="line">| ...          |</span><br><span class="line">| 旧SS         | ← 特权级变化时</span><br><span class="line">| 旧ESP        |</span><br><span class="line">| EFLAGS       |</span><br><span class="line">| 旧CS         |</span><br><span class="line">| 旧EIP        |</span><br><span class="line">| 错误码       | ← 部分异常</span><br><span class="line">Low Address</span><br></pre></td></tr></table></figure></div></li></ol><hr><h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><ol><li><strong>系统启动流程</strong>：BIOS → Bootloader → 加载ELF内核 → 跳转到<code>e_entry</code></li><li><strong>特权级隔离</strong>：通过CPL&#x2F;DPL&#x2F;RPL实现硬件级安全控制</li><li><strong>中断核心作用</strong>：<ul><li>处理硬件事件</li><li>实现系统调用（如INT 0x80）</li><li>处理程序异常</li></ul></li><li><strong>现代演进</strong>：<ul><li>8259A → APIC（多核支持）</li><li>硬件虚拟化扩展（VT-x）优化特权切换</li></ul></li></ol><blockquote><p>完整实现需结合：页表管理（CR3）、任务调度（TSS）、系统调用门（调用门&#x2F;中断门）</p></blockquote></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 操作系统学习笔记03-从初始内核到中断</li><li><strong>作者:</strong> Maple</li><li><strong>创建于 :</strong> 2025-07-14 16:32:12</li><li><strong>更新于 :</strong> 2025-07-14 16:45:18</li><li><strong>链接:</strong> https://github.com/maple-pwn/maple-pwn.github.io/2025/07/14/操作系统学习笔记03-从初始内核到中断/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/OS/">#OS</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2025/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E8%B5%B0%E5%90%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">操作系统学习笔记02-从实模式走向虚拟内存</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">操作系统学习笔记03-从初始内核到中断</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-%E8%BD%BD%E5%85%A5%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8"><span class="nav-text">0x06 载入初始内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x06-00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">0x06 00 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x06-01-%E5%AE%9E%E7%8E%B0%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8"><span class="nav-text">0x06 01 实现初始内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="nav-text">0x07 特权级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x08-%E5%AE%9E%E7%8E%B0%E6%89%93%E5%8D%B0%E5%87%BD%E6%95%B0"><span class="nav-text">0x08 实现打印函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x09-%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-text">0x09 实现中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">基础知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="nav-text">关键结论</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2025</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Maple</a><p class="post-count space-x-0.5"><span>共撰写了 8 篇文章</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/localSearch.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/libs/mermaid.min.js"></script><script src="/js/build/plugins/mermaid.js"></script><script src="/js/build/libs/anime.min.js"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/bookmarkNav.js" type="module"></script></body></html>