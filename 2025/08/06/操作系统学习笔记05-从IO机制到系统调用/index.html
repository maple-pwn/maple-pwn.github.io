<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Maple"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://maple-pwn.github.io/2025/08/06/操作系统学习笔记05-从io机制到系统调用/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="操作系统学习笔记05-从IO机制到系统调用"><meta property="og:url" content="http://maple-pwn.github.io/2025/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-%E4%BB%8EIO%E6%9C%BA%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/index.html"><meta property="og:site_name" content="Maple"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2025-08-06T10:49:06.000Z"><meta property="article:modified_time" content="2025-08-06T14:01:20.244Z"><meta property="article:author" content="Maple"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/1.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/1.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/1.svg"><title>操作系统学习笔记05-从IO机制到系统调用 | Maple</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"maple-pwn.github.io",root:"/",language:"zh-CN",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Maple's blog",subtitle:{text:["lucky day"],hitokoto:{enable:!1,show_author:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/maple-pwn",email:"3079403765@qq.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!0,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Github:{path:"https://github.com/maple-pwn",icon:"fa-brands fa-github"},Bookmarks:{icon:"fa-solid fa-bookmark",path:"/bookmarks/"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur",bookmark_colum:3},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Tags:{path:"/tags",icon:"fa-solid fa-tags"},Categories:{path:"/categories",icon:"fa-solid fa-list"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2025/4/5 00:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><link rel="stylesheet" href="/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Maple</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a target="_blank" rel="noopener" href="https://github.com/maple-pwn"><i class="fa-brands fa-github fa-fw"></i> GITHUB</a></li><li class="navbar-item"><a href="/bookmarks/"><i class="fa-solid fa-bookmark fa-fw"></i> BOOKMARKS</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-solid fa-box-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" target="_blank" rel="noopener" href="https://github.com/maple-pwn"><span>GITHUB </span><i class="fa-brands fa-github fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bookmarks/"><span>BOOKMARKS </span><i class="fa-solid fa-bookmark fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-solid fa-list fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">操作系统学习笔记05-从IO机制到系统调用</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/1.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Maple</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-08-06 18:49:06</span> <span class="mobile">2025-08-06 18:49:06</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-08-06 22:01:20</span> <span class="mobile">2025-08-06 22:01:20</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/OS/">OS</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/OS/">OS</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="0x0d-实现包含锁的IO机制"><a href="#0x0d-实现包含锁的IO机制" class="headerlink" title="0x0d 实现包含锁的IO机制"></a>0x0d 实现包含锁的IO机制</h2><p>首先回顾一下上一节的结果，会发现出现了很多奇怪的空格，并且上面出现报错<code>#GP General Protection Exception</code>（一般保护性异常）</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250730220927556.png" alt="image-20250730220927556"></p><p>这里的根本原因是由于临界区代码的资源竞争，这需要一些互斥的方法来保证操作的原子性（也就是互不影响）</p><h3 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h3><h4 id="介绍一些术语"><a href="#介绍一些术语" class="headerlink" title="介绍一些术语"></a>介绍一些术语</h4><ul><li><code>公共资源</code>：可以是公共内存、公共文件、公共硬件等，总之是被所有任务共享的一套资源</li><li><code>临界区</code>：程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。<strong>使用公共资源的代码程序</strong></li><li><code>互斥</code>：指某一个时刻公共资源只能被1个任务独享，也就是只能由一个任务在自己的临界区执行</li><li><code>竞争条件</code>：多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问以竞争的方式并行进行</li></ul><blockquote><p>如果将上面的东西和我们之前的内容进行一个对应的话：</p><p>公共资源就是显卡的光标寄存器；</p><p>同时因为每个线程都会使用put_char函数，这个函数是操作光标寄存器的，所以这段代码就是每个线程的临界区</p></blockquote><p>所以我们可以通过暴力的关、开中断来实现互斥，但是每次执行的时候都要关、开中断有些不太优雅，也太麻烦。</p><p>此外，如果我们关中断的操作距离临界区太远，就会造成多任务调度的低效，这就违背了当时设计多线程的初衷。</p><p>于是便有了“<strong>锁</strong>”这个概念</p><hr><p>锁是由<strong>信号量</strong>实现的，所以先解释一下<strong>信号量</strong></p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>在计算机当中，信号量就是个0以上的整数值，当为0时表示已无可用信号，是一种<strong>同步机制</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>同步 点击查看详细</summary><div class="content"><p>同步一般是指合作单位之间为协作完成某项工作而共同遵守的工作步调，强调的是配合时序，就像十字路口的红绿灯，只有在绿灯亮起的情况下司机才能前进，这就是一种同步。</p><p>简单来说，同步是指不能随时随意工作，工作必须在某种条件具备的情况下才能开始，工作条件具备的时间顺序就是时序。</p><p>线程同步的目的是不管线程如何混杂、穿插地执行，都不会影响结果地正确性。线程不像人那样有判断“配合时序”的意识，它的执行会很随意，这就使得合作出错成为必然。因此，当多个线程访问同一公共资源时，为了保证结果正确，必然要使用一套额外的机制来控制它们的工作步调</p></div></details><p>信号量是计数值，P、V操作表示信号量的减、增。</p><p>信号量的处置代表是信号资源的累积量，也就是剩余量，而P操作就是减少信号量来获取资源，V操作就是释放资源增加信号量，见下面微操作：</p><p><strong>V操作</strong>：</p><ul><li>将信号量的值加1</li><li>唤醒在此信号量上等待的操作</li></ul><p><strong>P操作</strong>：</p><ul><li>判断信号量是否大于$0$</li><li>若信号量大于$0$，则信号量减$1$</li><li>若信号量等于$0$，当前线程将自己阻塞，以在此信号量上等待</li></ul><hr><p>信号量的初值若为1的话，它的取值就只能为 0 和 1 ，这便称为二元信号量，我们可以利用二元信号量来实现<strong>锁</strong></p><p>那么 P 操作就是获得锁， V 操作就是释放锁。我们可以让线程通过锁进入临界区，可以借此保证只有一个线程可以进入临界区，从而做到互斥。大致流程如下：</p><ol><li>线程A进入临界区前先通过 P 操作获得锁，此时信号量的值便为 0</li><li>后续线程 B 再进入临界区时也通过 P 操作获得锁，由于信号量是 0 ，线程 B 便在此信号量上等待，也就是相当于线程 B 进入了睡眠态</li><li>当线程 A 从临界区出来后执行 V 操作释放锁，此时信号量的值重新变为 1 ，之后线程 A 将线程 B 唤醒</li><li>线程 B 醒来后获得了锁，进入临界区</li></ol><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>阻塞和唤醒 点击查看详细</summary><div class="content"><p><strong>阻塞</strong></p><p>调度器并不决定线程是否可以运行，只是决定了运行的时机，线程可否运行是由线程自己把控的。当线程被换上处理器运行后，在其时间片内，线程将主宰自己的命运。</p><p>阻塞是一种意愿，表达的是线程运行中发生了一些事情，这些事情通常是由于缺乏了某种运行条件造成的，以至于线程不得不暂时停下来，必须等到运行的条件再次具备时才能上处理器继续运行</p><p>因此，<strong>阻塞发生的时间是在线程自己的运行过程中，是线程自己阻塞自己，并不是被谁阻塞</strong></p><p><strong>唤醒</strong></p><p>已被阻塞的线程是无法运行的，需要锁的持有者将其唤醒。锁的持有者释放了锁之后便去唤醒在它后面因获取该锁而阻塞的线程。因此唤醒已阻塞的线程是由别的线程（通常是锁的持有者）来做的</p></div></details><h3 id="0x02-用锁实现终端输出"><a href="#0x02-用锁实现终端输出" class="headerlink" title="0x02 用锁实现终端输出"></a>0x02 用锁实现终端输出</h3><blockquote><p>终端也称为控制台，这是计算机历史中遗留下来的概念。过去计算机还是奢侈品的时候，为了充分利用计算机资源，允许多个用户连接到机器上（类似于 Windows 多用户的概念，为的是让更多的用户能够控制计算机，因此终端便称为控制台）</p><p>而为了能够在同一个显示器下实现多用户，也就是分别为每个用户虚拟出一个“显示器”，因此出现了虚拟终端</p><p>每个控制台都是一个虚拟终端，用户看到的屏幕是由软件虚拟出来的</p></blockquote><p>但虚拟终端的实现还是要依赖硬件本身的功能：</p><p>我们知道屏幕在不同模式下显示的字符数是有限的，因此屏幕不能一次性把显存中的全部数据显示出来，为此，显卡提供了两个寄存器“Start Address High Register” 和 ”Start Address Low Register” 来设置数据在显存中的起始地址。起始地址是用16位来表示的，它们分别设置显存地址的 15<del>8 位和 7</del>0 位。因此，我们可以把不同的 16 位地址分别写入这两个寄存器，从而实现将显存分块显示的目的，也就是实现了虚拟终端。由此可见，虽然多个虚拟终端共同用一个显示器，也就是共享同一片显存，但用户之间能够互不干扰，就是因为每个虚拟终端显示的是显存中的不同区域，如下图所示</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250801232943098.png" alt="image-20250801232943098"></p><p>在我们的系统中没有复杂的显卡寄存器操作，我们只有一个终端，因此所有的输出都往这一个屏幕上挤，这就容易让输出凌乱不堪。为了让这一个屏幕上的内容井然有序，既然我们已经实现了锁，我们可以通过锁实现输出互斥，这样屏幕上的字符就会井然有序</p><p>虽然我们没有真正的多控制台，但是我们把终端当成设备来对待，终端就是我们的标准输出设备，因此我们本节要构造一个终端设备，通过它实现以后的打印输出</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>实现代码 点击查看详细</summary><div class="content"><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//console.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;console.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;print.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sync.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">console_lock</span>;</span>    <span class="comment">//控制台锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_init</span><span class="params">()</span>&#123;</span><br><span class="line">  lock_init(console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_acquire</span><span class="params">()</span>&#123;</span><br><span class="line">  lock_acquire(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放终端 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_release</span><span class="params">()</span>&#123;</span><br><span class="line">  lock_release(&amp;console_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端输出字符串 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_str</span><span class="params">(<span class="type">char</span>* str)</span>&#123;</span><br><span class="line">  console_acquire();</span><br><span class="line">  put_str(str);</span><br><span class="line">  console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端输出字符 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_char</span><span class="params">(<span class="type">uint8_t</span> char_asci)</span>&#123;</span><br><span class="line">  console_acquire();</span><br><span class="line">  put_char(char_asci);</span><br><span class="line">  console_release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 终端输出十六进制整数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">console_put_int</span><span class="params">(<span class="type">uint32_t</span> num)</span>&#123;</span><br><span class="line">  console_acquire();</span><br><span class="line">  put_int(num);</span><br><span class="line">  console_release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其实就是封装了锁处理，此后用main输出的时候用console_put_str等函数即可，内部实现互斥机制</p></div></details><h3 id="0x03-从键盘获取输入"><a href="#0x03-从键盘获取输入" class="headerlink" title="0x03 从键盘获取输入"></a>0x03 从键盘获取输入</h3><p>接下来是输入任务，即从键盘获取键入的字符。这里实现的是PS&#x2F;2键盘</p><hr><h5 id="键盘输入的原理"><a href="#键盘输入的原理" class="headerlink" title="键盘输入的原理"></a><strong>键盘输入的原理</strong></h5><blockquote><p>计算机是一个系统，系统是指由各个功能独立的模块组成的整体，相当于正在内部按功能分层，一个模块就像个功能独立的黑盒子，上下游模块之间可依赖，相互提供数据。在所有模块的配合下，使这个系统作为整体对外提供服务（也就是计算机领域的<strong>抽象</strong>）</p><p>键盘同理，也是由一个个独立的模块分层实现的，但是并不是简单地由键盘把数据塞到主机里，这涉及两个功能独立的芯片配合</p></blockquote><p>键盘内部有个叫做<strong>键盘编码器</strong>的芯片，通常是$Intel 8048$或者兼容芯片，它的作用是：<strong>当键盘上发生案件操作时，它就像键盘控制器报告哪个键被按下，按键是否弹起</strong></p><p>而<strong>键盘控制器</strong>一般在主机内部的主板上，通常是$Intel8042$或者兼容芯片，它的作用是：接受来自键盘编码器的按键信息，将其解码后保存，然后向中断代理发中断，之后处理器执行相应的中断处理程序读入8042处理保存过的按键信息</p><p>他们的关系如下图所示</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802125445960.png" alt="image-20250802125445960"></p><p>当我们键盘按键的时候，8048会维护一个<strong>键值对的表</strong>，我们所按的键对应的<strong>扫描码</strong>会传给8042芯片，然后8042向8259A发送中断信号，这样处理器就会去执行键盘中断处理程序（中断处理程序需要我们自己实现）</p><p>这里的<strong>扫描码</strong>又分为两类，一个叫做<strong>通码</strong>，指的是按下按键产生的扫描码；另一个是<strong>断码</strong>，指的是松开按键产生的扫描码</p><blockquote><p>[!note]</p><p>注意我们只能得到键的扫描码，并不会得到键的ASCII码，扫描码是硬件提供的编码集，ASCII是软件中约定的编码集，这两个是不同的编码方案。</p><p>假如我们在键盘上按下了空格键，我们在键盘中断处理程序中只能得到空格键的扫描码，该扫描码是 0x39 而不是空格键的 ASCII 码 0x20</p><p>键盘的中断处理程序便充当了字符处理程序，将对应字符的扫描码转换为ASCII码输出</p></blockquote><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第一套键盘扫描码 点击查看详细</summary><div class="content"><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802133123244.png" alt="image-20250802133123244"></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802133136623.png" alt="image-20250802133136623"></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802133147534.png" alt="image-20250802133147534"></p></div></details><p>可以注意到扫描码中的通码和断码都是1字节大小，且断码&#x3D;通码+0x80，这是因为一般扫描码的最高1位用来标识通码还是断码，若是0则表示通码，为1则表示断码</p><p>为了让我们可以获取击键的过程，我们将每一次击键过程分为“按下”，“按下保持”，“弹起”三个阶段，其中每次8048向8042发送扫描码的时候，8042都会向8059A发起中断并且将扫描码保存在自己的缓冲区中，此时再调用我们准备好的键盘中断处理程序，从8042缓冲区获得传递来的扫描码。</p><h3 id="0x04-环形输入缓冲区"><a href="#0x04-环形输入缓冲区" class="headerlink" title="0x04 环形输入缓冲区"></a>0x04 环形输入缓冲区</h3><p>到目前为止，虽然顺利接受了键盘按键，但其实除了输出这些字符并没有出现什么特别的功能，而我们实现键盘输入很大的一部分就是可以实现shell功能，这样就可以键入指令然后实现需求了。<br>缓冲区是多个线程共用的共享内存，线程并行访问的时候它难免会出问题，所以我们需要解决这个对于缓冲区的访问操作产生的问题。这里我稍微介绍一下我们即将要设计的环形缓冲区：</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802134156698.png" alt="image-20250802134156698"></p><p>这里我们定义两个指针来指向其中的头和尾，但注意我们这里的环形是指逻辑上的环形，在物理内存上我们仍然是线性的，不过我们用以下方式来使得其从逻辑上来看是环形队列，那就是头指针用来写数据，尾指针用来读数据，这里当我们指针位置加1导致越过了缓冲区范围的时候会进行取余来重新指向缓冲区的开头，这样就形成了环形的错觉。</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>生产者消费者模型</p></div><div class="notel-content"><p>我们知道，在计算机中可以并行多个线程，当它们之间相互合作时，必然会存在共享资源的问题，这是通过“线程同步”来实现的</p><p>诠释“线程同步”最典型的例子就是“生产者与消费者问题”</p><ul><li><p>“同步”是指多个线程相互协作，共同完成一个任务，属于线程间工作步调相互制约。</p></li><li><p>”互斥“是指多个线程”分时“访问共享资源</p></li></ul><p>生产者与消费者问题是描述多个线程协同工作的模型，如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802134704682.png" alt="image-20250802134704682"></p><p>有一个或多个生产者、一个或多个消费者和一个固定大小的缓冲区，所欲生产者和消费者共享这同一个缓冲区。生产者生产某种类型的数据，每次放到一个缓冲区中，消费者消费这种数据，每次从缓冲区中消费一个。同一时刻，缓冲区只能被一个生产者或消费者使用。当缓冲区已满时，生产者不能继续往缓冲区中添加数据，当缓冲区为空时，消费者不能在缓冲区中消费数据</p><p><em>作者给了个很有意思的例子</em></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802135322210.png" alt="image-20250802135322210"></p><p>总结一下：生产者与消费者问题描述的是：</p><p>对于有限大小的公共缓冲区，如何同步生产者和消费者的运行，以达到对共享缓冲区的互斥访问，并保证生产者不会过度生产，消费者不会过度消费，缓冲区不会破环</p><p>对于这种缓冲区的破坏，要么是对缓冲区访问溢出，要么是缓冲区中的数据被破坏</p></div></div><h2 id="0x0e-用户进程"><a href="#0x0e-用户进程" class="headerlink" title="0x0e 用户进程"></a>0x0e 用户进程</h2><blockquote><p>自始至终，我们的程序都在 ring 0 级工作，这意味着任何程序都和操作系统平起平坐，可以改动任何系统资源，这是极度危险的。所以需要一个权限更低的进程</p></blockquote><h3 id="LDT-TSS"><a href="#LDT-TSS" class="headerlink" title="LDT &amp; TSS"></a>LDT &amp; TSS</h3><hr><p>LDT（本地描述符表）和 TSS（任务状态段）起源于 1980 年代 Intel 为 80286 和 80386 处理器引入保护模式时提出的设计，旨在通过硬件机制支持多任务管理和内存隔离，是早期基于分段的多任务操作系统（如 OS&#x2F;2 和 Windows 3.x）运行的关键基础,以下就是对LDT和TSS的介绍</p><h5 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h5><p>程序是一堆数据和指令的集合，它们只有被加载到内存并让 CPU 的寄存器中指向它们后， CPU 才能执行该程序。程序从文件系统上被加载到内存后，位于内存中的程序便称为映像，也称为<strong>任务</strong></p><p>在 IA32 架构的 CPU 上，内存被设计为需要按照分段的方式来访问，所以要想在这种CPU上开发程序就也需要遵守内存分段的规定。</p><p>而为了便于管理和好看，我们一般会将数据分类存储：数据集中放在一起，指令集中放在一起等等。</p><p>而 CPU 只把 CS：[E]IP 指向的内存当成指令，把 DS 指向的内存当作普通数据，因此必须人为保证填充到这些段寄存器中的值是正确的。<em>咱们只要往对应的寄存器中写入合适的值就成了，其他的咱们不用管，由处理器内部的处理框架自动完成。这就像咱们在软件开发过程中用到的框架一样，只不过这次的框架是由硬件CPU 提供的。</em></p><p>按照内存分段的方式，内存中的程序映像自然被分成了代码段、数据段等资源，这些资源属于程序私有的部分，因此 Intel 建议<strong>为每个程序单独赋予一个结构来存储其私有的资源</strong>，也就是<strong>LDT</strong></p><hr><p>LDT（Local Descriptor Table），即局部描述符表。描述符的功能就是描述一段内存区域的作用及属性，它只是对应内存区域的身份证</p><p>LDT属于任务私有的结构，它是每个人物都有的，其位置也不固定。而为了找到它，就需要通过在GDT中注册，通过选择子找到它</p><p><em>计算机就是一层套一层，再套一层说是</em></p><p>下图为LDT描述符格式</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802182055074.png" alt="image-20250802182055074"></p><p>在 LDT 中，描述符的 D 位和 L 位固定为 0</p><p>LDT描述符属于系统段描述符，因此 S 为0。在 S 为 0 的前提下，若 TYPE 的值为 0010，这表示此描述符是 LDT 描述符。</p><p><strong>现在可以找到 LDT 了，如何使用它呢</strong></p><p>CPU 使用某个表，肯定不只是找到一个描述符就行了，描述符的目的是为了告诉 CPU 描述符所对应区域的起始地址及偏移大小。CPU 为 LDT 准备了寄存器 LDTR 来存储其位置及偏移量</p><p>LDTR 结构如下图所示：</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802204241308.png" alt="image-20250802204241308"></p><ul><li>选择器是中 16 位的 LDT 选择子</li><li>描述符缓冲器是LDT的起始地址及偏移大小等属性</li></ul><p><strong>LDT 中的描述符全部用于指向任务自己的内存段，该如何引用它们呢？</strong></p><p>选择子是 16 位的，其高 13 位是索引值，用来在 GDT 或 LDT 中索引段描述符，用来在 GDT 或 LDT 中索引段描述符，第 0~1 位 RPL，表示请求特权级，第 2 位是 TI 位，此位用来指定选择子中的高 13 位是在 GDT中索引段描述符，还是在 LDT 中索引段描述符。</p><blockquote><p>TI 位也就是 Table Indicator，当此位为 1 时，表示从 LDT 中检索，反之当此位为 0 时，表示从 GDT中检索选择子</p></blockquote><p>当前运行的任务，其 LDT 位于 LDTR 指向的地址，这样 CPU 才能从中拿到任务运行所需要的资源（指令和数据）。因此，每切换一个任务时，需要用 lldt 指令重新加载任务的 LDT 到 LDTR</p><hr><h4 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h4><p>TSS 是为了使得 CPU 支持多任务来实现的，这里有点像线程中的 PCB，不过TSS基于进程，而PCB是线程自己也有拥有一个，所以这里切换进程也就是需要使用 TSS 来标记上下文，而 CPU 也用不同的 TSS 来区分不同的任务</p><p>TSS 和其它段一样，本质上是一片存储数据的内存区域，Intel 打算用这片内存区域保存任务的最新状态（也就是任务运行时占用的寄存器组等），因此它也和其它段一样，需要某个描述符结构来“描述”它，这就是 TSS 描述符，TSS描述符也要在 GDT 中注册，结构如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802213024100.png" alt="image-20250802213024100"></p><p><strong>TSS 描述符</strong>属于系统段描述符，因此S 为0，在S 为0 的情况下，TYPE 的值为10B1。我们这里关注一下B 位，B 表示busy 位，B 位为0 时，表示任务不繁忙，B 位为1 时，表示任务繁忙。</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>任务繁忙</p></div><div class="notel-content"><p>任务繁忙有两方面的含义：</p><ul><li>一方面就是指此任务是否为当前正在CPU 上运行的任务。</li><li>另一方面是指此任务嵌套调用了新的任务，CPU 正在执行新任务，此任务暂时挂起，等新任务执行完成后CPU 会回到此任务继续执行，所以此任务马上就会被调度执行了。<ul><li>这种有嵌套调用关系的任务数不只两个，可以很多，比如任务A 调用了任务A.1，任务A.1 又调用了任务A.1.1 等，为维护这种嵌套调用的关联，CPU 把新任务TSS 中的 B 位置为1，并且在新任务的TSS 中保存了上一级旧任务的TSS 指针（还要把新任务标志寄存器eflags 中NT 位的值置为1），新老任务的调用关系形成了调用关系链</li></ul></li></ul></div></div><p>B位的作用是任务不会自己调用自己，因为若正在执行的任务所调用的函数段的B位为 1，则说明它在调用自己，或者调用自己的调用者们。</p><hr><p>TSS 描述符是用来描述 TSS 的，接下来介绍一下 TSS。</p><p>TSS 同其他普通段一样，是位于内存中的区域，因此可以把TSS 理解为TSS 段，只不过TSS 中的数据并不像其他普通段那样散乱，TSS 中的数据是按照固定格式来存储的，如下图</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802213819512.png" alt="image-20250802213819512"></p><p>这里可以看出TSS本身自己就完全上下文的信息，其中包含了许多寄存器的备份，并且这里也包含了该任务所需要的栈地址</p><p>关于这三个栈，可以看<a href="https://maple-pwn.github.io/2025/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8%E5%88%B0%E4%B8%AD%E6%96%AD/#0x07-%E7%89%B9%E6%9D%83%E7%BA%A7">之前的文章</a>中对TSS的介绍。</p><p>此外，除了从中断和调用门返回之外，CPU不允许从高特权级转向为低特权级。所以这三组栈仅仅是CPU用来从低特权级跳到高特权级使用的，注意这三组栈地址在TSS中是不会改变的，也就是说不论你在哪个特权级进行了怎么样的压栈，当你从别的特权级返回到这个特权级的时候，他还是会从TSS中获取原始栈基址，而不管你曾经是否压过许多值。</p><hr><p>CPU本身是支持TSS的，这说明访问TSS以及识别他的结构过程并不是咱们需要做的工作。当任务被换下CPU的时候，CPU会自动将一些寄存器的值存入TSS相应位置，当任务上CPU运行的时候同样如此。<br>而我们本身是需要访问TSS的，所以说这里存在一个专门帮助我们寻找到TSS地址的寄存器TR，注意这里是帮助咱们寻找到TSS，而不是像GDTR那样专门有一部分位用来存放GDT首地址，前面咱们说过TSS是存在描述符的且存放在GDT中，所以我们访问他是跟访问其他普通段描述符一样，都是使用选择子，通过这个选择子我们就能够找到在GDT中的TSS段描述符，然后通过该描述符来找到咱们的TSS结构，下面给出TR结构和描述符缓冲器：</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802214352964.png" alt="image-20250802214352964"></p><hr><p>TSS 和 LDT 一样，必须要在 GDT 中注册才行，<em>这也是为了在引用描述符的阶段做安全检查</em></p><p>因此 TSS 是通过选择子来访问的，将 TSS 加载到寄存器 TR 的指令为 <code>ltr</code>,其指令格式为</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ltr &quot;16位通用寄存器&quot; 或 &quot;16位内存单元&quot;</span><br></pre></td></tr></table></figure></div><p>第一个任务的 TSS 手工加载之后，CPU会自动地把当前任务地资源状态保存到该任务对应的 TSS 中（由寄存器TR指定）</p><hr><p><strong>总之，</strong></p><p><strong>TSS 由用户提供，由 CPU 自动维护</strong></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250802215537859.png" alt="image-20250802215537859"></p><p>寄存器 TR 始终指向当前任务的 TSS，<strong>任务切换就是改变 TR的指向</strong>，CPU 自动将当前寄存器组的值（快照）写入 TR 指向的 TSS，同时将新任务 TSS 中的各寄存器的值载入 CPU 中对应的寄存器，从而实现了任务切换</p><hr><h2 id="0x0f-系统调用"><a href="#0x0f-系统调用" class="headerlink" title="0x0f 系统调用"></a>0x0f 系统调用</h2><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><blockquote><p>所谓系统调用就是让用户进程申请操作系统的帮助，让操作系统帮其完成某项工作，也就相当于是用户进程调用了操作系统的功能</p></blockquote><p>Linux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信号。Linux 只占用一个中断向量号，即 <code>0x80</code> ，处理器执行指令 <code>int 0x80</code> 时便出发了系统调用，而在系统调用之前，Linux 在寄存器 eax 写入子功能号，当用户通过 <code>int 0x80</code> 进行系统调用时，对应的中断处理例程会根据 eax 的值来判断用户进程申请哪种系统调用</p><p>我们来梳理一下系统调用的实现思路</p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250806172321153.png"><br>如上图：</p><ol><li>用中断门实现系统调用,效仿Linux 用0x80号中断作为系统调用的入口</li><li>在 IDT 中安装 0x80 号中断对应的描述符，在该描述符种注册系统调用对应的中断处理例程</li><li>建立系统调用子功能函数表 syscall_table,利用 eax 寄存器中的子功能号在该表中索引相应的处理函数</li><li>用宏实现用户空间系统调用接口_syscall</li></ol><h3 id="堆内存管理知识"><a href="#堆内存管理知识" class="headerlink" title="堆内存管理知识"></a>堆内存管理知识</h3><p>我们之前实现的内存管理形式过于粗糙，分配的内存是以4KB大小的页框为单位，所以我们需要实现一种小内存快的管理，可以满足任意内存大小的分配。</p><div class="note-large blue"><div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center"><p>arena</p></div><div class="notel-content"><p><strong><code>arena</code></strong>，一种内存管理概念，将大块内存划分为多个小块，每个小块之间互不干涉，可以分别管理，就叫做<code>arena</code></p><p>我们可以认为<code>arena</code>是由“一大块内存”被划分成无数“小内存块”的内存仓库。<code>arena</code>的这一大块内存就是通过<code>malloc_page</code>获得以 4KB 为粒度的内存，根据请求的内存量的大小， <code>arena</code>的大小也许是一个页框，也可能是多个页框，随后再平均拆分成多个小内存块。</p><p>根据内存块的大小，可以划分出不同规格的<code>arena</code>，例如一个<code>arena</code>中全是16字节大小的内存块，所以它<strong>只响应 16 字节以内的内存分配</strong>；另一种<code>arena</code>中全是32字节大小的内存块，故它<strong>只响应 32 字节以内的内存分配</strong>。</p><p>我们平时调用<code>malloc</code>申请内存的时候，操作系统返回的地址其实就是魔偶个内存块的起始地址，操作系统会根据<code>malloc</code>申请的内存大小来选择不同的内存块。</p><hr><p>同时，<code>arena</code>是一个提供内存分配的数据结构，它分为两部分：</p><ol><li>一部分是<strong>元信息</strong>，用来描述自己内存池中空闲内存块的数量，这其中包括内存块描述符指针，可以通过它间接获知本 <code>arena</code> 所包含内存块的规格大小。则一部分占用的空间约为 12 字节</li><li>另一部分是<strong>内存池区域</strong>，这里面由无数的内存块，此部分占用 <code>arena</code> 大量空间，我们把每个内存块命名为 <code>mem_block</code>,它们是内存分配粒度更细的资源，最终为用户分配的就是这其中的一个内存块</li></ol><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250806183545937.png" alt="image-20250806183545937"></p><p><img lazyload src="/images/loading.svg" data-src="/../images/image-20250806184353785.png"></p><p>但是<code>arena</code>逐渐变多，我们需要一个新的结构来统一描述<code>arena</code>，于是为每一种规格的内存块建立一个<strong>内存块描述符</strong>，即 <code>mem_block_desc</code>,在其中记录内存块规格大小，以及位于所有同类<code>arena</code>中的空闲内存块链表，<strong>内存块描述符</strong>简图如左图<br><img lazyload src="/images/loading.svg" data-src="/./05.assets/image-20250806214834984.png" alt="image-20250806214834984"></p></div></div><p><code>arena</code>以2为底，设计了 $2、4、8、16、32、64、128、256、512、1024$ 类别的小空间，适配各种类型的内存大小申请，以此完成了内存的获取</p><hr><p>而对于<strong>内存的释放</strong>：</p><p>我们知道，内存的使用情况通过<strong>位图</strong>来管理，所以其实当回收内存时，我们只需要将位图响应的位清0就好了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>🧩 模块一：IO互斥机制与锁的引入（0x0d）</strong></p><p>🛠 背景问题</p><ul><li>多个线程输出字符时访问了同一光标寄存器，造成屏幕显示混乱、触发 <code>#GP</code> 错误。</li><li>put_char() 是<strong>访问公共资源</strong>（VGA 寄存器）的<strong>临界区</strong>。</li></ul><p>✅ 技术要点</p><ul><li>引入<strong>信号量 semaphore</strong>的 P&#x2F;V 操作。</li><li>实现了二元信号量的封装：<code>lock_acquire / lock_release</code></li><li>通过 <code>console_put_str/char/int</code> 封装原始打印函数，加锁输出，确保原子性。</li></ul><p>✅ 设计优点</p><ul><li>替代 <code>cli/sti</code> 粗暴关中断的方式，更优雅、效率高。</li><li>提前为后续所有 IO 引入同步机制奠定基础。</li></ul><hr><p><strong>🧩 模块二：键盘输入驱动与环形缓冲区（0x0e）</strong></p><p>🔌 键盘输入原理</p><ul><li>键盘编码器（8048）产生<strong>扫描码</strong>，通过控制器（8042）传给主板，触发<strong>中断</strong>。</li><li>分为<strong>通码</strong>（按下）与<strong>断码</strong>（松开），通过中断例程处理。</li></ul><p>🔁 环形缓冲区设计</p><ul><li>输入是<strong>生产者-消费者模型</strong>的典型代表。</li><li><strong>环形结构</strong>通过逻辑循环（mod 操作）维护头尾指针。</li><li>支持并发读写：生产者（键盘中断）写入，消费者（Shell、read）读取。</li></ul><p>🔐 同步机制</p><ul><li>共享内存访问需加锁，避免 race condition。</li><li>支持输入阻塞等待唤醒。</li></ul><hr><p><strong>🧩 模块三：用户进程支持 —— LDT 和 TSS 的引入（0x0e）</strong></p><p>🧱 LDT（Local Descriptor Table）</p><ul><li>每个任务拥有独立的段描述符集合（代码段、数据段等）</li><li>每次进程切换需重新加载 LDT 选择子至 <code>LDTR</code>，实现段访问隔离。</li></ul><p>🧠 TSS（Task State Segment）</p><ul><li>存储进程的<strong>寄存器快照</strong>与栈指针。</li><li>由 CPU 自动读写（硬件支持上下文切换）</li><li>每个进程一个 TSS，挂载在 GDT 中，通过 <code>ltr</code> 加载至 <code>TR</code>。</li></ul><p>🧵 任务切换逻辑</p><ol><li><code>TR</code> 始终指向当前任务的 TSS。</li><li>切换任务时：<ul><li>旧任务寄存器值写入当前 TSS</li><li>新任务 TSS 中值恢复进寄存器</li></ul></li><li>可实现 ring0 &lt;-&gt; ring3 特权级栈切换</li></ol><hr><p><strong>🧩 模块四：系统调用机制（0x0f）</strong></p><p>📥 基本原理</p><ul><li>用户进程不能直接访问内核，需要通过中断机制转入 ring0。</li><li>模拟 Linux，使用 <code>int 0x80</code> 发起软中断。</li></ul><p>🧩 实现流程</p><ol><li>内核 IDT 中注册 0x80 中断描述符，绑定系统调用处理例程。</li><li>用户层调用 <code>_syscallX(...)</code> 宏，将功能号装入 eax，参数入 ebx&#x2F;ecx&#x2F;edx 等。</li><li>中断后内核通过 eax 查找 <code>syscall_table[]</code>，调用对应函数。</li></ol><p>🔑 系统调用的核心意义</p><ul><li>用户态安全调用内核服务（如 write、malloc、exit）</li><li>建立用户态与内核态的通信桥梁</li></ul><hr><p><strong>🧩 模块五：精细堆内存管理 —— Arena机制</strong></p><p>📦 问题动因</p><ul><li>原先基于页框（4KB）为单位分配内存，浪费严重。</li><li>需引入<strong>小块内存分配器</strong>来管理堆空间。</li></ul><p>🧰 Arena 内存池机制</p><ul><li>Arena 是多个小内存块 mem_block 的集合。</li><li>每种内存块规格（2^n 字节）拥有专属 Arena 管理。</li><li>mem_block 通过双向链表组织，支持高效分配与回收。</li></ul><p>🔄 释放机制</p><ul><li>回收时只需将块归还至空闲链表。</li><li>若 arena 所有块都空闲，释放整页。</li></ul><hr></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 操作系统学习笔记05-从IO机制到系统调用</li><li><strong>作者:</strong> Maple</li><li><strong>创建于 :</strong> 2025-08-06 18:49:06</li><li><strong>更新于 :</strong> 2025-08-06 22:01:20</li><li><strong>链接:</strong> https://github.com/maple-pwn/maple-pwn.github.io/2025/08/06/操作系统学习笔记05-从IO机制到系统调用/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/OS/">#OS</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2025/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-%E4%BB%8E%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E5%88%B0%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">操作系统学习笔记04-从页表映射到线程调度</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">操作系统学习笔记05-从IO机制到系统调用</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x0d-%E5%AE%9E%E7%8E%B0%E5%8C%85%E5%90%AB%E9%94%81%E7%9A%84IO%E6%9C%BA%E5%88%B6"><span class="nav-text">0x0d 实现包含锁的IO机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">0x01 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02-%E7%94%A8%E9%94%81%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E8%BE%93%E5%87%BA"><span class="nav-text">0x02 用锁实现终端输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03-%E4%BB%8E%E9%94%AE%E7%9B%98%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5"><span class="nav-text">0x03 从键盘获取输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04-%E7%8E%AF%E5%BD%A2%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">0x04 环形输入缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x0e-%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="nav-text">0x0e 用户进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LDT-TSS"><span class="nav-text">LDT &amp; TSS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x0f-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">0x0f 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-text">基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86"><span class="nav-text">堆内存管理知识</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2025</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Maple</a><p class="post-count space-x-0.5"><span>共撰写了 10 篇文章</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/localSearch.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/libs/mermaid.min.js"></script><script src="/js/build/plugins/mermaid.js"></script><script src="/js/build/libs/anime.min.js"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/bookmarkNav.js" type="module"></script></body></html>