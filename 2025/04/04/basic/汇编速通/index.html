<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"maple-pwn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="汇编速通by Maple 机器级代码机器级编程，两种抽象比较重要  第一种是由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。  以上不重要 数据格式Intel 用术语“字（w">
<meta property="og:type" content="article">
<meta property="og:title" content="Maple">
<meta property="og:url" content="http://maple-pwn.github.io/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/index.html">
<meta property="og:site_name" content="Maple">
<meta property="og:description" content="汇编速通by Maple 机器级代码机器级编程，两种抽象比较重要  第一种是由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。 第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。  以上不重要 数据格式Intel 用术语“字（w">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220704191537496.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220704192557175.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220704194524240.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/add-computation-example.jpg">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220704194834339.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220828200248791.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220705193103548.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220705194040325.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220705195332940.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220902201422665.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220705195602494.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220905144239732.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220905144652985.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220905145814013.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220706195512876.png">
<meta property="og:image" content="http://maple-pwn.github.io/images/image-20220706200736910.png">
<meta property="article:published_time" content="2025-04-03T17:34:36.742Z">
<meta property="article:modified_time" content="2025-02-16T16:07:44.134Z">
<meta property="article:author" content="Maple">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://maple-pwn.github.io/images/image-20220704191537496.png">


<link rel="canonical" href="http://maple-pwn.github.io/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://maple-pwn.github.io/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/","path":"2025/04/04/basic/汇编速通/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Maple</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Maple</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maple’s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A"><span class="nav-number">1.</span> <span class="nav-text">汇编速通</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81"><span class="nav-number">1.1.</span> <span class="nav-text">机器级代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.2.</span> <span class="nav-text">数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E8%AE%BF%E9%97%AE%E2%AD%90"><span class="nav-number">1.3.</span> <span class="nav-text">信息访问⭐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">1.3.1.</span> <span class="nav-text">操作数指示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据传送指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.4.</span> <span class="nav-text">压入和弹出栈数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.</span> <span class="nav-text">算数和逻辑操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80leaq"><span class="nav-number">1.4.2.</span> <span class="nav-text">加载有效地址leaq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.3.</span> <span class="nav-text">特殊的算数操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.</span> <span class="nav-text">控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">访问条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.3.</span> <span class="nav-text">跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B-2"><span class="nav-number">1.5.4.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.5.5.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">1.5.6.</span> <span class="nav-text">switch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="nav-number">1.6.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">数据传送</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="nav-number">1.7.</span> <span class="nav-text">数组分配与访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.8.</span> <span class="nav-text">异质的数据结构</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Maple</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/%E6%B1%87%E7%BC%96%E9%80%9F%E9%80%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-17 00:07:44" itemprop="dateModified" datetime="2025-02-17T00:07:44+08:00">2025-02-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="汇编速通"><a href="#汇编速通" class="headerlink" title="汇编速通"></a>汇编速通</h1><p>by Maple</p>
<h2 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h2><p>机器级编程，两种抽象比较重要</p>
<ol>
<li>第一种是由指令集体系结构或指令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li>
<li>第二种是机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的<strong>字节</strong>数组。</li>
</ol>
<p><em>以上不重要</em></p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel 用术语“字（word）”表示 16 位数据类型，称 32 位数为“双字（double words）”，称 64 位数为“四字（quad words）”。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704191537496.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-1 C 语言数据类型在 x86-64 中的大小。在 64 位机器中，指针长 8 字节</td>
</tr>
</tbody></table>
<p>如上图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：<code>movb</code>（传送字节）、<code>movw</code>（传送字）、<code>movl</code>（传送双字）和 <code>movq</code>（传送四字）。注意，汇编代码也使用后缀 <code>l</code> 来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为<strong>浮点数使用的是一组完全不同的指令和寄存器</strong>。</p>
<h2 id="信息访问⭐"><a href="#信息访问⭐" class="headerlink" title="信息访问⭐"></a>信息访问⭐</h2><p>一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器，这些寄存器用来存储整数数据和指针。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704192557175.png" alt="image-20220704192557175"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-2 整数寄存器</td>
</tr>
</tbody></table>
<p>指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。</p>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704194524240.png" alt="image-20220704194524240"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-3 操作数格式。<strong>比例因子 <code>s</code> 必须是 1、2、4 或者 8</strong>。</td>
</tr>
</tbody></table>
<p>地址计算的练习</p>
<table>
<thead>
<tr>
<th><img src="/./images/add-computation-example.jpg" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td></td>
</tr>
</tbody></table>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p><code>mov</code> 类指令把数据从源位置<strong>复制</strong>到目的位置，不做任何变化。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220704194834339.png" alt="image-20220704194834339"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-4 简单的数据传送指令</td>
</tr>
</tbody></table>
<p>x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">exchange</span> <span class="params">(<span class="type">long</span> *xp, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc -og exchange exchange.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.long exchange (long *xp, long y)</span><br><span class="line">.xp in %rdi, y in %rsi</span><br><span class="line">exchange:</span><br><span class="line">	movq	(%rdi), %rax	将xp赋值给x，然后作为返回值</span><br><span class="line">	movq	%rsi, (%rdi)	将y存储在xp中</span><br><span class="line">	ret						返回</span><br></pre></td></tr></table></figure>

<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><table>
<thead>
<tr>
<th><img src="/./images/image-20220828200248791.png" alt="image-20220828200248791"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-8 入栈和出栈指令</td>
</tr>
</tbody></table>
<p><code>pushq</code> 和 <code>popq</code> 指令都只有一个操作数：压入的数据源和弹出的数据目的。</p>
<p>将一个四字值压入栈中，首先要将栈指针（栈指针 <code>%rsp</code> 保存着栈顶元素的地址）减 8，然后将值写到新的栈顶地址。在 x86-64 中，栈向低地址方向增长，所以压栈是减小栈指针（寄存器 <code>%rsp</code>）的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值。</p>
<p>无论如何，<code>%rsp</code> 指向的地址总是栈顶。</p>
<h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p><strong>源在前，目的地在后</strong></p>
<p>下图这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705193103548.png" alt="image-20220705193103548"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-10 整数算术操作。<strong>注意：ATT 格式的汇编代码中，操作数的顺序与直觉相反</strong>。</td>
</tr>
</tbody></table>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">arith</span> <span class="params">(<span class="type">long</span> x, <span class="type">long</span> y, <span class="type">long</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> t1 = x + y;</span><br><span class="line">    <span class="type">long</span> t2 = z + t1;</span><br><span class="line">    <span class="type">long</span> t3 = x + <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> t4 = y * <span class="number">48</span>;</span><br><span class="line">    <span class="type">long</span> t5 = t3 + t4;</span><br><span class="line">    <span class="type">long</span> rval = t2 * t5;</span><br><span class="line">    <span class="keyword">return</span> raval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.x in %rdi, y in %rsi, z in %rdx, t1、t2、rval in %rax, t4 in %rdx, t5 in %rcx</span><br><span class="line">arith:</span><br><span class="line">	leaq	(%rdi, %rsi), %rax		;t1 = x + y</span><br><span class="line">	addq	%rdx, %rax				;t2 = z + t1</span><br><span class="line">	leaq	(%rsi, %rsi, 2), %rdx	;t4 = y+y*2 =&gt; t4 = 3*y</span><br><span class="line">	salq 	$4, %rdx				;t4&lt;&lt;4 =&gt; t4*=16</span><br><span class="line">									;加在一起就是t4 = y*48</span><br><span class="line">	leaq	4(%rdi, %rdx), %rcx		;t5 = 4 + x + t4</span><br><span class="line">	imulq	%rcx, %rax				;rval*=t5</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="加载有效地址leaq"><a href="#加载有效地址leaq" class="headerlink" title="加载有效地址leaq"></a>加载有效地址<code>leaq</code></h3><p>加载有效地址（load effective address）指令 <code>leaq</code> 实际上是 <code>movq</code> 指令的变形，<strong>它的第一个操作数将有效地址写入到目的操作数</strong>。<strong>目的操作数必须是一个寄存器</strong>。</p>
<h3 id="特殊的算数操作"><a href="#特殊的算数操作" class="headerlink" title="特殊的算数操作"></a>特殊的算数操作</h3><p>x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。延续字（2 字节）、双字（4 字节）和四字（8 字节）的命名惯例，Intel 把 16 字节的数称为八字（oct word）。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705194040325.png" alt="image-20220705194040325"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-12 特殊的算术操作。一对寄存器 <code>%rdx</code> 和 <code>%rax</code> 组成一个 128 位的八字</td>
</tr>
</tbody></table>
<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU 还维护着一组单个位的条件码（condition code）寄存器。</p>
<p>最常用的条件码有：</p>
<ul>
<li>CF：进位标志。最近的操作使最高位产生了进位，可用来检查无符号操作的溢出。</li>
<li>ZF：零标志。最近的操作得出的结果为 0。</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出，正溢出或负溢出。</li>
</ul>
<p><code>leaq</code> 指令不改变任何条件码，它是用来进行地址计算的，<strong>除此之外</strong>，图 3-10中列出的所有指令都会设置条件码。还有两类指令，它们只设置条件码而不改变任何其他寄存器，如下图所示：</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705195332940.png" alt="image-20220705195332940"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-13 比较和测试指令。这些指令不修改任何寄存器的值，只设置条件码</td>
</tr>
</tbody></table>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><table>
<thead>
<tr>
<th><img src="/./images/image-20220902201422665.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-14 <code>SET</code> 指令</td>
</tr>
</tbody></table>
<p>某些底层的机器指令可能有多个名字，称之为“同义名（synonym）”。例如，<code>setg</code>（表示“设置大于”）和 <code>setnle</code>（表示“设置不小于等于”）指的就是同一条机器指令，编译器和反汇编器会随意决定使用哪个名字。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>类似于<code>goto</code>代码</p>
<p>考虑下面的汇编代码序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  movq $0,%rax	; Set %rax to 0</span><br><span class="line">  jmp .L1	; Goto .L1</span><br><span class="line">  movq (%rax),%rdx	; Null pointer dereference (skipped)</span><br><span class="line">.L1:</span><br><span class="line">  popq %rdx  ; Jump target</span><br></pre></td></tr></table></figure>

<p>指令 <code>jmp .L1</code> 会导致程序跳过 <code>movq</code> 指令，而从 <code>popq</code> 指令开始继续执行。</p>
<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220705195602494.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-15 <code>jump</code> 指令</td>
</tr>
</tbody></table>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> lt_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> ge_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">absdiff_se</span> <span class="params">(<span class="type">long</span> x, <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        lt_cnt++;</span><br><span class="line">        result = y-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        gc_cnt++;</span><br><span class="line">        result = x-y;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.long absdiff_se (long x, long y)</span><br><span class="line">.x in %rdi, y in %rsi</span><br><span class="line">absdidd_se:</span><br><span class="line">	cmpq	%rsi, %rdi			;比较x:y</span><br><span class="line">	jge		.L2					;如果x&gt;=y，跳转到L2处</span><br><span class="line">	addq	$1, lt_cnt(%rip)	;lt_cnt++</span><br><span class="line">    movq	%rsi, %rax			;result = y</span><br><span class="line">    subq	%rdi, %rax			;result-=x;</span><br><span class="line">.L2:</span><br><span class="line">	addq	$1,ge_cnt(%rip)		;gd_cnt++</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">	subq	%rsi, %rax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>其实和判断是一样的，goto回循环开头</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><code>switch</code>（开关）语句可以根据一个<strong>整数索引值</strong>进行多重分支（multiway branching），在处理具有多种可能结果的测试时，这种语句特别有用。通过使用跳转表（jump table）这种数据结构使得实现。</p>
<p>使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句，当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220905144239732.png" alt="img"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-22 <code>switch</code> 语句示例以及翻译到扩展的 C 语言。 该翻译给出了跳转表 <code>jt</code> 的结构，以及如何访问它。作为对 C 语言的扩展，GCC 支持这样的表。</td>
</tr>
<tr>
<td><img src="/./images/image-20220905144652985.png" alt="img"></td>
</tr>
<tr>
<td>上图 <code>switch</code> 语句示例的汇编代码</td>
</tr>
<tr>
<td><img src="/./images/image-20220905145814013.png" alt="image-20220905145814013"></td>
</tr>
<tr>
<td>在汇编代码中，跳转表用上述声明表示</td>
</tr>
</tbody></table>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>假设</strong>过程 <code>P</code> 调用过程 <code>Q</code>，<code>Q</code> 执行后返回到 <code>P</code>。这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制。在进入过程 <code>Q</code> 的时候，程序计数器必须被设置为 <code>Q</code> 的代码的起始地址，然后在返回时，要把程序计数器设置为 <code>P</code> 中调用 <code>Q</code> 后面那条指令的地址。</li>
<li>传递数据。<code>P</code> 必须能够向 <code>Q</code> 提供一个或多个参数，<code>Q</code> 必须能够向 <code>P</code> 返回一个值。</li>
<li>分配和释放内存。在开始时，<code>Q</code> 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。</p>
<p>将栈指针（<code>%rsp</code>）减小一个适当的量可以为没有指定初始值的数据在栈上分配空间，类似地，可以通过增加栈指针来释放空间。</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220706195512876.png" alt="image-20220706195512876"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-25 通用的栈帧结构</td>
</tr>
</tbody></table>
<p>当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧（stack frame）。</p>
<p>通过寄存器，过程 <code>P</code> 可以传递最多 6 个整数值（也就是指针和整数），但是如果 <code>Q</code> 需要更多的参数，<code>P</code> 可以在调用 <code>Q</code> 之前在自己的栈帧里存储好这些参数。</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>x86-64 中，可以通过寄存器最多传递 6 个整型（整数和指针）参数。寄存器的使用是<strong>有特殊顺序的</strong>，寄存器使用的名字取决于要传递的数据类型的大小，如下图所示：</p>
<table>
<thead>
<tr>
<th><img src="/./images/image-20220706200736910.png" alt="image-20220706200736910"></th>
</tr>
</thead>
<tbody><tr>
<td>图 3-28 传递函数参数的寄存器。寄存器是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的</td>
</tr>
</tbody></table>
<p>会根据参数在参数列表中的顺序为它们分配寄存器，可以通过 64 位寄存器适当的部分访问小于 64 位的参数。例如，如果第一个参数是 32 位的，那么可以用 <code>%edi</code> 来访问它。</p>
<p>如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。</p>
<h2 id="数组分配与访问"><a href="#数组分配与访问" class="headerlink" title="数组分配与访问"></a>数组分配与访问</h2><p>略</p>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>就是<code>struct</code>、<code>union</code>这样子的数据结构</p>
<p>略</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/04/basic/Canary/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/04/04/basic/PIE/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Maple</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
