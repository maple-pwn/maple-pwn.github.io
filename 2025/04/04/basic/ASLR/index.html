<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"maple-pwn.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="ASLR有点硬核，打*的先不看 ASLR就是地址空间布局随机化，当ASLR开启时，程序每次运行时的内存布局都是相同的；打开后每次运行时的内存布局都会发生变化   0：完全关闭 1：部分开启（堆、栈、MMAP、动态链接库） 2：完全开启（BRK、堆、栈、MMAP、动态链接库）   1 实现原理程序加载到内存中的内存布局是由操作系统决定的，通过上面的ASLR开关方式可以知道，用户空间可以借助内核提供的">
<meta property="og:type" content="article">
<meta property="og:title" content="Maple">
<meta property="og:url" content="http://maple-pwn.github.io/2025/04/04/basic/ASLR/index.html">
<meta property="og:site_name" content="Maple">
<meta property="og:description" content="ASLR有点硬核，打*的先不看 ASLR就是地址空间布局随机化，当ASLR开启时，程序每次运行时的内存布局都是相同的；打开后每次运行时的内存布局都会发生变化   0：完全关闭 1：部分开启（堆、栈、MMAP、动态链接库） 2：完全开启（BRK、堆、栈、MMAP、动态链接库）   1 实现原理程序加载到内存中的内存布局是由操作系统决定的，通过上面的ASLR开关方式可以知道，用户空间可以借助内核提供的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-04-03T17:34:36.739Z">
<meta property="article:modified_time" content="2025-02-28T15:44:14.536Z">
<meta property="article:author" content="Maple">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://maple-pwn.github.io/2025/04/04/basic/ASLR/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://maple-pwn.github.io/2025/04/04/basic/ASLR/","path":"2025/04/04/basic/ASLR/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Maple</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Maple</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maple’s Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ASLR"><span class="nav-number">1.</span> <span class="nav-text">ASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">1 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%99%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">*1.1 虚文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-proc"><span class="nav-number">1.1.2.</span> <span class="nav-text">*1.2 proc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-randomize-va-space%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">*1.3 randomize_va_space变量的设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8C%96%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 内存布局的随机化设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-mmap%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1 mmap随机化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E6%A0%88%E7%9A%84%E9%9A%8F%E6%9C%BA%E5%8C%96"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2 栈的随机化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 随机化总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.</span> <span class="nav-text">2 绕过思路</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Maple</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://maple-pwn.github.io/2025/04/04/basic/ASLR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Maple">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maple">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Maple">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-04 01:34:36" itemprop="dateCreated datePublished" datetime="2025-04-04T01:34:36+08:00">2025-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-28 23:44:14" itemprop="dateModified" datetime="2025-02-28T23:44:14+08:00">2025-02-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h1><p>有点硬核，打*的先不看</p>
<p>ASLR就是地址空间布局随机化，当ASLR开启时，程序每次运行时的内存布局都是相同的；打开后每次运行时的内存布局都会发生变化</p>
<blockquote>
<ul>
<li>0：完全关闭</li>
<li>1：部分开启（堆、栈、MMAP、动态链接库）</li>
<li>2：完全开启（BRK、堆、栈、MMAP、动态链接库）</li>
</ul>
</blockquote>
<h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1 实现原理"></a>1 实现原理</h2><p>程序加载到内存中的内存布局是由操作系统决定的，通过上面的ASLR开关方式可以知道，用户空间可以借助内核提供的<code>proc</code>虚文件对ASLR控制</p>
<h3 id="1-1-虚文件系统"><a href="#1-1-虚文件系统" class="headerlink" title="*1.1 虚文件系统"></a>*1.1 虚文件系统</h3><p>Linux为了避免用户空间程序操作文件时仍需要考虑不同文件系统带来的差异问题，Linux提供了一个统一的接口供用户空间使用，叫做<code>VFS(虚拟文件系统)</code></p>
<p><code>VFS</code>为了支持各种文件系统，它定义一套所有文件系统都支持的接口和数据结构，用于支持各类文件系统和VFS协同工作</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV     1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE      4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT     8   <span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_DISALLOW_NOTIFY_PERM 16  <span class="comment">/* Disable fanotify permission events */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ALLOW_IDMAP         32      <span class="comment">/* FS has been updated to handle vfs idmappings. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE   32768   <span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">    <span class="type">int</span> (*init_fs_context)(<span class="keyword">struct</span> fs_context *);</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">               <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">invalidate_lock_key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote>
<p>Linux内文件系统需要设置<code>file_system_type</code>信息，然后将设置好的信息提交给<code>register_filesystem</code>函数进行注册，只有完成注册的文件系统才能被VFS操控</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">register_filesystem</span> <span class="params">(<span class="keyword">struct</span> file_system_type *)</span>;</span><br></pre></td></tr></table></figure>

<p><code>file_system_type</code>本身比较简单，主要就是定义获取和删除<code>super_block</code>的接口及属性信息，不同文件系统间的<code>file_system_type</code>之间通过链接进行管理</p>
<blockquote>
<p><code>super_block</code>是一个更加复杂的结构体，它定义了文件系统的具体信息和对应文件系统的操作接口，是实际管理文件系统的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>     <span class="comment">/* Keep this first */</span></span><br><span class="line">    <span class="type">dev_t</span>           s_dev;      <span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       s_blocksize_bits;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_blocksize;</span><br><span class="line">    <span class="type">loff_t</span>          s_maxbytes; <span class="comment">/* Max file size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>   *<span class="title">s_op</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>   *<span class="title">dq_op</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>   *<span class="title">s_qcop</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_iflags;   <span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       s_magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>       *<span class="title">s_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">s_umount</span>;</span></span><br><span class="line">    <span class="type">int</span>         s_count;</span><br><span class="line">    <span class="type">atomic_t</span>        s_active;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">spinlock_t</span>      s_inode_wblist_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes_wb</span>;</span>    <span class="comment">/* writeback inodes */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure></blockquote>
<p>而下面展示了<code>proc</code>文件系统的注册过程</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">proc_fs_type</span> =</span> &#123;</span><br><span class="line">    .name           = <span class="string">&quot;proc&quot;</span>,</span><br><span class="line">    .init_fs_context    = proc_init_fs_context,</span><br><span class="line">    .parameters     = proc_fs_parameters,</span><br><span class="line">    .kill_sb        = proc_kill_sb,</span><br><span class="line">    .fs_flags       = FS_USERNS_MOUNT | FS_DISALLOW_NOTIFY_PERM,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __init <span class="title function_">proc_root_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    register_filesystem(&amp;proc_fs_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p><code>proc</code>是进程文件系统，属于Linux中伪文件系统中的一种，它没有对应真实的磁盘或硬盘，而是提供给用户空间便利的使用Linux系统资源的接口。常见的伪文件系统有<code>proc</code>,<code>sys</code>,<code>dev</code>等。<code>proc</code>可以方便的查看进程信息，比如进程的内存布局，CPU信息等</p>
<h3 id="1-2-proc"><a href="#1-2-proc" class="headerlink" title="*1.2 proc"></a>*1.2 proc</h3><p>进行Linux驱动开发时，可以借助<code>proc_ops</code>结构体，<code>proc_create</code>接口、<code>proc_remove</code>接口对<code>proc</code>进行创建和控制。</p>
<p><code>prco_ops</code>结构体中有两个较为重要的成员，即<code>proc_read</code>和<code>proc_write</code>，它们分别会响应虚文件被用户空间读写时的操作。下面给出了创建<code>proc</code>虚文件的示例代码</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>* <span class="title">lde_proc_entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lde_proc_read</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">char</span> __user* ubuf, <span class="type">size_t</span> count, <span class="type">loff_t</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s called file 0x%px, buffer 0x%px count 0x%lx off 0x%llx\n&quot;</span>,</span><br><span class="line">        __func__, file, ubuf, count, *data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lde_proc_write</span><span class="params">(<span class="keyword">struct</span> file* file, <span class="type">const</span> <span class="type">char</span> __user* ubuf, <span class="type">size_t</span> count, <span class="type">loff_t</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%s called legnth 0x%lx, 0x%px\n&quot;</span>,</span><br><span class="line">        __func__, count, ubuf);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">lde_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_read = lde_proc_read,</span><br><span class="line">    .proc_write = lde_proc_write</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">lde_proc_create</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"> </span><br><span class="line">    ret = SUCCEED;</span><br><span class="line"> </span><br><span class="line">    lde_proc_entry = proc_create(<span class="string">&quot;lde_proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;lde_proc_ops);</span><br><span class="line">    <span class="keyword">if</span> (!lde_proc_entry) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;%s create proc entry failed\n&quot;</span>, __func__);</span><br><span class="line"> </span><br><span class="line">        ret = PROC_CREATE_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lde_proc_remove</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lde_proc_entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;%s proc not exists\n&quot;</span>, __func__);</span><br><span class="line">        <span class="keyword">goto</span> TAG_RETURN;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    proc_remove(lde_proc_entry);</span><br><span class="line"> </span><br><span class="line">TAG_RETURN:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>通过读写虚文件，可以在<code>dmesg</code>中看到相关的打印信息</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/lde_proc</span><br><span class="line">echo test | sudo tee -a /proc/lde_proc</span><br><span class="line"> </span><br><span class="line">[  440.396298] starting from 0xffffffffc0af6090 ...</span><br><span class="line">[  446.024481] lde_proc_read called file 0xffff9626c2931400, buffer 0x000077aeb6db8000 count 0x40000 off 0x0</span><br><span class="line">[  459.392387] lde_proc_write called legnth 0x5, 0x00007fff783f3090</span><br><span class="line">[  476.345011] exiting from 0xffffffffc0af60f0 ...</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-3-randomize-va-space变量的设置"><a href="#1-3-randomize-va-space变量的设置" class="headerlink" title="*1.3 randomize_va_space变量的设置"></a>*1.3 randomize_va_space变量的设置</h3><p><code>proc</code>除了支持访问进程信息外，它还支持在Linux内核运行时对内核参数进行修改，该机制也被叫做<code>sysctl</code></p>
<p><code>proc/sys/kernel/</code>中的虚文件会通过<code>kern_table</code>进行定义，每个模块都会定义一个处理函数贺数据对象，处理函数会负责处理虚文件被读写时进行的操作，而数据对象则是被操作的数值。<code>randomize_va_space</code>指定的处理函数史<code>proc_dointvec</code>，其作用是读取整数值或写入整数值，待处理的数据对象是<code>randomize_va_space</code>，它是一个整型的全局变量</p>
<p>当向<code>proc/sys/kernel/randomize_va_space</code>写入数值时，<code>randomize_va_space</code>变量的数值就会被<code>proc_dointvec</code>函数修改</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">kern_table</span>[] =</span> &#123;</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_MMU)</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname   = <span class="string">&quot;randomize_va_space&quot;</span>,</span><br><span class="line">        .data       = &amp;randomize_va_space,</span><br><span class="line">        .maxlen     = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode       = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler   = proc_dointvec,</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-4-内存布局的随机化设置"><a href="#1-4-内存布局的随机化设置" class="headerlink" title="1.4 内存布局的随机化设置"></a>1.4 内存布局的随机化设置</h3><p>当程序启动时，负责加载ELF文件的<code>load_elf_binary</code>函数会根据<code>randomize_va_space</code>变量设置标志位，当标志位完成设置后，才会正式开始BRK、MMAP、堆、栈、动态链接库、vDSO的地址随机化，随机化的主要操作就是根据随机值堆地址进行偏移</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">	current-&gt;flags |= PF_RANDOMIZE;</span><br><span class="line">   setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* Do this so that we can load the interpreter, if need be.  We will</span></span><br><span class="line"><span class="comment">  change some of these later */</span></span><br><span class="line">&gt;retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">            executable_stack);</span><br><span class="line">&gt;......</span><br><span class="line">&gt;mm = current-&gt;mm;</span><br><span class="line">&gt;mm-&gt;end_code = end_code;</span><br><span class="line">&gt;mm-&gt;start_code = start_code;</span><br><span class="line">&gt;mm-&gt;start_data = start_data;</span><br><span class="line">&gt;mm-&gt;end_data = end_data;</span><br><span class="line">&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line"></span><br><span class="line">&gt;......</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> (!first_pt_load) &#123;</span><br><span class="line">       elf_flags |= MAP_FIXED;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_EXEC) &#123;</span><br><span class="line">       elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;</span><br><span class="line">       <span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line">           load_bias = ELF_ET_DYN_BASE;</span><br><span class="line">           <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">               load_bias += arch_mmap_rnd();</span><br><span class="line">           alignment = maximum_alignment(elf_phdata, elf_ex-&gt;e_phnum);</span><br><span class="line">           <span class="keyword">if</span> (alignment)</span><br><span class="line">               load_bias &amp;= ~(alignment - <span class="number">1</span>);</span><br><span class="line">           elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">           load_bias = <span class="number">0</span>;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;......</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * For architectures with ELF randomization, when executing</span></span><br><span class="line"><span class="comment">    * a loader directly (i.e. no interpreter listed in ELF</span></span><br><span class="line"><span class="comment">    * headers), move the brk area out of the mmap region</span></span><br><span class="line"><span class="comment">    * (since it grows up, and may collide early with the stack</span></span><br><span class="line"><span class="comment">    * growing down), and into the unused ELF_ET_DYN_BASE region.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (IS_ENABLED(CONFIG_ARCH_HAS_ELF_RANDOMIZE) &amp;&amp; elf_ex-&gt;e_type == ET_DYN &amp;&amp; !interpreter) </span><br><span class="line">   &#123;</span><br><span class="line">       mm-&gt;brk = mm-&gt;start_brk = ELF_ET_DYN_BASE;</span><br><span class="line">   &#125;</span><br><span class="line">   mm-&gt;brk = mm-&gt;start_brk = arch_randomize_brk(mm);</span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> compat_brk_randomized</span></span><br><span class="line">&gt;current-&gt;brk_randomized = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;......</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p><em>看不懂没事，因为看不懂也能做题</em></p>
<h4 id="1-4-1-mmap随机化"><a href="#1-4-1-mmap随机化" class="headerlink" title="1.4.1 mmap随机化"></a>1.4.1 mmap随机化</h4><p>内核会通过<code>arch_pick_mmap_layout</code>函数对MMAP进行随机化，当检测到标志位开启时，就会提供随机值给MMAP，否则会提供0，MMAP会根据该数值对地址空间进行设置</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_new_exec</span><span class="params">(<span class="keyword">struct</span> linux_binprm * bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    arch_pick_mmap_layout(me-&gt;mm, &amp;bprm-&gt;rlim_stack);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(setup_new_exec);</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">arch_pick_mmap_layout</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> rlimit *rlim_stack)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    arch_pick_mmap_base(&amp;mm-&gt;mmap_base, &amp;mm-&gt;mmap_legacy_base,</span><br><span class="line">            arch_rnd(mmap64_rnd_bits), task_size_64bit(<span class="number">0</span>),</span><br><span class="line">            rlim_stack);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_rnd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rndbits)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;flags &amp; PF_RANDOMIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h4 id="1-4-2-栈的随机化"><a href="#1-4-2-栈的随机化" class="headerlink" title="1.4.2 栈的随机化"></a>1.4.2 栈的随机化</h4><p><code>load_elf_binary</code>函数会先通过<code>setup_arg_page</code>函数设置栈空间。栈空间的偏移值由<code>randomize_stack_top</code>的结果决定，当标志位中存在<code>PF_RANDOMIZE</code>时，<code>randomize_stack_top</code>将地址根据随机值进行偏移，否则就不会进行偏移</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">randomize_stack_top</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> stack_top)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> random_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE) &#123;</span><br><span class="line">       random_variable = get_random_long();</span><br><span class="line">       random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">       random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">   <span class="keyword">return</span> PAGE_ALIGN(stack_top) + random_variable;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> <span class="title function_">setup_arg_pages</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm,</span></span><br><span class="line"><span class="params">           <span class="type">unsigned</span> <span class="type">long</span> stack_top,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> executable_stack)</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   ......</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">   <span class="comment">/* Limit stack size */</span></span><br><span class="line">   stack_base = bprm-&gt;rlim_stack.rlim_max;</span><br><span class="line"></span><br><span class="line">   stack_base = calc_max_stack_size(stack_base);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Add space for stack randomization. */</span></span><br><span class="line">   stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Make sure we didn&#x27;t let the argument array grow too large. */</span></span><br><span class="line">   <span class="keyword">if</span> (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)</span><br><span class="line">       <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   stack_base = PAGE_ALIGN(stack_top - stack_base);</span><br><span class="line"></span><br><span class="line">   stack_shift = vma-&gt;vm_start - stack_base;</span><br><span class="line">   mm-&gt;arg_start = bprm-&gt;p - stack_shift;</span><br><span class="line">   bprm-&gt;p = vma-&gt;vm_end - stack_shift;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   stack_top = arch_align_stack(stack_top);</span><br><span class="line">   stack_top = PAGE_ALIGN(stack_top);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (unlikely(stack_top &lt; mmap_min_addr) ||</span><br><span class="line">       unlikely(vma-&gt;vm_end - vma-&gt;vm_start &gt;= stack_top - mmap_min_addr))</span><br><span class="line">       <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">   stack_shift = vma-&gt;vm_end - stack_top;</span><br><span class="line"></span><br><span class="line">   bprm-&gt;p -= stack_shift;</span><br><span class="line">   mm-&gt;arg_start = bprm-&gt;p;</span><br><span class="line">&gt;<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   ......</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>一般来说，栈是向下增长的，如果支持栈向上增长，那么可以通过<code>CONFIG_STACK_GROWSUP</code>对内核进行配置。处理栈空间的地址时，如果不使用<code>CONFIG_STACK_GROWSUP</code>功能，那么栈顶地址会通过<code>arch_align_stack</code>再次进行偏移，然后将低4比特设置为0，进行对齐。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_align_stack</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">        sp -= prandom_u32_max(<span class="number">8192</span>);</span><br><span class="line">    <span class="keyword">return</span> sp &amp; ~<span class="number">0xf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.4</span>.<span class="number">3</span> 动态链接的随机化</span><br><span class="line"></span><br><span class="line">当`load_elf_binary`函数处理动态链接库时，它会根据标志位决定是否给动态链接库的加载地址设置偏移值，偏移值的数值由`arch_rnd`获取。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_rnd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rndbits)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(current-&gt;flags &amp; PF_RANDOMIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">arch_mmap_rnd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arch_rnd(mmap_is_ia32() ? mmap32_rnd_bits : mmap64_rnd_bits);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">load_elf_binary&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!first_pt_load) &#123;</span><br><span class="line">        elf_flags |= MAP_FIXED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_EXEC) &#123;</span><br><span class="line">        elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elf_ex-&gt;e_type == ET_DYN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interpreter) &#123;</span><br><span class="line">            load_bias = ELF_ET_DYN_BASE;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_RANDOMIZE)</span><br><span class="line">                load_bias += arch_mmap_rnd();</span><br><span class="line">            alignment = maximum_alignment(elf_phdata, elf_ex-&gt;e_phnum);</span><br><span class="line">            <span class="keyword">if</span> (alignment)</span><br><span class="line">                load_bias &amp;= ~(alignment - <span class="number">1</span>);</span><br><span class="line">            elf_flags |= MAP_FIXED_NOREPLACE;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            load_bias = <span class="number">0</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="1-5-随机化总结"><a href="#1-5-随机化总结" class="headerlink" title="1.5 随机化总结"></a>1.5 随机化总结</h3><p>上面已经描述了需要随机化的地址空间（BRK、堆、栈、MMAP、动态链接库、vDSO）是如何及何时进行随机化的，由于随机化的操作是程序运行开始阶段处理的，<strong>所以随机化选项的变更并不会影响已经运行的程序。</strong></p>
<p>尽管不同地址空间的随机化方式都是根据随机值进行偏移，但是也可以明显的看到，不同地址空间随机化取值的方式总体上是类似的，先是通过<code>get_random_long</code>函数获取随机值，然后根据某数值进行运算，最后根据页偏移进行对齐。</p>
<p>下面对为什么使用不同数值计算的原因进行了解释。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT      12</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_random_long</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 64</span></span><br><span class="line">    <span class="keyword">return</span> get_random_u64();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> get_random_u32();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
<p>mmap、动态链接库的解释</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rndbits = mmap64_rnd_bit = mmap_rnd_bits = CONFIG_ARCH_MMAP_RND_BITS = <span class="number">32</span></span><br><span class="line"> </span><br><span class="line">(get_random_long() &amp; ((<span class="number">1UL</span> &lt;&lt; rndbits) - <span class="number">1</span>)) &lt;&lt; PAGE_SHIFT</span><br></pre></td></tr></table></figure>

<p>作用：将随机值跟页大小对齐（4kb，0x1000）；1向右移动32位比特，减1后变为32位比特空间内的最大值，特点是所有比特位全为1，当随机值和它进行与运算后，随机值会被保留下来，最后根据页大小向右移动12位，跟页大小对齐。由于运算时比特位自动扩充的原因，<code>((1UL &lt;&lt; rndbits) -  1)</code>可以保障数值占用的比特位数量在32内，在64位系统中，用户空间一般会占用48位空间，考虑到高4位会被用于区分不同的ELF文件（比如动态链接库一般是0x7xxx打头，执行文件一般0x5xxx、0x6xxx打头等等），所以系统会对低48位（32位随机值+12位页对齐值）进行设置，并不会触及高4个比特位</p>
</blockquote>
<p>栈的解释：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __STACK_RND_MASK(is32bit) ((is32bit) ? 0x7ff : 0x3fffff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_RND_MASK __STACK_RND_MASK(mmap_is_ia32())</span></span><br><span class="line"> </span><br><span class="line">random_variable = get_random_long();</span><br><span class="line">random_variable &amp;= STACK_RND_MASK;</span><br><span class="line">random_variable &lt;&lt;= PAGE_SHIFT;</span><br></pre></td></tr></table></figure>

<p>作用：设置随机值后跟页大小对齐（4kb，0x1000）；原数值和0x3fffff与运算时，只有低22个比特位会被保留下来，当跟页大小对齐后，数值大小会被扩充到34个比特位，在Linux当中，栈地址会以0x7ffx打头，占用14个比特位，所以会对低34个比特位设置。</p>
</blockquote>
<h2 id="2-绕过思路"><a href="#2-绕过思路" class="headerlink" title="2 绕过思路"></a>2 绕过思路</h2><p>下面会以程序中存在泄露地址的情况为前提进行讨论。</p>
<p>即使开启了ASLR，导致程序使用的内存地址在不断的变化，但是变化的只是基地址，程序内容的地址仍然靠基地址加文件内偏移的组合进行定位，因此程序同一元素即使每次每次运行时的地址都不一样，<strong>但它减去起始地址的偏移值永远都是固定的。</strong></p>
<p>当我们可以稳定泄露程序内某元素的地址时，就可以先借助起始地址手工计算偏移值，等到下次运行时，就可以直接通过元素的随机地址减偏移值得到随机的起始地址（比如可泄露元素的地址是Libc中，那么就相当于稳定获取Libc的基地址，进而对整个Libc进行利用）</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/04/04/basectf/9th_thformat_string_level1/format_string_level1/format_string_level1/" rel="prev" title="">
                  <i class="fa fa-angle-left"></i> 
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/04/04/basic/Canary/" rel="next" title="">
                   <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Maple</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
