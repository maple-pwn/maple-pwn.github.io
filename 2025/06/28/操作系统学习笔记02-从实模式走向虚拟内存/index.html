<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Maple"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://maple-pwn.github.io/2025/06/28/操作系统学习笔记02-从实模式走向虚拟内存/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:type" content="article"><meta property="og:title" content="操作系统学习笔记02-从实模式走向虚拟内存"><meta property="og:url" content="http://maple-pwn.github.io/2025/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E8%B5%B0%E5%90%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/index.html"><meta property="og:site_name" content="Maple"><meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><meta property="article:published_time" content="2025-06-28T08:05:26.000Z"><meta property="article:modified_time" content="2025-06-28T08:14:58.773Z"><meta property="article:author" content="Maple"><meta property="article:tag" content="OS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://maple-pwn.github.io/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/1.svg" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/1.svg"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/1.svg"><title>操作系统学习笔记02-从实模式走向虚拟内存 | Maple</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><script id="hexo-configurations">window.config={hostname:"maple-pwn.github.io",root:"/",language:"zh-CN",path:"search.json"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Hexo Theme Redefine, Redefine Your Hexo Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"Maple's blog",subtitle:{text:["lucky day"],hitokoto:{enable:!1,show_author:!0,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!0,style:"default",links:{github:"https://github.com/maple-pwn",email:"3079403765@qq.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.2",navbar:{auto_hide:!0,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-solid fa-house"},Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Github:{path:"https://github.com/maple-pwn",icon:"fa-brands fa-github"},Bookmarks:{icon:"fa-solid fa-bookmark",path:"/bookmarks/"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur",bookmark_colum:3},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:{Archives:{path:"/archives",icon:"fa-solid fa-box-archive"},Tags:{path:"/tags",icon:"fa-solid fa-tags"},Categories:{path:"/categories",icon:"fa-solid fa-list"}}},article_date_format:"YYYY-MM-DD",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2025/4/5 00:00:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><link rel="stylesheet" href="/fontawesome/sharp-solid.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-title" href="/">Maple</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-solid fa-house fa-fw"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-solid fa-box-archive fa-fw"></i> 归档</a></li><li class="navbar-item"><a target="_blank" rel="noopener" href="https://github.com/maple-pwn"><i class="fa-brands fa-github fa-fw"></i> GITHUB</a></li><li class="navbar-item"><a href="/bookmarks/"><i class="fa-solid fa-bookmark fa-fw"></i> BOOKMARKS</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>首页 </span><i class="fa-solid fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>归档 </span><i class="fa-solid fa-box-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" target="_blank" rel="noopener" href="https://github.com/maple-pwn"><span>GITHUB </span><i class="fa-brands fa-github fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/bookmarks/"><span>BOOKMARKS </span><i class="fa-solid fa-bookmark fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/tags"><span>Tags</span> <i class="fa-solid fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active" href="/categories"><span>Categories</span> <i class="fa-solid fa-list fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div><div class="label text-third-text-color text-sm">标签</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">分类</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div><div class="label text-third-text-color text-sm">文章</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">操作系统学习笔记02-从实模式走向虚拟内存</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/1.svg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Maple</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-06-28 16:05:26</span> <span class="mobile">2025-06-28 16:05:26</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-06-28 16:14:58</span> <span class="mobile">2025-06-28 16:14:58</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/OS/">OS</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/OS/">OS</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="0x04-进入保护模式"><a href="#0x04-进入保护模式" class="headerlink" title="0x04 进入保护模式"></a>0x04 进入保护模式</h2><h3 id="0x04-00-基础知识"><a href="#0x04-00-基础知识" class="headerlink" title="0x04 00 基础知识"></a>0x04 00 基础知识</h3><p><strong>保护模式</strong></p><p>前面介绍过实模式，就是程序编址都在物理地址下进行。但是这种编址模式必然不会适合如今的计算机，因此产生了保护模式。</p><p>寻址位数扩展的32位，按字节编地址，则寻址范围大小就有2^32，即为4GB。但有个例外，段基地址寄存器仍然是16位，就是上述S结尾的寄存器们，这是因为：那就是此时的段基址寄存器里面所保存的已经不再是基地址了，而是<strong>选择子</strong>，这里我们只需要知道段基址还是16位寄存器，而且寻址方式还是段基址加上偏移就够了。</p><p>在保护模式中，我们在访问段的时候必须添加一定约束，比如说访问控制等，这些控制条件不可能在一个寄存器中放下，因此设计了一种新的数据结构——<strong>全局描述表（GDT）</strong>。这个表里每一个表项称为<strong>段描述符</strong>，其大小为64字节，这个描述符就用来描述自己所对应的哪个内存段的其实地址、大小、权限等信息。而这个全局描述表由于表示内存所有段信息，所以十分大，因此存在一个叫做<strong>GDTR寄存器</strong>专门指向<strong>表地址</strong>。</p><p>这样之后，段基址寄存器所保存的就是寻址段在全集描述表下的某一段描述符的索引（简单来说，就是段基址寄存器保存的是索引，而真正的数据写在了一个数据结构中）。此外有一些内容需要指出：</p><ol><li><p>段描述符位于内存当中，这对于CPU来说很慢</p></li><li><p>段描述符格式比较奇怪，一个数据需要分三个地方存储，对CPU来说很麻烦</p></li></ol><p>而为了解决这个问题，80286的保护模式给出了解决方案：<strong>缓存技术</strong>，将段信息用一个寄存器来保存，这就是<strong>段描述符寄存器</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CPU分级、段描述符等内容介绍 点击查看更多</summary><div class="content"><p><strong>CPU分级</strong></p><p>首先看CPU分级。如下图所示，在这个图中，<strong><code>ring的数值越小，权限就越大</code></strong>。如果低权限访问高权限的东西，就会导致失败（例如ring3访问ring0的内容，就会被拒绝）。其中，kernel使用了<code>ring0</code>,windows只用了<code>ring3</code></p><p><img lazyload src="/images/loading.svg" data-src="/./../images/o_2109200928364-8.png" alt="o_2109200928364-8"></p><p><strong>GDT和LDT</strong></p><p>和一个段有关的信息需要8个字节来描述，这就是段描述符，每个段都需要一个描述符。为了存放这些描述符，需要在内存内中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放，这就构成了一个描述符表。有GDT和LDT两种，结构如下</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/929457-20161229204511398-1779477258.png" alt="929457-20161229204511398-1779477258"></p><p>当我们执行类似<code>mov ds, ax</code>指令时，CPU会查表，根据<code>ax</code>的值来决定查找<code>GDT</code>还是<code>LDT</code>，并找到对应的段描述符。</p><p><code>GDT</code>存放在内存中，因此CPU想要找到它，就需要知道它的位置，于是有一个叫做<code>GDTR</code>的寄存器专门存放GDT表的位置和大小，是一个特殊的48位寄存器，C语言表示如下</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GDTR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD GDTBase;	<span class="comment">//GDT表的地址（32位）</span></span><br><span class="line">    SHORT limit;	<span class="comment">//GDT表的大小（16位）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>段选择子</strong></p><p>段选择子结构简单，它是一个16位的描述符，指向了定义该段的段描述符。结构如下所示</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/o_2109200226344-2-1750777379427-1.png" alt="o_2109200226344-2"></p><p>成员解释如下：</p><table><thead><tr><th>成员</th><th>功能</th></tr></thead><tbody><tr><td>RPL</td><td>请求特权级别，即用什么权限来请求</td></tr><tr><td>TI</td><td>TI&#x3D;0的时候，查GDT；否则查LDT</td></tr><tr><td>Index</td><td>处理器将索引值乘以8再加上GDT或者LDT的基地址，就是要加载的段描述符</td></tr></tbody></table><p><strong>段描述符</strong></p><p>段描述符的结构如下所示</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/o_2109191244474-1.png" alt="o_2109191244474-1"></p><p>成员解释如下</p><table><thead><tr><th align="center">成员</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">P位</td><td align="left">P&#x3D;1时段描述符有效；否则无效</td></tr><tr><td align="center">Base</td><td align="left">Base的低16位被放到了段描述符的低4个字节；高16位被均分到段描述符的高四个字节的头和尾。最后使用时需要拼接起来</td></tr><tr><td align="center">Limit</td><td align="left">由图可知，把段描述符中所有的Limit拼接起来就只有20位。上一节教程说它有32位的Limit。那就是要看<code>G位</code>了</td></tr><tr><td align="center">G位</td><td align="left">如果G&#x3D;0，说明Limit的单位是字节，段长度<code>Limit</code>的范围可从1B ~ 1MB（即在20位前面补3个0）；G&#x3D;1，Limit的单位是字节为4KB，段长度Limit的范围可从4KB ~ 4GB（在20位的后面补充FFF)。<em>例如：如果Litmit拼接后位FFFFF，如果G&#x3D;0，则为000FFFFF，否则为FFFFFFF</em></td></tr><tr><td align="center">S位</td><td align="left">s&#x3D;1则为代码段或者数据段描述符。否则为系统段描述符；<em>在CPU眼中，凡是硬件运行所需要的东西都可称之为系统，凡是软件运行所需要的东西都可以称之为数据，无论是代码、还是数据，包括栈都是作为硬件的输入，都只是给硬件提供数据而已</em></td></tr><tr><td align="center">TYPE域</td><td align="left">这个内容较为复杂，不做过多介绍，可自行搜索</td></tr><tr><td align="center">DPL</td><td align="left">描述符特权级别，规定了访问该段所需要的特权级别是什么。如果通俗的理解，就是：如果你想访问我，那么你应该具备什么权限。</td></tr><tr><td align="center">DB段</td><td align="left">用来指示有效地址（段内偏移地址）及操作数大小。 <strong>对于代码段来说</strong>，此位为D位，若D为0,则表示有效地址和操作数为16,指令有效地址用IP寄存器。若D为1,表示指令有效地址及操作数为32位，指令有效地址用EIP寄存器。<strong>对于栈段来说</strong>，此位为B位，用来指定操作数大小，若B为0则使用个SP寄存器，若B为1使用esp寄存器。</td></tr></tbody></table></div></details><p><strong>打开A20地址线</strong></p><p>首先了解一下<code>地址回绕</code>:在处于实模式下时，只有20位地址线，即A0～A19,20位地址线能表示2^20字节，即为1MB大小，0x0～0xFFFFF，若内存超过1MB，则需要21条地址线支持。因此若地址进位到1MB以上，由于没有21位地址线，则会丢弃多余位数。</p><p>随着CPU的发展，地址线更加多了，但是为了兼容性的问题，实模式下应该和之前的8086一模一样，即只使用20条地址线。但是，A20地址线是存在的，若访问0x100000 ~ 0x10FFEF之间的内存，系统会直接访问这块物理内存，而不会回绕</p><p>为了解决这个问题，IBM在键盘控制器上的一些输出线来控制第21根地址线的有效性，称为A20Gate</p><ul><li>A20打开，则不回绕</li><li>A20关闭，则回绕</li></ul><p>这就兼容了实模式和保护模式。所以我们在进入保护模式前需要打开A20地址线，操作就如同读取硬盘控制器类似，将端口0x92的第一位置为1即可</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in al, 0x92</span><br><span class="line">or al, 0000_0010B</span><br><span class="line">out 0x92, al</span><br></pre></td></tr></table></figure></div><h3 id="0x04-01-实现"><a href="#0x04-01-实现" class="headerlink" title="0x04 01 实现"></a>0x04 01 实现</h3><p>代码中有很多东西值得去记一记</p><p><strong>首先就是控制寄存器CR0.</strong></p><p><img lazyload src="/images/loading.svg" data-src="/./../images/1586953-20220225155636449-1472084699.png" alt="1586953-20220225155636449-1472084699"></p><p>比较重要的是<code>PE</code>位，它是启用保护模式的控制标志;而<code>PG</code>位是分页机制的开启控制，后面会谈</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x00000001</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure></div><p><strong>loader.S的编写</strong></p><ol><li>首先肯定是规定好需要的栈指针地址，这一点我们其实在0x03中的<code>boot.inc</code>中已经完成，这里引用就行了</li></ol><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;LOADER_BASE_ADDR = 0x900</span><br><span class="line">section loader vstart = LOADER_BASE_ADDR	;起始地址设置</span><br><span class="line">LOADER_STACK_TOP equ LOADER_BASE_ADDER		;loader在实模式下的栈指针地址</span><br><span class="line">jmp loader_start</span><br></pre></td></tr></table></figure></div><blockquote><p>equ是一个伪指令，用于定义<strong>符号常量</strong>，它的作用是将一个标识符与一个具体的域或表达式永久绑定；可以理解为C中的#define</p></blockquote><ol start="2"><li><p>接着在loader开始前，我们应该手搓一个gdt和它的内部描述符，让后面gdtr有地方可以寻址，让我们再看一眼gdt的结构</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/794592-20180430085632351-152401329.jpg" alt="794592-20180430085632351-152401329"></p><p><img lazyload src="/images/loading.svg" data-src="/./../images/bVcSMIr.webp" alt="bVcSMIr"></p><p>大概照此定义gdt以及内部描述符、然后是选择子、gdt的指针</p></li><li><p>编写loader_start,做一个实模式的测试</p></li><li><p>接着进入保护模式</p><ol><li>打开A20</li><li>加载GDT</li><li>cr0第0位置设置为1，保护模式开启</li><li>刷新流水线（后面解释，别急）</li></ol></li><li><p>对保护模式操作</p></li></ol><p><strong>处理器微架构（刷新流水线）</strong></p><p><strong>流水线</strong></p><p>即不同指令的不同阶段可以并行执行，以提高CPU处理效率的方式</p><p>例如：顺序执行vs流水线执行</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令1：| 取指 | 译码 | 执行 | 访存 | 写回 |</span><br><span class="line">指令2：                     | 取指 | 译码 | 执行 | 访存 | 写回 |</span><br><span class="line">指令3：                                           | 取指 | 译码 | 执行 | 访存 | 写回 |</span><br></pre></td></tr></table></figure></div><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时钟周期 | 1   | 2   | 3   | 4   | 5   | 6   | 7   |</span><br><span class="line">---------------------------------------------------</span><br><span class="line">指令1    | 取指 | 译码 | 执行 | 访存 | 写回 |     |     |</span><br><span class="line">指令2    |     | 取指 | 译码 | 执行 | 访存 | 写回 |     |</span><br><span class="line">指令3    |     |     | 取指 | 译码 | 执行 | 访存 | 写回 |</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/./../images/80a2e470b73c656fa404990099f72309.png" alt="80a2e470b73c656fa404990099f72309"></p><p>这样子到操作可以极快的提高CPU的运算速度，但是在遇到if、for、switch等语言结构的时候，就需要进行<strong>分支预测</strong>，依此来判断哪边代码出现的概率大，然后就将其加入流水线。</p><p>但是这可能会出现预测错误，于是清空流水线产生了，结合我们写在<code>loader.S</code>中的代码进行解释</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SELECTOR_CODE:p_mode_start	;刷新流水线</span><br></pre></td></tr></table></figure></div><ul><li>首先，段描述符缓冲区寄存器还没有更新，他还是实模式下的值，而进入保护模式需要填充正确的信息</li><li>其次，在默认情况下，若未使用bits伪指令来设置运行环境，编译器将一直以16位实模式来作为指令编译格式，我们都知道CPU为了提高流水线效率而采用了流水线，这样指令间就是重叠执行的，我们在执行<code>jmp dword SELECTOR_CODE:p_mode_start</code>指令时他仍是被编译为16位，因此咱们添加了dword为指令，因此其机器码会添加0x66模式反转前缀，而在这条指令之后由于添加了bits 32 伪指令，所以之后全是32位指令</li></ul><p>那么这段代码干了什么呢：</p><blockquote><p>在我们即将要吧cr0的pe位置1时，它之后的部分指令已经被送上流水线，但是段描述符缓冲寄存器在实模式下以及使用了，其中低20位为段基址，但其他位默认为0,因此描述符中的D位为0,表示16位，这就出了点问题了，也就是说现在流水线上的指令都是按照16位操作数来译码的，所以我们现在所做的工作是既要改变代码段描述符缓冲寄存器的值，又要清空流水线</p><p>代码段寄存器cs只有用 过程调用指令call，远转移指令jmp、远返回指令retf等指令间接改变，没有直接改变cs的方法。而CPU遇到jmp指令时，会将已经送上流水线的指令清空，所以jmp有着清空流水线的功效。</p></blockquote><h2 id="0x05-内存容量检查及内存分页"><a href="#0x05-内存容量检查及内存分页" class="headerlink" title="0x05 内存容量检查及内存分页"></a>0x05 内存容量检查及内存分页</h2><h3 id="0x05-00-基础知识"><a href="#0x05-00-基础知识" class="headerlink" title="0x05 00 基础知识"></a>0x05 00 基础知识</h3><p>在进入内核知识之前，先简单了解一下如何获取物理内存容量。因为我们要在后期做好内存管理工作，应该先知道自己有多少物理内存不是嘛</p><p><strong>Linux获取内存的基本方法</strong></p><p>在linux的2.6内核中，使用detect_memory函数获取内存容量，但是查看函数源码，我们可以发现这个函数的本质上是通过调用BIOS中断0x15的三个子功能实现的，源码可见<a class="link" target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v2.6.39.4/source/arch/x86/boot/memory.c#L122">这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p><ul><li>eax &#x3D; 0xe820:遍历主机上全部内存</li><li>ax &#x3D; 0xe801:分别检测低15MB和16MB~4GB内存，最大支持4GB</li><li>AH&#x3D; 0x88:最多检测64MB内存，实际内存超过此容量也按照64MB返回</li></ul><p>下面介绍一下第一种方式</p><p><strong>利用BIOS中断0x15子功能0xe820获取内存</strong></p><p>这个方式获取的返回信息最多，但因为信息过多，所以我们需要一种方式来组织这些数据，这种结构称之为ARDS（地址范围描述符），汇编伪代码如下</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARDS_struct:</span><br><span class="line">    BaseAddrLow   dd 0    ; 低 32 位基地址</span><br><span class="line">    BaseAddrHigh  dd 0    ; 高 32 位基地址</span><br><span class="line">    LengthLow     dd 0    ; 低 32 位长度</span><br><span class="line">    LengthHigh    dd 0    ; 高 32 位长度</span><br><span class="line">    Type          dd 0    ; 内存类型</span><br></pre></td></tr></table></figure></div><p>BIOS按照上述类型来返回内存信息是因为这段内存可能有下面几种情况</p><ul><li>系统的ROM</li><li>ROM用到了这部分内存</li><li>设备内存映射到了这部分内存</li><li>某种原因导致这部分内存不适合标准设备使用</li></ul><p>相关的寄存器如下</p><table><thead><tr><th align="left">寄存器</th><th align="left">输入参数（调用前）</th><th align="left">输出参数（返回后）</th></tr></thead><tbody><tr><td align="left">EAX</td><td align="left"><code>0xE820</code>（功能号）</td><td align="left">可能被修改（某些 BIOS 实现会保留）。</td></tr><tr><td align="left">EBX</td><td align="left">连续调用索引（首次调用设为 <code>0</code>）</td><td align="left">下一个索引（若 <code>EBX=0</code> 表示遍历完成）。</td></tr><tr><td align="left">ECX</td><td align="left">ARDS 结构大小（通常 <code>20</code> 字节）</td><td align="left">实际写入的字节数（通常 <code>20</code>）。</td></tr><tr><td align="left">EDX</td><td align="left"><code>&#39;SMAP&#39;</code>（签名 <code>0x534D4150</code>）</td><td align="left">保持不变。</td></tr><tr><td align="left">ES:DI</td><td align="left">ARDS 缓冲区指针（存放返回的内存描述符）</td><td align="left">填充后的 ARDS 结构。</td></tr></tbody></table><p><strong>虚拟地址</strong></p><p>这里拿物理地址做一个对比。物理内存可以认为是一个物理字节数组，每个物理地址指向这个物理字节数组中的一项；而虚拟内存也可以理解为一个物理字节数组，但是这个字节数组是存储在磁盘上的。</p><p>综上呢，物理地址空间中的每个物理地址都是实打实地指向了具体的存储单元，虚拟地址空间中每个虚拟地址指向哪里有3种情况：</p><ul><li>未分配：这个虚拟地址仅仅只是数字，没有任何指向</li><li>未缓冲：这个虚拟地址指向了磁盘的某个字节存储单元，里面存储了指令或者数据</li><li>已缓冲，这个虚拟地址指向了物理内存的某个字节存储单元，里面存储了指令或者数据</li></ul><p>回到我们自己的操作系统，这里只有512MB的物理内存，但是32位操作系统的最大寻址空间是4GB。但对于程序来说它不知道，它只知道它在一个32位系统上，应该有4GB的内存空间供它加载，那么怎么加载的问题就是由链接器决定，也就是由程序员自行决定。但是问题依旧在，512MB的内存怎么够4GB活动呢？于是我们将整片程序中的一部分称为页，然后我们按照自己的需要映射到真实的物理内存当中，此时我们并不需要一次性全部放到物理内存当中</p><p>这样就可以给程序一个假象，它认为自己在一个4GB的连续空间中加载，但实际上，它早就被切片成一个个小小的部分，分配到一定的地址里，不再连续。操作系统的作用就是映射，将虚拟内存映射到真正的内存里。</p><p>接下来分析一下这个<strong>切片</strong>————页。一般页被分为4KB（对应12位地址），而我们是32位系统，所以高20位为页地址，低12位是页内的地址，在我们本来的程序中是进行了分段的操作，但是载入物理内存的过程中就会进行分页而打乱顺序，此时就需要用到页表，而表中保存的就是一个个映射，保证你按照顺序访问虚拟地址。然后，根据页地址的划分，我们又可以分为一层页表、二层页表等等</p><p>先介绍一下一层页表，后面其实就很好理解了</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/57b756ecbbfab86be150b83088c691db.jpg" alt="57b756ecbbfab86be150b83088c691db"></p><p>任意地址最终会落在某个物理页上，那么定位到某个具体物理页，然后给出物理页内的偏移量就可以访问到任意1字节的内存。<strong>所以用20位2进制就可以表示全部的物理页，12位二进制就可以表达4KB之内的任意地址</strong></p><p>接下来有了另一个问题， 我们该怎么在线性地址中找到页表中对应的页表项？</p><blockquote><ol><li>分页机制打开前要将也表地址加载到寄存器cr3中，这是启用分页机制的先决条件之一。所以在打开分页机制前加载到寄存器cr3中的是页表的物理地址，页表中页表项的地址自然就是物理地址了</li><li>内存分页机制的作用是将虚拟地址转化为物理地址，但其转化过程相当于在关闭分页机制下进行，过程所涉及到的页表以及页表项的寻址，他们的地址都被CPU当作最终的物理地址直接送上地址总线，不会被分页机制再次转换</li></ol><p>那么想要访问其中任意页表项的成员，只要知道该页表项的索引（下标）就可以了：</p><p>一个页表项对应一个页，所以用线性地址高20位作为页表项的索引，每个页表项要占用4字节大小，所以这高20位的索引乘以4后才是该页表项的物理地址，从该页表项中得到映射的物理页地址，然后用线性地址的低12位与该物理页地址相加，所得到的地址之和就是最终要访问的物理地址</p></blockquote><p>下面是一个二层页表结构的图</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/ad9f77b363cafa568b1541bae0efb539.png" alt="ad9f77b363cafa568b1541bae0efb539"></p><blockquote><p>其实有一个很关键的问题，都已经有一级表了，要二级表干嘛？</p><ol><li>一级页表中最多可容纳1M(1048576)个页表项，每个页表项是4字节，如果页表项全满，就是4MB</li><li>一级页表中所有页表项必须要提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB，用户进程要占用3GB</li><li>每个进程都有自己的页表，进程一多，页表占用的空间就会很大</li></ol><p>总而言之，我们要解决的问题就是：我们怎么样动态的创建页表项呢？</p></blockquote><p>每个页都是4KB是不变的（大页除外）。所以4GB线性空间最多有1M个标准页也是不变的。以及标准也是将这1M个标准页放置到一张页表中，二级页表是将这1M个标注你也表平均放置1K个页表中。每个页表中包含1K个表项。页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB,合适得很</p><blockquote><p>二级页表地址转换原理是将32位虚拟地址拆分成高10位，中10位，低12位。高10位作为页表的索引，用于在页目录表中定位一个页目录项PDE，页目录项中有页表物理地址，也就是定位到了某个页表。中间10位作为物理页的索引，用于在页表内定位到某个页表项PTE，页表项有分配的物理页地址，也即是定位到了某个物理页。低12位作为页内偏移量用于在已经定位到的物理页内寻值</p></blockquote><p>之后的四层甚至更多，其实也是按照这种样子，将寻址做的一层层，就不多说了</p><p><strong>使用虚拟地址访问页表</strong></p><p>我们在程序进行的过程中，免不了会进行类似于malloc等的内存申请，或者说因为管理内存而许纳泽释放块，所以页表应该是一个动态的概念（跟上面二级页表的优点一致），应该随着我们的要求来增加或者说删减。</p><p>要实现这个功能我们首先就得使用虚拟地址访问到页表，我们可以将页目录的最后一项保存为页目录的首地址</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [PAGE_DIR_TABLE_POS + 4092], eax	;使得最后一个目录项地址指向页目录表自己的地址</span><br></pre></td></tr></table></figure></div><p><img lazyload src="/images/loading.svg" data-src="/./../images/image-20250627162509634.png" alt="image-20250627162509634"></p><p>这里根据这个分析一下虚拟地址与物理地址的映射关系（左边是32位虚拟地址的范围，右边是虚拟地址对应的物理地址，不过用48位表示。分析各行的映射结果</p><blockquote><blockquote><p>第一行，虚拟地址0x00000000~0x000fffff,这是虚拟空间低端1M内存，其对应的物理地址是0x000000000000～0x0000000fffff。这是第0个页表起的作用，ecx&#x3D;256就是为256个页表项分配物理页</p></blockquote><blockquote><p>第二行，虚拟地址0xc0000000~0xc00fffff，这是第768个页表起的作用。由于第0个页目录项和第768个页目录项指向的是同一个页表，所以其映射的物理地址依然是0x000000000000-0x0000000fffff</p></blockquote><p>接下来就出现了三个比较奇怪的页项</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xffc00000～0xffc00fff -&gt; 0x000000101000～0x000000101fff</span><br><span class="line">0xfff00000～0xfff00fff -&gt; 0x000000101000～0x000000101fff</span><br><span class="line">0xfffff000～0xffffffff -&gt; 0x000000100000～0x000000100fff</span><br></pre></td></tr></table></figure></div><blockquote><p>首先第一个，<code>0xffc00000～0xffc00fff -&gt; 0x000000101000～0x000000101fff</code></p><p>虚拟地址的高10位用来访问页目录表中的目录项，如果高10全为1，这就说明我们访问此虚拟地址的时候访问的是最后一个页目录项，而最后一个页目录项保存的不是页表地址，而是页目录的地址，这样我们的及其就会将页目录看成一个页表来理解，此时我们页目录最后一项保存的是0x101000,所以我们也会映射到0x101000-0x101fff</p></blockquote><blockquote><p><code>0xfff00000～0xfff00fff -&gt; 0x000000101000～0x000000101fff</code></p><p>首地址0xfff00000来分析，高10位全是1表示该虚拟地址在页目录中对应的是最后一个页目录项，目前为止同上面是一致的，然后我们取中间10位发现其为0x300，对应的是页目录项中第0x300表项也就是偏移为0xc00的地方，这里我们之前将其的地址也改为了第0个页表地址，所以此时这段映射会映射到0x101000-0x101fff</p></blockquote><blockquote><p><code>0xfffff000～0xffffffff -&gt; 0x000000100000～0x000000100fff</code></p><p>首地址分析可知，高10位和中10位都是1，所以我们呢首先会查看页目录最后一页，然后将页目录表当作页表看待，然后我们再次访问页目录最后一项，我们认为它是页表最后一项，这里保存的仍然是0x100000，所以我们这里的映射是0x100000-0x100fff</p></blockquote></blockquote><h3 id="0x05-01-实践代码"><a href="#0x05-01-实践代码" class="headerlink" title="0x05 01 实践代码"></a>0x05 01 实践代码</h3><p>这一部分还是直接看他人的吧，这里不加赘述了</p><h2 id="02-总结"><a href="#02-总结" class="headerlink" title="02 总结"></a>02 总结</h2><p>这次我们从实模式寻址走向了页表。走过了过程如下：</p><p><strong>直接访问 -&gt; 段基址+段偏移地址 -&gt; 段选择子+段偏移地址 -&gt; 虚拟地址</strong></p><p>让我们重新串联一次</p><h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>直接访问是<strong>实模式</strong>最为核心的特征和设计目标，可以说，实模式就是为了实现程序对物理内存的<strong>无限制、直接访问</strong>而存在的，如下图所示</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/5218ac675cef726035d788ad296cd490.png" alt="5218ac675cef726035d788ad296cd490"></p><p>上图可执行文件中1000~1024之间的地址加载到内存的后内存的地址也是1000 ~ 1024，在可执行文件中分配的唯一地址就是内存中的物理地址</p><blockquote><p>问题随之而来：同一个可执行文件不可以同时执行，因为他们的物理地址是一样的，这会导致冲突。还有就是这个可执行文件的物理地址已经固定了，如果想在其它物理地址上运行，必须重新编译</p></blockquote><h3 id="段基址-段偏移地址"><a href="#段基址-段偏移地址" class="headerlink" title="段基址+段偏移地址"></a>段基址+段偏移地址</h3><p>随着多任务需求的来临，直接定位的方法必然被淘汰，于是开发者们发明了段基址+段偏移地址。</p><p>实模式通过段寄存器（CS，DS，ES，SS)和偏移地址（IP，SI，DI，BX，SP，BP）来计算物理地址<br>$$<br>物理地址&#x3D;(段寄存器 * 16) + 偏移地址<br>$$<br>如下图所示的定位偏移</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/1affb0741f1c27f8e186b9dfca415b2d.png" alt="1affb0741f1c27f8e186b9dfca415b2d"></p><p>右边红色就是存储的偏移，<code>0 4 8</code>是相对于数据段的偏移地址，<code>0 4 8 12</code>是相对于代码段的偏移地址。</p><p>当可执行文件加载到内存时，现在内存中分配一个数据段和代码段（这两个段理论上可以分开存储）</p><p>当CPU开始执行代码段的第一条指令的时候，会将代码段的其实地址放入到段寄存器中，此时CS代码段寄存器中存储的就是0x00600000 -&gt; 开始从起始地址处开始执行第一条代码指令，此时把代码指令的偏移地址放入到IP寄存器中，IP寄存器存储的就是0，所以CPU要定位一条代码指令时通过<code>CS：IP</code>的方式定位，正如下图所示</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/3334e09798148098b37d0373d66cb431.png" alt="3334e09798148098b37d0373d66cb431"></p><blockquote><p>这种定位方式不再固定程序的执行位置，而是靠相对偏移来或许对应数据，较于直接访问更加灵活，也允许同一程序的同时运行了。</p><p>但依旧存在问题：程序之间没有内存隔离，是一块完整的程序，一个程序就可以轻易的破坏另一个程序或者操作系统的内存，过于危险。</p></blockquote><h3 id="段选择子-段偏移地址"><a href="#段选择子-段偏移地址" class="headerlink" title="段选择子+段偏移地址"></a>段选择子+段偏移地址</h3><p><code>段选择子+段偏移地址</code>和<code>段基址+段偏移地址</code>形式相似，发明他的意义就是为了安全</p><p><strong>段选择子+段偏移地址</strong>中的<strong>段选择子</strong>可以认为是一个索引，这个索引指向了那两个全局段描述符表中的一项，全局段描述表存储在内存中，它的起始地址存储在全局段描述符寄存器中</p><ul><li><strong>段选择子</strong>是一个16位的值，存储在段寄存器中，<code>本身不包含任何内存地址信息</code>，高13位就是全局段描述表的索引</li><li><strong>段偏移地址</strong>是由指令指针（EIP）、通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP）或其它寻址方式产生的32位或64位地址。它制定了<strong>段内</strong>具体位置</li><li><strong>段描述符</strong>是保护模式的关键数据结构，它是一个8字节（64位）的表项，存储在全局描述表GDT或局部描述符表LDT中<ul><li><strong>段基址</strong>：该段在物理内存中的起始地址（32位）</li><li><strong>段界限</strong>：该段的最大有效偏移（20位，配合粒度决定单位是字节还是4KB页）</li><li><strong>访问权限&#x2F;属性</strong>，包括：<ul><li>是否存在于内存</li><li>描述符特权级：访问该段所需的最低CPU特权级</li><li>类型（Type）:代码段、数据段、堆栈段；可读、可写、可执行等</li><li>其它标志</li></ul></li></ul></li></ul><p>计算过程：</p><p>将代码段的选择子放入到CS段寄存器中 -&gt; CPU从段寄存器中获取段选择子 -&gt; 截取选择子的高13位获取索引 -&gt; 根据全局描述符表寄存器的地址找到全局描述符表的起始地址 -&gt; 根据 <code>起始地址 + 索引 * 8</code>获取段的地址 -&gt; 段的基址加上ip寄存器中的偏移地址得到指令的物理地址</p><p>如下图1~6</p><p><img lazyload src="/images/loading.svg" data-src="/./../images/c30f20c530950bcaedcd9e368dcaa577.png" alt="c30f20c530950bcaedcd9e368dcaa577"></p><blockquote><p>截止目前，段选择子 + 段偏移地址通过索引GDT（全局描述符表），成功将逻辑地址转换为线性地址（其实是在逻辑地址和线性地址间添加了一层GDT抽象，用于解析段基址）。成功的将各个内存隔离开来，保护模式确实安全了很多</p><p>但同样的，问题依旧存在：纯分段机制导致内存被划分成大小不一的段，当程序结束时，内存会留下一个个空洞，这样导致内存使用效率越来越低，连续的大内存越来越难找。并且，这里映射出来的还是物理地址，受硬件制约过大。</p></blockquote><h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p>为了解决这个问题，分页机制产生了，当打开分页机制时，<strong>段选择子+段偏移地址</strong>得到的地址就不再是物理地址了，而是虚拟地址，默认打开分页</p><p>其核心思想是将物理内存和程序的线性地址空间都划分为固定大小的块，称为<strong>页帧</strong>，操作系统维护一个<strong>页表</strong>，负责将程序只用的<strong>虚拟&#x2F;线性地址空间中的页面</strong>映射到物理内存中的页帧或者磁盘上的交换空间。</p><p>当操作系统加载一个可执行文件后，创建了一个进程，这个进程就有了自己的虚拟地址空间，每个进程的虚拟地址空间都是一样的</p><table><thead><tr><th><img lazyload src="/images/loading.svg" data-src="/./../images/0b6a5cd9f7f9d8aafabcbdc271f06a7d.png" alt="0b6a5cd9f7f9d8aafabcbdc271f06a7d"></th></tr></thead><tbody><tr><td><em>进程虚拟地址空间</em></td></tr></tbody></table><p>如上图所示，进程的虚拟地址空间被统一划分成了多个固定区域。其中内核区域是操作系统自己的代码，内核在物理内存中只存储一份，每个进程将这个区域的虚拟地址映射到同一份内核物理内存上，如下图所示</p><table><thead><tr><th><img lazyload src="/images/loading.svg" data-src="/./../images/63ebf0eefc696fd971d295bc442d4e68.png" alt="63ebf0eefc696fd971d295bc442d4e68"></th></tr></thead><tbody><tr><td><em>内核和共享库的映射</em></td></tr></tbody></table><p>虚拟页存储在磁盘上，物理页则存储在DRARM上</p><p>通常操作系统加载可执行文件后，创建了一个进程，这个进程就有了虚拟地址空间，这并不意味着可执行文件已经从磁盘加载到内存中了，操作系统只是为了进程虚拟地址空间的每个区域分配了虚拟页。</p><p>代码和数据区域的虚拟页被分配到了可执行文件的适当位置，此时虚拟页状态为未缓冲，虚拟页指向了磁盘地址。之后通过翻译，可以成功映射到应有的物理地址中。而多级页的存在是为了加快这个速度（这个很好理解，可以看作从线性搜索变成了2分搜索这样子）</p><p>综上，我们走完了从实模式开始到现代虚拟地址的内存管理模式，这篇文章告一段落，内容真的好长啊。</p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 操作系统学习笔记02-从实模式走向虚拟内存</li><li><strong>作者:</strong> Maple</li><li><strong>创建于 :</strong> 2025-06-28 16:05:26</li><li><strong>更新于 :</strong> 2025-06-28 16:14:58</li><li><strong>链接:</strong> https://github.com/maple-pwn/maple-pwn.github.io/2025/06/28/操作系统学习笔记02-从实模式走向虚拟内存/</li><li><strong>版权声明: </strong>本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/OS/">#OS</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2025/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8%E5%88%B0%E4%B8%AD%E6%96%AD/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">操作系统学习笔记03-从初始内核到中断</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2025/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E4%BB%8EPOST%E5%88%B0Loader/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">操作系统学习笔记01-从POST到Loader</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">目录</div><div class="page-title">操作系统学习笔记02-从实模式走向虚拟内存</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="nav-text">0x04 进入保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04-00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">0x04 00 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04-01-%E5%AE%9E%E7%8E%B0"><span class="nav-text">0x04 01 实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F%E6%A3%80%E6%9F%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="nav-text">0x05 内存容量检查及内存分页</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x05-00-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-text">0x05 00 基础知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x05-01-%E5%AE%9E%E8%B7%B5%E4%BB%A3%E7%A0%81"><span class="nav-text">0x05 01 实践代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-%E6%80%BB%E7%BB%93"><span class="nav-text">02 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="nav-text">直接访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%9F%BA%E5%9D%80-%E6%AE%B5%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="nav-text">段基址+段偏移地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90-%E6%AE%B5%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="nav-text">段选择子+段偏移地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-text">虚拟地址</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2025</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Maple</a><p class="post-count space-x-0.5"><span>共撰写了 8 篇文章</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/localSearch.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/libs/mermaid.min.js"></script><script src="/js/build/plugins/mermaid.js"></script><script src="/js/build/libs/anime.min.js"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/bookmarkNav.js" type="module"></script></body></html>